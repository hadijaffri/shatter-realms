<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ShatterRealms - Realism Edition</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="menu">
        <h1>SHATTERREALMS</h1>
        <h2>Realism Edition</h2>
        <div id="deviceSelect">
            <p style="color: #aaa; margin-bottom: 15px;">Select your device:</p>
            <button class="menu-btn" onclick="selectDevice('computer')">üñ•Ô∏è Computer</button>
            <button class="menu-btn" onclick="selectDevice('mobile')">üì± Mobile</button>
        </div>
        <div id="startSection" style="display: none;">
            <button class="menu-btn" onclick="startGame()">‚öîÔ∏è Solo Play</button>
            <button class="menu-btn" onclick="joinMultiplayer()" style="background: linear-gradient(135deg, #4a0080, #800080);">üë• Multiplayer</button>
            <button class="menu-btn shop-btn" onclick="openShop()">üõí Shop</button>
            <button class="menu-btn" onclick="openInventory()" style="background: linear-gradient(135deg, #9b59b6, #8e44ad);">üì¶ Inventory</button>
            <button class="menu-btn" onclick="openFriendsPanel()" style="background: linear-gradient(135deg, #3498db, #2980b9);">üë• Friends</button>
            <button class="menu-btn settings-btn" onclick="openSettings()">‚öôÔ∏è Settings</button>
            <button class="menu-btn quit-btn" onclick="quitGame()">üö™ Quit</button>
            <div id="menuCoins" style="color: gold; margin-top: 12px; font-size: 16px;">üí∞ 0 <button id="menuAddCoins" onclick="openCustomCoinModal()" style="background: gold; color: #000; border: none; border-radius: 50%; width: 22px; height: 22px; font-size: 16px; font-weight: bold; cursor: pointer; margin-left: 5px;">+</button></div>
        </div>
    </div>
    
    <div id="shopPanel" class="panel">
        <div class="panel-header">
            <h2>üõí SHOP</h2>
            <button class="close-btn" onclick="closeShop()">‚úï</button>
        </div>
        <div class="panel-content" id="shopItems"></div>
    </div>
    
    <div id="settingsPanel" class="panel">
        <div class="panel-header">
            <h2>‚öôÔ∏è SETTINGS</h2>
            <button class="close-btn" onclick="closeSettings()">‚úï</button>
        </div>
        <div class="panel-content" id="settingsContent"></div>
    </div>
    
    <div id="mobileControls">
        <div id="joystickZone">
            <div id="joystickBase">
                <div id="joystickKnob"></div>
            </div>
        </div>
        <button id="attackBtn" class="mobile-btn">‚öîÔ∏è</button>
        <button id="jumpBtn" class="mobile-btn">‚¨ÜÔ∏è</button>
        <button id="dashBtn" class="mobile-btn">üí®</button>
    </div>
    
    <div id="hud" style="display: none;">
        <div id="healthBar" class="bar-container">
            <span class="bar-icon">‚ù§Ô∏è</span>
            <div class="bar-fill" style="width: 100%"></div>
            <span class="bar-text">100 / 100</span>
        </div>
        <div id="energyBar" class="bar-container">
            <span class="bar-icon">‚ö°</span>
            <div class="bar-fill" style="width: 100%"></div>
            <span class="bar-text">100 / 100</span>
        </div>
    </div>
    
    <div id="coinsDisplay" style="display: none;"><span id="coinsText">üí∞ 0</span><button id="addCoinsBtn" onclick="openCustomCoinModal()">+</button></div>
    
    <div id="statsPanel" style="display: none;">
        <div><span class="stat-label">WAVE</span><br><span class="stat-value" id="waveNum">1</span></div>
        <div style="margin-top:5px;"><span class="stat-label">SCORE</span><br><span class="stat-value" id="score">0</span></div>
    </div>
    
    <div id="minimap" style="display: none;"><canvas id="minimapCanvas"></canvas></div>
    <div id="crosshair" style="display: none;"></div>
    <div id="hotbar" style="display: none;"></div>
    <div id="waveAnnounce"></div>
    <div id="clickToPlay" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 10px; font-size: 18px; z-index: 200; pointer-events: none;">Click to enable mouse controls</div>
    
    <div id="bossHealth">
        <div id="bossName">BOSS</div>
        <div id="bossBarContainer"><div id="bossFill"></div></div>
    </div>
    
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p>Wave: <span id="finalWave">1</span></p>
        <p>Score: <span id="finalScore">0</span></p>
        <p>Coins: <span id="finalCoins">0</span></p>
        <button class="menu-btn" onclick="restartGame()">‚öîÔ∏è Retry</button>
        <button class="menu-btn" onclick="backToMenu()">üè† Menu</button>
    </div>

    <div id="multiplayerLobby">
        <div class="lobby-content">
            <h2>MULTIPLAYER ARENA</h2>
            <div style="margin-bottom: 15px;">
                <label for="playerNameInput" style="color: #aaa; font-size: 12px; display: block; margin-bottom: 5px;">Player Name</label>
                <input type="text" id="playerNameInput" maxlength="20" placeholder="Enter your name..." style="padding: 8px 12px; font-size: 14px; border: 2px solid #444; border-radius: 8px; background: #222; color: white; text-align: center; width: 200px;">
                <div id="nameWarning" style="color: #ff6600; font-size: 11px; margin-top: 5px; display: none;"></div>
            </div>
            <div class="spinner" id="connectionSpinner"></div>
            <div id="lobbyStatus">Connecting to server...</div>
            <div id="connectionDetails" style="color: #888; font-size: 12px; margin: 10px 0;"></div>
            <div id="playerCount">Players: 0</div>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 10px; margin-top: 20px;">
                <button class="menu-btn" id="retryConnectionBtn" style="display: none; background: linear-gradient(135deg, #e74c3c, #c0392b); width: 200px;" onclick="retryConnection()">Retry Connection</button>
                <button class="menu-btn" onclick="leaveLobby()" style="width: 200px;">Leave Lobby</button>
            </div>
        </div>
    </div>

    <div id="multiplayerHUD" style="display: none;">
        <div id="matchTimer" style="position: fixed; top: 15px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); border: 2px solid gold; border-radius: 10px; padding: 8px 20px; color: gold; font-size: 20px; font-weight: bold; z-index: 100;">5:00</div>
        <div id="killFeed" style="position: fixed; top: 60px; right: 15px; width: 250px; z-index: 100;"></div>
        <div id="scoreboard" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); border: 2px solid gold; border-radius: 15px; padding: 20px; z-index: 300; min-width: 400px;">
            <h2 style="color: gold; text-align: center; margin-bottom: 15px;">SCOREBOARD</h2>
            <div id="scoreboardContent"></div>
        </div>
        <button id="voiceChatBtn" class="voice-chat-btn" onclick="toggleVoiceChat()" title="Voice Chat">üé§</button>
        <div id="voiceIndicators" style="position: fixed; bottom: 80px; right: 15px; display: flex; flex-direction: column; gap: 4px; z-index: 100;"></div>
    </div>

    <div id="chatContainer" style="display: none; position: fixed; bottom: 70px; left: 15px; width: 350px; z-index: 150; pointer-events: none;">
        <div id="chatMessages" style="max-height: 200px; overflow: hidden; display: flex; flex-direction: column; gap: 2px;"></div>
        <div id="chatHint" style="color: rgba(255,255,255,0.4); font-size: 11px; margin-top: 5px;">Press T to chat</div>
        <div id="chatInputContainer" style="display: none; margin-top: 5px; pointer-events: auto;">
            <input type="text" id="chatInput" maxlength="200" placeholder="Type a message..." style="width: 100%; padding: 6px 10px; font-size: 12px; border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; background: rgba(0,0,0,0.8); color: white; outline: none;">
        </div>
    </div>

    <div id="matchEndScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 400; flex-direction: column; align-items: center; justify-content: center;">
        <h1 id="matchResult" style="font-size: 48px; color: gold; margin-bottom: 20px;">MATCH OVER</h1>
        <div id="matchWinner" style="font-size: 24px; color: #0f0; margin-bottom: 30px;"></div>
        <div id="finalScoreboard" style="background: rgba(30,30,30,0.9); border: 2px solid gold; border-radius: 15px; padding: 20px; min-width: 400px; margin-bottom: 30px;"></div>
        <div id="matchReward" style="color: gold; font-size: 20px; margin-bottom: 20px;"></div>
        <button class="menu-btn" onclick="leaveMultiplayer()">Return to Menu</button>
    </div>

    <!-- AI Coin Purchase Modal -->
    <div id="customCoinModal">
        <div class="modal-content">
            <h3>Buy Coins with AI Pricing</h3>
            <p style="color: #aaa; font-size: 12px; margin-bottom: 15px;">Enter how many coins you want. Our AI will calculate the best price for you!</p>
            <input type="number" id="coinAmount" placeholder="Enter coins (50-50,000)" min="50" max="50000" value="500">
            <div id="priceDisplay">Calculating...</div>
            <div id="aiReasoning" style="color: #888; font-size: 11px; margin-bottom: 10px;"></div>
            <div class="modal-buttons">
                <button class="modal-btn buy" id="buyCoinsBtn" onclick="purchaseAICoins()">Buy Now</button>
                <button class="modal-btn cancel" onclick="closeCustomCoinModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Friends Panel -->
    <div id="friendsPanel" class="panel" style="display: none; max-width: 450px; border-color: #3498db;">
        <div class="panel-header">
            <h2 style="color: #3498db;">üë• Friends</h2>
            <button class="close-btn" onclick="closeFriendsPanel()">‚úï</button>
        </div>
        <div class="panel-content">
            <div style="text-align: center; margin-bottom: 15px;">
                <div style="color: #aaa; font-size: 11px;">Your Friend Code</div>
                <div id="myFriendCode" style="color: #3498db; font-size: 18px; font-weight: bold; margin: 5px 0;">Loading...</div>
            </div>
            <div style="margin-bottom: 15px;">
                <div style="display: flex; gap: 5px;">
                    <input type="text" id="addFriendInput" placeholder="Enter friend code (e.g. Player#1234)" style="flex: 1; padding: 8px; font-size: 12px; border: 2px solid #444; border-radius: 8px; background: #222; color: white;">
                    <button class="menu-btn" onclick="sendFriendRequest()" style="padding: 8px 15px; font-size: 12px; background: linear-gradient(135deg, #3498db, #2980b9);">Add</button>
                </div>
                <div id="friendRequestStatus" style="color: #888; font-size: 11px; margin-top: 5px;"></div>
            </div>
            <div id="pendingRequestsSection" style="margin-bottom: 15px; display: none;">
                <h3 style="color: #e67e22; font-size: 13px; margin-bottom: 8px;">Pending Requests</h3>
                <div id="pendingRequestsList"></div>
            </div>
            <div style="margin-bottom: 15px;">
                <h3 style="color: #2ecc71; font-size: 13px; margin-bottom: 8px;">Friends List</h3>
                <div id="friendsListContainer"></div>
            </div>
            <div style="margin-bottom: 15px;">
                <h3 style="color: #9b59b6; font-size: 13px; margin-bottom: 8px;">Friends Servers</h3>
                <button class="menu-btn" onclick="createFriendsServer()" style="width: 100%; padding: 8px; font-size: 12px; background: linear-gradient(135deg, #9b59b6, #8e44ad); margin-bottom: 8px;">Create Friends Server</button>
                <div id="friendsServersList"></div>
            </div>
        </div>
    </div>

    <!-- DOB Age Gate Modal -->
    <div id="dobModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 500; justify-content: center; align-items: center;">
        <div class="modal-content dob-modal-content" style="max-width: 380px;">
            <h3 style="color: #3498db; margin-bottom: 10px;">Age Verification</h3>
            <p style="color: #aaa; font-size: 12px; margin-bottom: 15px;">Voice chat requires age verification. Please enter your date of birth.</p>
            <div style="display: flex; gap: 8px; justify-content: center; margin-bottom: 15px;">
                <select id="dobMonth" class="dob-select"><option value="">Month</option></select>
                <select id="dobDay" class="dob-select"><option value="">Day</option></select>
                <select id="dobYear" class="dob-select"><option value="">Year</option></select>
            </div>
            <div id="dobError" style="color: #ff4444; font-size: 12px; margin-bottom: 10px; display: none;"></div>
            <div class="modal-buttons">
                <button class="modal-btn buy" onclick="submitDobVerification()">Verify</button>
                <button class="modal-btn cancel" onclick="closeDobModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Notification Toast Container -->
    <div id="notificationContainer" style="position: fixed; top: 15px; right: 15px; z-index: 600; display: flex; flex-direction: column; gap: 8px; pointer-events: none; max-width: 320px;"></div>

    <!-- Auth Modal -->
    <div id="authModal">
        <div class="auth-content">
            <h2>SHATTERREALMS</h2>
            <div class="subtitle">Realism Edition</div>
            <div class="auth-tabs">
                <button class="auth-tab active" onclick="switchAuthTab('login')">Log In</button>
                <button class="auth-tab" onclick="switchAuthTab('signup')">Sign Up</button>
            </div>
            <!-- Login Form -->
            <div id="loginForm" class="auth-form active">
                <div class="auth-input-group">
                    <label>Username</label>
                    <input type="text" id="loginUsername" class="auth-input" placeholder="Enter username" maxlength="20" autocomplete="username" onkeydown="if(event.key==='Enter')submitLogin()">
                </div>
                <div class="auth-input-group">
                    <label>Password</label>
                    <input type="password" id="loginPassword" class="auth-input" placeholder="Enter password" autocomplete="current-password" onkeydown="if(event.key==='Enter')submitLogin()">
                </div>
                <div id="loginError" class="auth-error"></div>
                <div id="loginSpinner" class="auth-spinner"></div>
                <button class="auth-submit-btn" onclick="submitLogin()">Log In</button>
            </div>
            <!-- Sign Up Form -->
            <div id="signupForm" class="auth-form">
                <div class="auth-input-group">
                    <label>Username</label>
                    <input type="text" id="signupUsername" class="auth-input" placeholder="Choose a username" maxlength="20" autocomplete="username" oninput="validateUsernameRealtime()" onkeydown="if(event.key==='Enter')submitSignup()">
                    <div id="usernameStatus" class="username-status"></div>
                </div>
                <div class="auth-input-group">
                    <label>Password</label>
                    <input type="password" id="signupPassword" class="auth-input" placeholder="Choose a password (min 6 chars)" autocomplete="new-password" onkeydown="if(event.key==='Enter')submitSignup()">
                </div>
                <div class="auth-input-group">
                    <label>Confirm Password</label>
                    <input type="password" id="signupConfirmPassword" class="auth-input" placeholder="Confirm password" autocomplete="new-password" onkeydown="if(event.key==='Enter')submitSignup()">
                </div>
                <div id="signupError" class="auth-error"></div>
                <div id="signupSpinner" class="auth-spinner"></div>
                <button class="auth-submit-btn" onclick="submitSignup()">Create Account</button>
            </div>
            <div class="auth-guest-link" onclick="continueAsGuest()">Continue as Guest</div>
        </div>
    </div>

    <!-- Empty Lobby Prompt -->
    <div id="emptyLobbyPrompt">
        <div class="empty-lobby-content">
            <h3>No Players Found</h3>
            <p>No other players are in the lobby right now. Would you like to switch to Solo mode?</p>
            <div class="empty-lobby-buttons">
                <button class="menu-btn" onclick="switchToSoloFromMultiplayer()" style="background: linear-gradient(135deg, #4a00e0, #8e2de2);">Go Solo</button>
                <button class="menu-btn" onclick="dismissEmptyLobbyPrompt()" style="background: #444;">Keep Waiting</button>
            </div>
        </div>
    </div>

    <!-- Inventory Management Panel -->
    <div id="inventoryPanel" class="panel" style="display: none; max-width: 600px;">
        <div class="panel-header">
            <h2>Inventory & Loadout</h2>
            <button class="close-btn" onclick="closeInventory()">x</button>
        </div>
        <div class="panel-content">
            <div style="margin-bottom: 20px;">
                <h3 style="color: gold; margin-bottom: 10px;">Equipped Hotbar</h3>
                <div id="hotbarConfig" style="display: flex; gap: 5px; justify-content: center;"></div>
                <p style="color: #888; font-size: 10px; margin-top: 5px;">Drag weapons here or click to equip</p>
            </div>
            <div>
                <h3 style="color: #0f0; margin-bottom: 10px;">Your Weapons</h3>
                <div id="inventoryGrid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;"></div>
            </div>
            <div style="margin-top: 20px; text-align: center;">
                <button class="menu-btn" onclick="generateNewWeapon()" id="generateWeaponBtn" style="background: linear-gradient(135deg, #9b59b6, #8e44ad);">
                    Generate New Weapon (AI)
                </button>
                <p style="color: #888; font-size: 10px; margin-top: 5px;">Uses AI to create a unique weapon!</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post-processing for hyper-realistic graphics -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
    <script>
        // Cookie helpers for persistent data
        function setCookie(name, value, days = 365) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = name + '=' + encodeURIComponent(value) + '; expires=' + expires + '; path=/; SameSite=Lax';
        }

        function getCookie(name) {
            const value = document.cookie.split('; ').find(row => row.startsWith(name + '='));
            return value ? decodeURIComponent(value.split('=')[1]) : null;
        }

        // Generate or retrieve device ID
        function getDeviceId() {
            let deviceId = getCookie('deviceId');
            if (!deviceId) {
                deviceId = 'dev_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
                setCookie('deviceId', deviceId);
            }
            return deviceId;
        }

        // Initialize device ID on load
        const deviceId = getDeviceId();

        // Game State
        let scene, camera, renderer, player;
        let gameRunning = false;
        let enemies = [];
        let projectiles = [];
        let coins = [];
        let colliders = [];
        let buildings = [];
        let boss = null;
        let deviceMode = getCookie('deviceMode') || 'computer';
        let playerState = null;
        let swordMesh = null;
        let swordSwinging = false;
        let swordSwingTime = 0;

        // Post-processing composer for hyper-realistic graphics
        let composer = null;
        let bloomPass = null;
        let fxaaPass = null;

        function setupPostProcessing() {
            if (typeof THREE.EffectComposer === 'undefined') {
                console.warn('Post-processing not available');
                return;
            }

            composer = new THREE.EffectComposer(renderer);

            // Base render pass
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Bloom for glowing effects (subtle for realism)
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.12, // Strength - very subtle glow
                0.4,  // Radius
                0.9   // Threshold - only the brightest elements bloom
            );
            composer.addPass(bloomPass);

            // FXAA anti-aliasing
            if (typeof THREE.FXAAShader !== 'undefined') {
                fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
                fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * renderer.getPixelRatio());
                fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * renderer.getPixelRatio());
                composer.addPass(fxaaPass);
            }

            // Color correction pass for cinematic look
            const colorCorrectionShader = {
                uniforms: {
                    'tDiffuse': { value: null },
                    'saturation': { value: 1.1 },
                    'contrast': { value: 1.05 },
                    'brightness': { value: 0.02 },
                    'vignetteIntensity': { value: 0.15 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float saturation;
                    uniform float contrast;
                    uniform float brightness;
                    uniform float vignetteIntensity;
                    varying vec2 vUv;

                    vec3 adjustSaturation(vec3 color, float sat) {
                        float grey = dot(color, vec3(0.2126, 0.7152, 0.0722));
                        return mix(vec3(grey), color, sat);
                    }

                    void main() {
                        vec4 color = texture2D(tDiffuse, vUv);

                        // Saturation
                        color.rgb = adjustSaturation(color.rgb, saturation);

                        // Contrast and brightness
                        color.rgb = (color.rgb - 0.5) * contrast + 0.5 + brightness;

                        // Vignette
                        vec2 center = vUv - 0.5;
                        float dist = length(center);
                        float vignette = 1.0 - smoothstep(0.3, 0.9, dist) * vignetteIntensity;
                        color.rgb *= vignette;

                        // Subtle film grain
                        float grain = (fract(sin(dot(vUv * 1000.0, vec2(12.9898, 78.233))) * 43758.5453) - 0.5) * 0.02;
                        color.rgb += grain;

                        gl_FragColor = color;
                    }
                `
            };

            const colorPass = new THREE.ShaderPass(colorCorrectionShader);
            colorPass.renderToScreen = true;
            composer.addPass(colorPass);
        }

        // Particle system
        let particles = [];
        const MAX_PARTICLES = 150;

        // Multiplayer state
        let isMultiplayer = false;
        let multiplayerSocket = null;
        let remotePlayers = {};
        let myPlayerId = null;
        let matchTimeRemaining = 300000; // 5 minutes
        let lastPositionSync = 0;
        let playerName = 'Player_' + Math.random().toString(36).substr(2, 4);

        // Connection retry state
        let connectionAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        const INITIAL_RECONNECT_DELAY = 1000;
        let reconnectTimeout = null;
        let connectionTimeout = null;
        const CONNECTION_TIMEOUT_MS = 10000;
        let isRetrying = false;

        // Auth state
        let isAuthenticated = false;
        let authToken = getCookie('authToken') || null;
        let authenticatedUsername = null;
        let usernameValidationTimer = null;

        // Empty lobby timer
        let emptyLobbyTimer = null;

        // Social / friends state
        let socialSocket = null;
        let myFriendCode = '';
        let friendsList = [];
        let pendingRequests = [];
        let friendsServers = [];
        let isFriendsPanelOpen = false;

        // Voice chat state
        let voiceChatEnabled = false;
        let voiceChatMuted = false;
        let localStream = null;
        let peerConnections = {};
        let audioContextVoice = null;
        let localAnalyser = null;

        // Particle creation functions
        function createParticles(position, color, count, speed, size, lifetime, spread = 1) {
            if (particles.length >= MAX_PARTICLES) return;
            count = Math.min(count, MAX_PARTICLES - particles.length);
            for (let i = 0; i < count; i++) {
                const geo = new THREE.SphereGeometry(size * (0.5 + Math.random() * 0.5), 6, 6);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);

                // Random velocity
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.3) * spread,
                    (Math.random() - 0.5) * spread
                ).normalize().multiplyScalar(speed * (0.5 + Math.random() * 0.5));

                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: lifetime,
                    maxLife: lifetime,
                    gravity: 0.0003,
                    shrink: true
                });
            }
        }

        function createSparkParticles(position, color, count) {
            if (particles.length >= MAX_PARTICLES) return;
            count = Math.min(count, MAX_PARTICLES - particles.length);
            for (let i = 0; i < count; i++) {
                const geo = new THREE.BoxGeometry(0.02, 0.15, 0.02);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);

                const angle = Math.random() * Math.PI * 2;
                const upAngle = Math.random() * Math.PI * 0.5;
                const speed = 0.05 + Math.random() * 0.1;

                const velocity = new THREE.Vector3(
                    Math.cos(angle) * Math.sin(upAngle) * speed,
                    Math.cos(upAngle) * speed,
                    Math.sin(angle) * Math.sin(upAngle) * speed
                );

                particle.lookAt(particle.position.clone().add(velocity));

                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: 400 + Math.random() * 300,
                    maxLife: 700,
                    gravity: 0.0008,
                    shrink: false,
                    trail: true
                });
            }
        }

        function createMagicParticles(position, color, count, size = 0.08) {
            if (particles.length >= MAX_PARTICLES) return;
            count = Math.min(count, MAX_PARTICLES - particles.length);
            for (let i = 0; i < count; i++) {
                const geo = new THREE.OctahedronGeometry(size * (0.6 + Math.random() * 0.4), 0);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });
                const particle = new THREE.Mesh(geo, mat);

                // Spiral outward pattern
                const angle = (i / count) * Math.PI * 2 + Math.random() * 0.5;
                const radius = 0.2 + Math.random() * 0.3;
                particle.position.copy(position);
                particle.position.x += Math.cos(angle) * radius;
                particle.position.z += Math.sin(angle) * radius;
                particle.position.y += (Math.random() - 0.5) * 0.5;

                const velocity = new THREE.Vector3(
                    Math.cos(angle) * 0.02,
                    0.02 + Math.random() * 0.03,
                    Math.sin(angle) * 0.02
                );

                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: 600 + Math.random() * 400,
                    maxLife: 1000,
                    gravity: -0.0001, // Float upward
                    shrink: true,
                    spin: true,
                    spinSpeed: 0.05 + Math.random() * 0.05
                });
            }
        }

        function createExplosionParticles(position, color, secondaryColor) {
            // Core explosion particles
            createParticles(position, color, 15, 0.15, 0.12, 500, 2);
            // Secondary colored particles
            createParticles(position, secondaryColor, 8, 0.12, 0.08, 400, 1.5);
            // Spark trails
            createSparkParticles(position, 0xffff00, 6);
            // Smoke
            createParticles(position, 0x444444, 5, 0.03, 0.2, 800, 0.8);
        }

        function createHitParticles(position, color) {
            createParticles(position, color, 8, 0.06, 0.05, 300, 0.8);
            createSparkParticles(position, 0xffffff, 5);
        }

        function createDeathParticles(position, color) {
            createParticles(position, color, 15, 0.08, 0.1, 600, 1.5);
            createMagicParticles(position, 0xff0000, 8, 0.06);
            createParticles(position, 0x220000, 10, 0.04, 0.15, 800, 1);
        }

        function createSlashParticles(position, direction, color) {
            if (particles.length >= MAX_PARTICLES) return;
            const slashCount = Math.min(12, MAX_PARTICLES - particles.length);
            for (let i = 0; i < slashCount; i++) {
                const geo = new THREE.PlaneGeometry(0.04, 0.25);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);

                // Arc pattern
                const arcAngle = (i / slashCount) * Math.PI - Math.PI / 2;
                const offset = new THREE.Vector3(
                    Math.cos(arcAngle) * 0.3,
                    Math.sin(arcAngle) * 0.3,
                    0
                );

                // Rotate offset to match direction
                const rotation = Math.atan2(direction.x, direction.z);
                offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation);
                particle.position.add(offset);

                particle.rotation.y = rotation;
                particle.rotation.x = arcAngle;

                const velocity = offset.clone().normalize().multiplyScalar(0.03);

                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: 200 + Math.random() * 100,
                    maxLife: 300,
                    gravity: 0,
                    shrink: true
                });
            }
        }

        function createProjectileTrail(position, color) {
            if (particles.length >= MAX_PARTICLES) return;
            const geo = new THREE.SphereGeometry(0.06, 4, 4);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6
            });
            const particle = new THREE.Mesh(geo, mat);
            particle.position.copy(position);

            scene.add(particle);
            particles.push({
                mesh: particle,
                velocity: new THREE.Vector3(0, 0.005, 0),
                life: 150,
                maxLife: 150,
                gravity: 0,
                shrink: true
            });
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];

                // Update position
                p.mesh.position.add(p.velocity.clone().multiplyScalar(dt / 16));

                // Apply gravity
                p.velocity.y -= p.gravity * dt;

                // Update life
                p.life -= dt;
                const lifeRatio = p.life / p.maxLife;

                // Fade out
                p.mesh.material.opacity = lifeRatio;

                // Shrink
                if (p.shrink) {
                    const scale = 0.3 + lifeRatio * 0.7;
                    p.mesh.scale.setScalar(scale);
                }

                // Spin
                if (p.spin) {
                    p.mesh.rotation.x += p.spinSpeed;
                    p.mesh.rotation.y += p.spinSpeed * 0.7;
                }

                // Remove dead particles
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        // Settings
        const settings = {
            autoJump: false,
            autoCollectCoins: true,
            walkSpeed: 30,
            sprintSpeed: 30,
            sensitivity: 50,
            invertY: false,
            showDamageNumbers: true,
            showMinimap: true
        };
        
        // Inventory
        const inventory = { coins: 100, ownedItems: ['sword', 'fireball'] };

        // Save inventory to cookie as fallback
        function saveInventoryToCookie() {
            const data = JSON.stringify({
                coins: inventory.coins,
                ownedItems: inventory.ownedItems
            });
            setCookie('inventory', data);
        }

        // Load inventory from cookie
        function loadInventoryFromCookie() {
            const saved = getCookie('inventory');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    if (data.coins !== undefined) inventory.coins = data.coins;
                    if (data.ownedItems && data.ownedItems.length > 0) {
                        inventory.ownedItems = data.ownedItems;
                    }
                    return true;
                } catch (e) {
                    console.log('Could not parse inventory cookie');
                }
            }
            return false;
        }

        // Save generated weapons to cookie
        function saveWeaponsToCookie() {
            try {
                const weapons = localStorage.getItem('generatedWeapons') || '[]';
                setCookie('generatedWeapons', weapons);
                const hotbarState = localStorage.getItem('hotbarState') || '[]';
                setCookie('hotbarState', hotbarState);
            } catch (e) {
                console.log('Could not save weapons to cookie');
            }
        }

        // Load generated weapons from cookie fallback
        function loadWeaponsFromCookie() {
            const weapons = getCookie('generatedWeapons');
            if (weapons && !localStorage.getItem('generatedWeapons')) {
                localStorage.setItem('generatedWeapons', weapons);
            }
            const hotbarState = getCookie('hotbarState');
            if (hotbarState && !localStorage.getItem('hotbarState')) {
                localStorage.setItem('hotbarState', hotbarState);
            }
        }

        // Cloud save functions
        async function loadFromCloud() {
            try {
                const response = await fetch('/api/save');
                const data = await response.json();
                inventory.coins = data.coins;
                if (data.ownedItems && data.ownedItems.length > 0) {
                    inventory.ownedItems = data.ownedItems;
                    // Populate hotbar with owned items
                    hotbar = [null, null, null, null, null, null];
                    for (let i = 0; i < Math.min(inventory.ownedItems.length, 6); i++) {
                        hotbar[i] = inventory.ownedItems[i];
                    }
                    // Refresh hotbar UI if it exists
                    if (document.getElementById('hotbar')) {
                        setupHotbar();
                    }
                }
                // Save to cookie as backup
                saveInventoryToCookie();
                document.getElementById('menuCoins').textContent = 'üí∞ ' + inventory.coins;
                document.getElementById('coinsDisplay').textContent = 'üí∞ ' + inventory.coins;
                console.log('Loaded from cloud:', inventory);
                console.log('Hotbar updated:', hotbar);
            } catch (e) {
                console.log('Could not load from cloud, trying cookie fallback');
                if (loadInventoryFromCookie()) {
                    hotbar = [null, null, null, null, null, null];
                    for (let i = 0; i < Math.min(inventory.ownedItems.length, 6); i++) {
                        hotbar[i] = inventory.ownedItems[i];
                    }
                    if (document.getElementById('hotbar')) {
                        setupHotbar();
                    }
                    document.getElementById('menuCoins').textContent = 'üí∞ ' + inventory.coins;
                    document.getElementById('coinsDisplay').textContent = 'üí∞ ' + inventory.coins;
                    console.log('Loaded from cookie:', inventory);
                }
            }
            // Restore weapons from cookie if localStorage is empty
            loadWeaponsFromCookie();
        }

        async function saveToCloud() {
            // Always save to cookie as backup
            saveInventoryToCookie();
            saveWeaponsToCookie();
            try {
                await fetch('/api/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        coins: inventory.coins,
                        ownedItems: inventory.ownedItems
                    })
                });
                console.log('Saved to cloud:', inventory);
            } catch (e) {
                console.log('Could not save to cloud, saved to cookie');
            }
        }

        // Alias for backward compatibility
        const saveCoinsToCloud = saveToCloud;

        // Load save when page loads
        loadFromCloud();

        // Items
        const itemDefs = {
            // === STARTER WEAPONS ===
            sword: { name: 'Sword', icon: '‚öîÔ∏è', type: 'weapon', damage: 25, cooldown: 500, desc: 'Basic melee attack' },
            fireball: { name: 'Fireball', icon: 'üî•', type: 'ability', damage: 40, cooldown: 2000, energy: 15, desc: 'Ranged fire attack' },

            // === MELEE WEAPONS ===
            axe: { name: 'Battle Axe', icon: 'ü™ì', type: 'weapon', damage: 45, cooldown: 800, desc: 'Heavy melee damage' },
            spear: { name: 'Spear', icon: 'üî±', type: 'weapon', damage: 35, cooldown: 600, desc: 'Long reach attack' },
            hammer: { name: 'War Hammer', icon: 'üî®', type: 'weapon', damage: 60, cooldown: 1200, desc: 'Massive damage, slow' },
            dagger: { name: 'Dagger', icon: 'üó°Ô∏è', type: 'weapon', damage: 18, cooldown: 250, desc: 'Fast attack speed' },
            katana: { name: 'Katana', icon: '‚öîÔ∏è', type: 'weapon', damage: 38, cooldown: 400, desc: 'Swift blade strikes' },
            scythe: { name: 'Scythe', icon: 'üåô', type: 'weapon', damage: 55, cooldown: 900, desc: 'Reaper\'s weapon' },
            mace: { name: 'Mace', icon: 'üèè', type: 'weapon', damage: 42, cooldown: 700, desc: 'Crushing blows' },
            flail: { name: 'Flail', icon: '‚õìÔ∏è', type: 'weapon', damage: 48, cooldown: 850, desc: 'Chain weapon' },
            halberd: { name: 'Halberd', icon: 'ü™ì', type: 'weapon', damage: 52, cooldown: 950, desc: 'Polearm attack' },
            claws: { name: 'Wolf Claws', icon: 'üê∫', type: 'weapon', damage: 22, cooldown: 200, desc: 'Rapid slashes' },
            gauntlet: { name: 'Power Gauntlet', icon: 'ü•ä', type: 'weapon', damage: 35, cooldown: 450, desc: 'Punch attack' },
            chainsaw: { name: 'Chainsaw', icon: 'ü™ö', type: 'weapon', damage: 65, cooldown: 300, desc: 'Brutal damage' },
            pickaxe: { name: 'Pickaxe', icon: '‚õèÔ∏è', type: 'weapon', damage: 40, cooldown: 650, desc: 'Mining tool turned weapon' },
            shovel: { name: 'Battle Shovel', icon: 'ü™†', type: 'weapon', damage: 28, cooldown: 500, desc: 'Blunt force' },
            sickle: { name: 'Sickle', icon: 'üåæ', type: 'weapon', damage: 32, cooldown: 350, desc: 'Curved blade' },
            nunchucks: { name: 'Nunchucks', icon: 'ü•¢', type: 'weapon', damage: 26, cooldown: 280, desc: 'Martial arts weapon' },
            bo_staff: { name: 'Bo Staff', icon: 'üéã', type: 'weapon', damage: 30, cooldown: 400, desc: 'Long range melee' },
            whip: { name: 'Whip', icon: '„Ä∞Ô∏è', type: 'weapon', damage: 24, cooldown: 350, desc: 'Long reach' },
            anchor: { name: 'Anchor', icon: '‚öì', type: 'weapon', damage: 75, cooldown: 1500, desc: 'Extremely heavy' },
            wrench: { name: 'Giant Wrench', icon: 'üîß', type: 'weapon', damage: 38, cooldown: 550, desc: 'Tool of destruction' },

            // === LEGENDARY MELEE ===
            excalibur: { name: 'Excalibur', icon: 'üó°Ô∏è', type: 'weapon', damage: 85, cooldown: 600, desc: 'Legendary blade' },
            mjolnir: { name: 'Mjolnir', icon: 'üî®', type: 'weapon', damage: 95, cooldown: 1000, desc: 'Thor\'s hammer' },
            gungnir: { name: 'Gungnir', icon: 'üî±', type: 'weapon', damage: 80, cooldown: 700, desc: 'Odin\'s spear' },
            kusanagi: { name: 'Kusanagi', icon: '‚öîÔ∏è', type: 'weapon', damage: 88, cooldown: 450, desc: 'Divine blade' },

            // === RANGED WEAPONS ===
            bow: { name: 'Bow', icon: 'üèπ', type: 'ranged', damage: 35, cooldown: 800, desc: 'Arrow shot' },
            crossbow: { name: 'Crossbow', icon: 'üéØ', type: 'ranged', damage: 50, cooldown: 1200, desc: 'Powerful bolt' },
            shuriken: { name: 'Shuriken', icon: '‚ú¥Ô∏è', type: 'ranged', damage: 20, cooldown: 300, desc: 'Throwing star' },
            javelin: { name: 'Javelin', icon: 'üéø', type: 'ranged', damage: 45, cooldown: 900, desc: 'Throwing spear' },
            boomerang: { name: 'Boomerang', icon: 'ü™É', type: 'ranged', damage: 28, cooldown: 600, desc: 'Returns to you' },
            kunai: { name: 'Kunai', icon: 'üìç', type: 'ranged', damage: 22, cooldown: 350, desc: 'Ninja knife' },
            chakram: { name: 'Chakram', icon: 'üíø', type: 'ranged', damage: 38, cooldown: 700, desc: 'Spinning disc' },
            blowdart: { name: 'Blowdart', icon: 'üé∫', type: 'ranged', damage: 15, cooldown: 400, desc: 'Poison dart' },

            // === MAGIC SPELLS ===
            iceball: { name: 'Ice Blast', icon: '‚ùÑÔ∏è', type: 'ability', damage: 35, cooldown: 1800, energy: 12, desc: 'Freezing projectile' },
            lightning: { name: 'Lightning', icon: '‚ö°', type: 'ability', damage: 55, cooldown: 2500, energy: 25, desc: 'Chain lightning' },
            poison: { name: 'Poison Cloud', icon: '‚ò†Ô∏è', type: 'ability', damage: 30, cooldown: 3000, energy: 20, desc: 'AOE poison damage' },
            laser: { name: 'Laser Beam', icon: 'üî¥', type: 'ability', damage: 70, cooldown: 3500, energy: 35, desc: 'Powerful beam attack' },
            meteor: { name: 'Meteor', icon: '‚òÑÔ∏è', type: 'ability', damage: 90, cooldown: 5000, energy: 50, desc: 'Massive impact' },
            tornado: { name: 'Tornado', icon: 'üå™Ô∏è', type: 'ability', damage: 45, cooldown: 3000, energy: 30, desc: 'Spinning winds' },
            earthquake: { name: 'Earthquake', icon: 'üåã', type: 'ability', damage: 60, cooldown: 4000, energy: 40, desc: 'Ground shaker' },
            tsunami: { name: 'Tsunami', icon: 'üåä', type: 'ability', damage: 55, cooldown: 3500, energy: 35, desc: 'Water wave' },
            vortex: { name: 'Void Vortex', icon: 'üï≥Ô∏è', type: 'ability', damage: 75, cooldown: 4500, energy: 45, desc: 'Black hole' },
            solar: { name: 'Solar Flare', icon: '‚òÄÔ∏è', type: 'ability', damage: 65, cooldown: 3000, energy: 32, desc: 'Blinding light' },
            lunar: { name: 'Lunar Strike', icon: 'üåô', type: 'ability', damage: 58, cooldown: 2800, energy: 28, desc: 'Moon power' },
            arcane: { name: 'Arcane Blast', icon: 'üîÆ', type: 'ability', damage: 50, cooldown: 2200, energy: 22, desc: 'Pure magic' },
            nature: { name: 'Nature\'s Wrath', icon: 'üåø', type: 'ability', damage: 42, cooldown: 2500, energy: 20, desc: 'Plant attack' },
            shadow: { name: 'Shadow Bolt', icon: 'üñ§', type: 'ability', damage: 48, cooldown: 1800, energy: 18, desc: 'Dark magic' },
            holy: { name: 'Holy Light', icon: '‚ú®', type: 'ability', damage: 52, cooldown: 2000, energy: 24, desc: 'Divine damage' },
            plasma: { name: 'Plasma Ball', icon: 'üü£', type: 'ability', damage: 62, cooldown: 2400, energy: 28, desc: 'Energy sphere' },
            gravity: { name: 'Gravity Well', icon: '‚¨õ', type: 'ability', damage: 55, cooldown: 3200, energy: 35, desc: 'Crushing force' },
            chain_lightning: { name: 'Chain Lightning', icon: '‚õàÔ∏è', type: 'ability', damage: 40, cooldown: 2000, energy: 22, desc: 'Bouncing shock' },
            frost_nova: { name: 'Frost Nova', icon: 'üí†', type: 'ability', damage: 35, cooldown: 2500, energy: 25, desc: 'AOE freeze' },
            fire_storm: { name: 'Fire Storm', icon: 'üî•', type: 'ability', damage: 70, cooldown: 4000, energy: 40, desc: 'Raining fire' },

            // === LEGENDARY MAGIC ===
            supernova: { name: 'Supernova', icon: 'üí•', type: 'ability', damage: 150, cooldown: 8000, energy: 80, desc: 'Ultimate explosion' },
            apocalypse: { name: 'Apocalypse', icon: 'üåë', type: 'ability', damage: 200, cooldown: 12000, energy: 100, desc: 'World ender' },
            genesis: { name: 'Genesis Beam', icon: 'üåü', type: 'ability', damage: 120, cooldown: 6000, energy: 60, desc: 'Creation energy' },
            oblivion: { name: 'Oblivion', icon: 'üíÄ', type: 'ability', damage: 180, cooldown: 10000, energy: 90, desc: 'Erase from existence' },

            // === UTILITY ITEMS ===
            shield: { name: 'Shield', icon: 'üõ°Ô∏è', type: 'ability', cooldown: 6000, energy: 20, desc: '+20 defense 4s' },
            medkit: { name: 'Medkit', icon: 'üíä', type: 'consumable', healing: 50, cooldown: 4000, desc: 'Heal 50 HP' },
            megaHeal: { name: 'Mega Heal', icon: 'üíâ', type: 'consumable', healing: 100, cooldown: 8000, desc: 'Full heal' },
            jumpPad: { name: 'Jump Pad', icon: 'ü¶ò', type: 'ability', cooldown: 3000, energy: 10, desc: 'Super jump' },
            speedBoost: { name: 'Speed Boost', icon: 'üí®', type: 'ability', cooldown: 5000, energy: 15, desc: '2x speed 3s' },
            rage: { name: 'Rage Mode', icon: 'üò°', type: 'ability', cooldown: 10000, energy: 40, desc: '2x damage 5s' },
            invisibility: { name: 'Invisibility', icon: 'üëª', type: 'ability', cooldown: 15000, energy: 50, desc: 'Vanish 5s' },
            teleport: { name: 'Teleport', icon: 'üåÄ', type: 'ability', cooldown: 8000, energy: 30, desc: 'Blink forward' },
            reflect: { name: 'Reflect Shield', icon: 'ü™û', type: 'ability', cooldown: 10000, energy: 35, desc: 'Reflect damage' },
            lifesteal: { name: 'Lifesteal', icon: 'üßõ', type: 'ability', cooldown: 12000, energy: 45, desc: 'Drain health' },
            timestop: { name: 'Time Stop', icon: '‚è∞', type: 'ability', cooldown: 20000, energy: 60, desc: 'Freeze time 3s' },
            clone: { name: 'Shadow Clone', icon: 'üë•', type: 'ability', cooldown: 15000, energy: 40, desc: 'Create decoy' },
            berserk: { name: 'Berserk', icon: 'üî¥', type: 'ability', cooldown: 18000, energy: 55, desc: '3x damage, take 2x' },
            fortify: { name: 'Fortify', icon: 'üè∞', type: 'ability', cooldown: 12000, energy: 35, desc: '+50 defense 6s' },
            regenerate: { name: 'Regeneration', icon: 'üíö', type: 'ability', cooldown: 20000, energy: 40, desc: 'Heal over time' },
            energize: { name: 'Energize', icon: 'üîã', type: 'ability', cooldown: 15000, energy: 0, desc: 'Restore 50 energy' },

            // === BOMBS & EXPLOSIVES ===
            grenade: { name: 'Grenade', icon: 'üí£', type: 'ability', damage: 80, cooldown: 4000, energy: 25, desc: 'Explosive' },
            dynamite: { name: 'Dynamite', icon: 'üß®', type: 'ability', damage: 100, cooldown: 5000, energy: 35, desc: 'Big explosion' },
            molotov: { name: 'Molotov', icon: 'üçæ', type: 'ability', damage: 60, cooldown: 3500, energy: 20, desc: 'Fire bomb' },
            flashbang: { name: 'Flashbang', icon: 'üí°', type: 'ability', damage: 10, cooldown: 6000, energy: 15, desc: 'Stun enemies' },
            smoke_bomb: { name: 'Smoke Bomb', icon: 'üí≠', type: 'ability', damage: 0, cooldown: 5000, energy: 10, desc: 'Cover escape' },
            cluster_bomb: { name: 'Cluster Bomb', icon: 'üéÜ', type: 'ability', damage: 120, cooldown: 7000, energy: 50, desc: 'Multiple explosions' },
            nuke: { name: 'Mini Nuke', icon: '‚ò¢Ô∏è', type: 'ability', damage: 250, cooldown: 20000, energy: 100, desc: 'Nuclear strike' },

            // === SUMMONING ===
            summon_wolf: { name: 'Summon Wolf', icon: 'üê∫', type: 'ability', damage: 30, cooldown: 8000, energy: 40, desc: 'Call wolf ally' },
            summon_dragon: { name: 'Summon Dragon', icon: 'üêâ', type: 'ability', damage: 80, cooldown: 15000, energy: 70, desc: 'Dragon attack' },
            summon_golem: { name: 'Summon Golem', icon: 'üóø', type: 'ability', damage: 50, cooldown: 10000, energy: 50, desc: 'Stone guardian' },
            summon_phoenix: { name: 'Summon Phoenix', icon: 'ü¶Ö', type: 'ability', damage: 70, cooldown: 12000, energy: 60, desc: 'Fire bird' },
            summon_demon: { name: 'Summon Demon', icon: 'üëø', type: 'ability', damage: 90, cooldown: 18000, energy: 80, desc: 'Hellspawn' },

            // === ELEMENTAL WEAPONS ===
            flame_sword: { name: 'Flame Sword', icon: 'üî•', type: 'weapon', damage: 55, cooldown: 550, desc: 'Burning blade' },
            frost_axe: { name: 'Frost Axe', icon: 'üßä', type: 'weapon', damage: 58, cooldown: 850, desc: 'Freezing chop' },
            thunder_hammer: { name: 'Thunder Hammer', icon: '‚õàÔ∏è', type: 'weapon', damage: 72, cooldown: 1100, desc: 'Shocking smash' },
            venom_dagger: { name: 'Venom Dagger', icon: 'üêç', type: 'weapon', damage: 25, cooldown: 280, desc: 'Poisoned blade' },
            earth_mace: { name: 'Earth Mace', icon: 'ü™®', type: 'weapon', damage: 62, cooldown: 900, desc: 'Stone crusher' },
            wind_blade: { name: 'Wind Blade', icon: 'üå¨Ô∏è', type: 'weapon', damage: 42, cooldown: 380, desc: 'Swift as wind' },
            shadow_scythe: { name: 'Shadow Scythe', icon: 'üåë', type: 'weapon', damage: 68, cooldown: 800, desc: 'Dark harvest' },
            holy_lance: { name: 'Holy Lance', icon: '‚úùÔ∏è', type: 'weapon', damage: 65, cooldown: 700, desc: 'Divine pierce' }
        };

        const shopItems = [
            // Melee Weapons
            { id: 'axe', price: 150 },
            { id: 'spear', price: 120 },
            { id: 'hammer', price: 300 },
            { id: 'dagger', price: 80 },
            { id: 'katana', price: 250 },
            { id: 'scythe', price: 400 },
            { id: 'mace', price: 200 },
            { id: 'flail', price: 280 },
            { id: 'halberd', price: 350 },
            { id: 'claws', price: 180 },
            { id: 'gauntlet', price: 220 },
            { id: 'chainsaw', price: 500 },
            { id: 'pickaxe', price: 160 },
            { id: 'shovel', price: 90 },
            { id: 'sickle', price: 140 },
            { id: 'nunchucks', price: 170 },
            { id: 'bo_staff', price: 130 },
            { id: 'whip', price: 150 },
            { id: 'anchor', price: 600 },
            { id: 'wrench', price: 190 },
            // Legendary Melee
            { id: 'excalibur', price: 2500 },
            { id: 'mjolnir', price: 3000 },
            { id: 'gungnir', price: 2800 },
            { id: 'kusanagi', price: 2700 },
            // Ranged
            { id: 'bow', price: 200 },
            { id: 'crossbow', price: 350 },
            { id: 'shuriken', price: 100 },
            { id: 'javelin', price: 280 },
            { id: 'boomerang', price: 180 },
            { id: 'kunai', price: 120 },
            { id: 'chakram', price: 250 },
            { id: 'blowdart', price: 80 },
            // Magic Spells
            { id: 'iceball', price: 200 },
            { id: 'lightning', price: 350 },
            { id: 'poison', price: 250 },
            { id: 'laser', price: 500 },
            { id: 'meteor', price: 800 },
            { id: 'tornado', price: 400 },
            { id: 'earthquake', price: 550 },
            { id: 'tsunami', price: 500 },
            { id: 'vortex', price: 700 },
            { id: 'solar', price: 600 },
            { id: 'lunar', price: 550 },
            { id: 'arcane', price: 380 },
            { id: 'nature', price: 320 },
            { id: 'shadow', price: 400 },
            { id: 'holy', price: 450 },
            { id: 'plasma', price: 580 },
            { id: 'gravity', price: 520 },
            { id: 'chain_lightning', price: 360 },
            { id: 'frost_nova', price: 380 },
            { id: 'fire_storm', price: 650 },
            // Legendary Magic
            { id: 'supernova', price: 5000 },
            { id: 'apocalypse', price: 8000 },
            { id: 'genesis', price: 4500 },
            { id: 'oblivion', price: 7000 },
            // Utility
            { id: 'shield', price: 100 },
            { id: 'medkit', price: 75 },
            { id: 'megaHeal', price: 200 },
            { id: 'jumpPad', price: 125 },
            { id: 'speedBoost', price: 150 },
            { id: 'rage', price: 400 },
            { id: 'invisibility', price: 600 },
            { id: 'teleport', price: 450 },
            { id: 'reflect', price: 500 },
            { id: 'lifesteal', price: 700 },
            { id: 'timestop', price: 1500 },
            { id: 'clone', price: 550 },
            { id: 'berserk', price: 800 },
            { id: 'fortify', price: 400 },
            { id: 'regenerate', price: 600 },
            { id: 'energize', price: 300 },
            // Bombs
            { id: 'grenade', price: 250 },
            { id: 'dynamite', price: 400 },
            { id: 'molotov', price: 200 },
            { id: 'flashbang', price: 150 },
            { id: 'smoke_bomb', price: 100 },
            { id: 'cluster_bomb', price: 900 },
            { id: 'nuke', price: 5000 },
            // Summons
            { id: 'summon_wolf', price: 500 },
            { id: 'summon_dragon', price: 2000 },
            { id: 'summon_golem', price: 800 },
            { id: 'summon_phoenix', price: 1500 },
            { id: 'summon_demon', price: 2500 },
            // Elemental Weapons
            { id: 'flame_sword', price: 450 },
            { id: 'frost_axe', price: 480 },
            { id: 'thunder_hammer', price: 650 },
            { id: 'venom_dagger', price: 300 },
            { id: 'earth_mace', price: 520 },
            { id: 'wind_blade', price: 380 },
            { id: 'shadow_scythe', price: 600 },
            { id: 'holy_lance', price: 580 }
        ];
        
        let hotbar = ['sword', 'fireball', null, null, null, null];
        let selectedSlot = 0;
        let itemCooldowns = {};
        
        // Input
        const keys = {};
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;
        let joystickActive = false;
        let joystickX = 0, joystickY = 0;
        
        // Wave
        let currentWave = 1;
        let waveInProgress = false;
        
        // Get terrain height at any position
        function getTerrainHeight(x, z) {
            let height = 0;
            height += Math.sin(x * 0.02) * Math.cos(z * 0.02) * 3; // Large hills
            height += Math.sin(x * 0.05) * Math.cos(z * 0.04) * 1.5; // Medium bumps
            height += Math.sin(x * 0.1 + z * 0.1) * 0.3; // Small details
            height += Math.sin(x * 0.15 + z * 0.08) * 0.15; // Micro details

            const distFromCenter = Math.sqrt(x * x + z * z);
            if (distFromCenter < 30) {
                height *= distFromCenter / 30;
            }

            // Flatten terrain under village cobblestone area (centered at 0, 12, radius 18)
            const cobbleCenterZ = 12;
            const cobbleRadius = 18;
            const dxCobble = x;
            const dzCobble = z - cobbleCenterZ;
            const distFromCobble = Math.sqrt(dxCobble * dxCobble + dzCobble * dzCobble);
            if (distFromCobble < cobbleRadius + 4) {
                // Smooth blend: fully flat inside radius, gradual transition in 4-unit border
                const blend = Math.max(0, Math.min(1, (distFromCobble - cobbleRadius) / 4));
                height *= blend;
            }

            return height;
        }
        
        function init() {
            playerState = {
                position: new THREE.Vector3(0, 1.7, 0),
                velocity: new THREE.Vector3(0, 0, 0),
                rotation: { x: 0, y: 0 },
                health: 100,
                maxHealth: 100,
                energy: 100,
                maxEnergy: 100,
                speed: 0.03,
                sprintSpeed: 0.05,
                defense: 5,
                isGrounded: true,
                score: 0,
                kills: 0
            };
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x7ec8e3);
            scene.fog = new THREE.FogExp2(0x7ec8e3, 0.006);
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.copy(playerState.position);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, deviceMode === 'mobile' ? 1.5 : 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.25;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.physicallyCorrectLights = true;
            document.body.appendChild(renderer.domElement);
            renderer.domElement.style.display = 'none'; // Hide canvas until game starts

            // Hyper-realistic post-processing
            setupPostProcessing();

            // Realistic lighting
            const ambientLight = new THREE.AmbientLight(0x8899aa, 0.4);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffeedd, 1.0);
            sunLight.position.set(60, 100, 40);
            sunLight.castShadow = true;
            const shadowRes = deviceMode === 'mobile' ? 1024 : 2048;
            sunLight.shadow.mapSize.width = shadowRes;
            sunLight.shadow.mapSize.height = shadowRes;
            sunLight.shadow.camera.near = 10;
            sunLight.shadow.camera.far = 250;
            sunLight.shadow.camera.left = -60;
            sunLight.shadow.camera.right = 60;
            sunLight.shadow.camera.top = 60;
            sunLight.shadow.camera.bottom = -60;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);
            
            const hemiLight = new THREE.HemisphereLight(0x88bbff, 0x445522, 0.5);
            scene.add(hemiLight);
            
            // Ground - realistic grass with hills (higher resolution)
            const groundGeo = new THREE.PlaneGeometry(250, 250, 120, 120);
            const positions = groundGeo.attributes.position;
            const colors = [];

            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                // Create rolling hills with more variation
                let height = 0;
                height += Math.sin(x * 0.02) * Math.cos(y * 0.02) * 3; // Large hills
                height += Math.sin(x * 0.05) * Math.cos(y * 0.04) * 1.5; // Medium bumps
                height += Math.sin(x * 0.1 + y * 0.1) * 0.3; // Small details
                height += Math.sin(x * 0.15 + y * 0.08) * 0.15; // Micro details

                // Flatten area near spawn
                const distFromCenter = Math.sqrt(x * x + y * y);
                if (distFromCenter < 30) {
                    height *= distFromCenter / 30;
                }

                positions.setZ(i, height);

                // Vertex colors for ground variation
                const grassBase = new THREE.Color(0x4a7c3f);
                const grassDark = new THREE.Color(0x3a5c2f);
                const grassLight = new THREE.Color(0x5a9c4f);
                const dirt = new THREE.Color(0x6b5344);

                // Mix colors based on position and height
                let color = grassBase.clone();
                const noise = Math.sin(x * 0.3) * Math.cos(y * 0.25) * 0.5 + 0.5;
                const heightFactor = (height + 3) / 6;

                if (noise > 0.7) {
                    color.lerp(grassLight, (noise - 0.7) * 2);
                } else if (noise < 0.3) {
                    color.lerp(grassDark, (0.3 - noise) * 2);
                }

                // Add dirt patches
                const dirtNoise = Math.sin(x * 0.08 + 1.5) * Math.cos(y * 0.12 + 2.3);
                if (dirtNoise > 0.6) {
                    color.lerp(dirt, (dirtNoise - 0.6) * 1.5);
                }

                // Darken valleys, lighten peaks
                color.lerp(grassDark, Math.max(0, -heightFactor * 0.3));
                color.lerp(grassLight, Math.max(0, heightFactor * 0.2));

                colors.push(color.r, color.g, color.b);
            }

            groundGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            groundGeo.computeVertexNormals();

            const groundMat = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.92,
                metalness: 0,
                flatShading: false
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Village center cobblestone area
            const cobbleCenterY = getTerrainHeight(0, 12);
            const cobbleGeo = new THREE.CircleGeometry(18, 32);
            const cobbleMat = new THREE.MeshStandardMaterial({
                color: 0x6a6a6a,
                roughness: 0.85,
                metalness: 0.1
            });
            const cobble = new THREE.Mesh(cobbleGeo, cobbleMat);
            cobble.rotation.x = -Math.PI / 2;
            cobble.position.set(0, cobbleCenterY + 0.03, 12);
            cobble.receiveShadow = true;
            scene.add(cobble);

            // Cobblestone details (individual stones)
            for (let s = 0; s < 80; s++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 16;
                const stoneX = Math.cos(angle) * radius;
                const stoneZ = 12 + Math.sin(angle) * radius;
                const stoneY = getTerrainHeight(stoneX, stoneZ);
                const stoneSize = 0.3 + Math.random() * 0.4;
                const stoneGeo = new THREE.CylinderGeometry(stoneSize, stoneSize * 0.9, 0.08, 6);
                const stoneMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0, 0, 0.35 + Math.random() * 0.2),
                    roughness: 0.9
                });
                const stone = new THREE.Mesh(stoneGeo, stoneMat);
                stone.position.set(stoneX, stoneY + 0.06, stoneZ);
                stone.rotation.y = Math.random() * Math.PI;
                stone.receiveShadow = true;
                scene.add(stone);
            }

            // Dirt paths (multiple)
            const pathMat = new THREE.MeshStandardMaterial({ color: 0x7a6355, roughness: 0.95 });

            // Main path (north-south)
            const pathGeo1 = new THREE.PlaneGeometry(4, 150);
            const path1 = new THREE.Mesh(pathGeo1, pathMat);
            path1.rotation.x = -Math.PI / 2;
            path1.position.y = 0.02;
            path1.receiveShadow = true;
            scene.add(path1);

            // East-west path
            const pathGeo2 = new THREE.PlaneGeometry(100, 3.5);
            const path2 = new THREE.Mesh(pathGeo2, pathMat);
            path2.rotation.x = -Math.PI / 2;
            path2.position.set(0, 0.02, 12);
            path2.receiveShadow = true;
            scene.add(path2);

            // Path to church
            const pathGeo3 = new THREE.PlaneGeometry(3, 40);
            const path3 = new THREE.Mesh(pathGeo3, pathMat);
            path3.rotation.x = -Math.PI / 2;
            path3.rotation.z = -0.4;
            path3.position.set(20, 0.02, -5);
            path3.receiveShadow = true;
            scene.add(path3);

            // Scatter small rocks on ground
            for (let r = 0; r < 50; r++) {
                const rx = (Math.random() - 0.5) * 200;
                const rz = (Math.random() - 0.5) * 200;
                const terrainY = getTerrainHeight(rx, rz);
                const rockSize = 0.1 + Math.random() * 0.15;
                const smallRock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(rockSize, 0),
                    new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(0.08, 0.1, 0.3 + Math.random() * 0.15),
                        roughness: 0.95
                    })
                );
                smallRock.position.set(rx, terrainY + rockSize * 0.3, rz);
                smallRock.rotation.set(Math.random(), Math.random(), Math.random());
                smallRock.castShadow = true;
                scene.add(smallRock);
            }
            
            createEnvironment();
            createBuildings();
            
            const playerGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.7, 16);
            const playerMat = new THREE.MeshStandardMaterial({ visible: false });
            player = new THREE.Mesh(playerGeo, playerMat);
            player.position.copy(playerState.position);
            scene.add(player);
            
            // Create 3D sword
            const swordGroup = new THREE.Group();
            
            // Blade
            const bladeGeo = new THREE.BoxGeometry(0.06, 0.8, 0.02);
            const bladeMat = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc, 
                metalness: 0.9, 
                roughness: 0.2 
            });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.y = 0.5;
            swordGroup.add(blade);
            
            // Blade tip
            const tipGeo = new THREE.ConeGeometry(0.04, 0.15, 4);
            const tip = new THREE.Mesh(tipGeo, bladeMat);
            tip.position.y = 0.95;
            tip.rotation.z = Math.PI;
            swordGroup.add(tip);
            
            // Guard
            const guardGeo = new THREE.BoxGeometry(0.2, 0.04, 0.06);
            const guardMat = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, 
                metalness: 0.8, 
                roughness: 0.3 
            });
            const guard = new THREE.Mesh(guardGeo, guardMat);
            guard.position.y = 0.08;
            swordGroup.add(guard);
            
            // Handle
            const handleGeo = new THREE.CylinderGeometry(0.025, 0.03, 0.2, 8);
            const handleMat = new THREE.MeshStandardMaterial({ 
                color: 0x4a3728, 
                roughness: 0.9 
            });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -0.05;
            swordGroup.add(handle);
            
            // Pommel
            const pommelGeo = new THREE.SphereGeometry(0.035, 8, 8);
            const pommel = new THREE.Mesh(pommelGeo, guardMat);
            pommel.position.y = -0.17;
            swordGroup.add(pommel);
            
            swordMesh = swordGroup;
            swordMesh.visible = false;
            scene.add(swordMesh);
            
            setupMinimap();
            setupHotbar();
            generateSettingsUI();
            updateShopUI();
        }
        
        function createEnvironment() {
            colliders = [];
            
            // Trees - realistic
            for (let i = 0; i < 40; i++) {
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                
                if (Math.abs(x) < 25 && Math.abs(z) < 25) continue;
                if (Math.abs(x) < 4) continue;
                
                const terrainY = getTerrainHeight(x, z);
                const treeHeight = 5 + Math.random() * 3;
                const trunkRadius = 0.25 + Math.random() * 0.15;
                
                // Trunk
                const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.7, trunkRadius, treeHeight * 0.4, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5D4037, roughness: 0.9 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.set(x, terrainY + treeHeight * 0.2, z);
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                scene.add(trunk);
                
                colliders.push({
                    type: 'cylinder',
                    position: new THREE.Vector3(x, terrainY, z),
                    radius: trunkRadius + 0.2,
                    canAutoJump: false
                });
                
                // Foliage layers
                for (let j = 0; j < 3; j++) {
                    const foliageRadius = (1.5 - j * 0.3) * (0.8 + Math.random() * 0.2);
                    const foliageGeo = new THREE.ConeGeometry(foliageRadius, treeHeight * 0.2, 8);
                    const foliageMat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(0.28 + Math.random() * 0.05, 0.45, 0.28 + Math.random() * 0.06),
                        roughness: 0.85
                    });
                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                    foliage.position.set(x, terrainY + treeHeight * (0.4 + j * 0.14), z);
                    foliage.castShadow = true;
                    scene.add(foliage);
                }
            }
            
            // Rocks - realistic flat orientation
            for (let i = 0; i < 25; i++) {
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;
                
                if (Math.abs(x) < 18 && Math.abs(z) < 18) continue;
                
                const terrainY = getTerrainHeight(x, z);
                const rockSize = 0.3 + Math.random() * 0.8;
                const rockGeo = new THREE.DodecahedronGeometry(rockSize, 0);
                const rockMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(0.4 + Math.random() * 0.15, 0.4 + Math.random() * 0.1, 0.38),
                    roughness: 0.95,
                    flatShading: true
                });
                const rock = new THREE.Mesh(rockGeo, rockMat);
                rock.position.set(x, terrainY + rockSize * 0.3, z);
                // REALISTIC: rocks lie flat, only slight random rotation
                rock.rotation.set(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * Math.PI * 2,
                    (Math.random() - 0.5) * 0.3
                );
                rock.scale.set(1 + Math.random() * 0.4, 0.4 + Math.random() * 0.3, 1 + Math.random() * 0.4);
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
                
                colliders.push({
                    type: 'sphere',
                    position: new THREE.Vector3(x, terrainY + rockSize * 0.2, z),
                    radius: rockSize * 0.6,
                    canAutoJump: true,
                    jumpHeight: rockSize * 0.3
                });
            }
            
            // Grass tufts
            for (let i = 0; i < 200; i++) {
                const x = (Math.random() - 0.5) * 120;
                const z = (Math.random() - 0.5) * 120;
                const terrainY = getTerrainHeight(x, z);
                
                const grassGeo = new THREE.PlaneGeometry(0.12, 0.3 + Math.random() * 0.2);
                const grassMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0.25 + Math.random() * 0.05, 0.5, 0.32),
                    side: THREE.DoubleSide
                });
                const grass = new THREE.Mesh(grassGeo, grassMat);
                grass.position.set(x, terrainY + 0.15, z);
                grass.rotation.y = Math.random() * Math.PI;
                grass.rotation.x = -0.1;
                scene.add(grass);
            }
        }
        
        function createBuildings() {
            buildings = [];

            const buildingData = [
                // Village center
                { x: 20, z: 0, type: 'house' },
                { x: -20, z: 0, type: 'shop' },
                { x: 20, z: 25, type: 'barn' },
                { x: -20, z: -25, type: 'tower' },
                // New buildings
                { x: 0, z: 35, type: 'tavern' },
                { x: -35, z: 15, type: 'blacksmith' },
                { x: 35, z: -15, type: 'church' },
                { x: -10, z: -40, type: 'windmill' },
                { x: 45, z: 20, type: 'watchtower' },
                { x: -45, z: -10, type: 'house' },
                { x: 30, z: 45, type: 'stable' },
                { x: -30, z: 40, type: 'shop' },
                // Outer buildings
                { x: 55, z: -35, type: 'ruins' },
                { x: -55, z: 35, type: 'cottage' },
                { x: 60, z: 50, type: 'watchtower' },
                { x: -60, z: -50, type: 'barn' }
            ];

            buildingData.forEach(b => {
                const terrainY = getTerrainHeight(b.x, b.z);
                createBuilding(b.x, b.z, b.type, terrainY);
            });

            // Add village well in center
            createWell(0, 15);

            // Add market stalls
            createMarketStall(-8, 8);
            createMarketStall(-4, 8);
            createMarketStall(4, 8);

            // Add fences
            createFence(-15, 25, 20, 0);
            createFence(15, 25, 20, 0);
            createFence(-25, 20, 15, Math.PI / 2);
        }

        function createWell(x, z) {
            const terrainY = getTerrainHeight(x, z);
            const wellGroup = new THREE.Group();

            // Stone base
            const baseGeo = new THREE.CylinderGeometry(1.2, 1.4, 0.8, 12);
            const stoneMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 });
            const base = new THREE.Mesh(baseGeo, stoneMat);
            base.position.y = 0.4;
            base.castShadow = true;
            wellGroup.add(base);

            // Inner hole (dark)
            const holeGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 12);
            const holeMat = new THREE.MeshStandardMaterial({ color: 0x111122 });
            const hole = new THREE.Mesh(holeGeo, holeMat);
            hole.position.y = 0.82;
            wellGroup.add(hole);

            // Wooden frame posts
            const postMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 });
            for (let i = 0; i < 2; i++) {
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.5, 0.15), postMat);
                post.position.set(i === 0 ? -1 : 1, 1.6, 0);
                post.castShadow = true;
                wellGroup.add(post);
            }

            // Roof beam
            const beam = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.15, 0.2), postMat);
            beam.position.y = 2.9;
            wellGroup.add(beam);

            // Roof
            const roofGeo = new THREE.BoxGeometry(2.8, 0.1, 1.5);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 3.1;
            roof.rotation.x = 0.15;
            wellGroup.add(roof);

            // Bucket
            const bucketGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.25, 8);
            const bucketMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
            const bucket = new THREE.Mesh(bucketGeo, bucketMat);
            bucket.position.set(0, 1.5, 0);
            wellGroup.add(bucket);

            // Rope
            const ropeGeo = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 6);
            const ropeMat = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
            const rope = new THREE.Mesh(ropeGeo, ropeMat);
            rope.position.set(0, 2.2, 0);
            wellGroup.add(rope);

            wellGroup.position.set(x, terrainY, z);
            scene.add(wellGroup);
        }

        function createMarketStall(x, z) {
            const terrainY = getTerrainHeight(x, z);
            const stallGroup = new THREE.Group();

            // Table
            const tableMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const table = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 1.2), tableMat);
            table.position.y = 1;
            table.castShadow = true;
            stallGroup.add(table);

            // Legs
            for (let lx = -0.8; lx <= 0.8; lx += 1.6) {
                for (let lz = -0.4; lz <= 0.4; lz += 0.8) {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 0.1), tableMat);
                    leg.position.set(lx, 0.5, lz);
                    stallGroup.add(leg);
                }
            }

            // Canopy poles
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
            for (let px = -0.9; px <= 0.9; px += 1.8) {
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2, 8), poleMat);
                pole.position.set(px, 2, -0.5);
                stallGroup.add(pole);
            }

            // Canopy
            const canopyColors = [0xcc3333, 0x3366cc, 0x33aa33, 0xcccc33];
            const canopyColor = canopyColors[Math.floor(Math.random() * canopyColors.length)];
            const canopyMat = new THREE.MeshStandardMaterial({ color: canopyColor, roughness: 0.9, side: THREE.DoubleSide });
            const canopy = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 1.5), canopyMat);
            canopy.position.set(0, 2.8, 0);
            canopy.rotation.x = -0.3;
            stallGroup.add(canopy);

            // Goods on table (random items)
            const goodsColors = [0xff6600, 0xffff00, 0x00ff00, 0xff0000, 0x8B4513];
            for (let g = 0; g < 5; g++) {
                const goodGeo = Math.random() > 0.5 ?
                    new THREE.SphereGeometry(0.1, 8, 8) :
                    new THREE.BoxGeometry(0.15, 0.15, 0.15);
                const goodMat = new THREE.MeshStandardMaterial({ color: goodsColors[g] });
                const good = new THREE.Mesh(goodGeo, goodMat);
                good.position.set(-0.6 + g * 0.3, 1.15, (Math.random() - 0.5) * 0.6);
                stallGroup.add(good);
            }

            stallGroup.position.set(x, terrainY, z);
            scene.add(stallGroup);
        }

        function createFence(x, z, length, rotation) {
            const terrainY = getTerrainHeight(x, z);
            const fenceGroup = new THREE.Group();
            const fenceMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.9 });

            const postCount = Math.floor(length / 2);
            for (let i = 0; i < postCount; i++) {
                // Post
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.12, 1.2, 0.12), fenceMat);
                post.position.set(i * 2 - length / 2 + 1, 0.6, 0);
                post.castShadow = true;
                fenceGroup.add(post);

                // Horizontal beams
                if (i < postCount - 1) {
                    const beam1 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.06), fenceMat);
                    beam1.position.set(i * 2 - length / 2 + 2, 0.9, 0);
                    fenceGroup.add(beam1);

                    const beam2 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.06), fenceMat);
                    beam2.position.set(i * 2 - length / 2 + 2, 0.4, 0);
                    fenceGroup.add(beam2);
                }
            }

            fenceGroup.rotation.y = rotation;
            fenceGroup.position.set(x, terrainY, z);
            scene.add(fenceGroup);
        }
        
        function createBuilding(x, z, type, terrainY) {
            const building = new THREE.Group();
            
            let width, depth, height, wallColor, roofColor;
            
            let isSpecial = false;

            switch(type) {
                case 'house':
                    width = 7; depth = 5; height = 3.5;
                    wallColor = 0xD2B48C;
                    roofColor = 0x8B4513;
                    break;
                case 'shop':
                    width = 8; depth = 6; height = 3.5;
                    wallColor = 0xF5DEB3;
                    roofColor = 0x654321;
                    break;
                case 'barn':
                    width = 10; depth = 7; height = 4;
                    wallColor = 0xCD853F;
                    roofColor = 0x8B0000;
                    break;
                case 'tower':
                    width = 5; depth = 5; height = 8;
                    wallColor = 0x808080;
                    roofColor = 0x2F4F4F;
                    break;
                case 'tavern':
                    width = 12; depth = 8; height = 4.5;
                    wallColor = 0xDEB887;
                    roofColor = 0x4a3728;
                    break;
                case 'blacksmith':
                    width = 9; depth = 7; height = 3.5;
                    wallColor = 0x696969;
                    roofColor = 0x2F2F2F;
                    break;
                case 'church':
                    width = 10; depth = 15; height = 7;
                    wallColor = 0xE8E8E8;
                    roofColor = 0x4a4a5a;
                    break;
                case 'windmill':
                    width = 6; depth = 6; height = 10;
                    wallColor = 0xF5F5DC;
                    roofColor = 0x8B4513;
                    isSpecial = true;
                    break;
                case 'watchtower':
                    width = 4; depth = 4; height = 12;
                    wallColor = 0x808080;
                    roofColor = 0x2F4F4F;
                    break;
                case 'stable':
                    width = 12; depth = 8; height = 3;
                    wallColor = 0x8B7355;
                    roofColor = 0x654321;
                    break;
                case 'ruins':
                    width = 8; depth = 8; height = 2;
                    wallColor = 0x696969;
                    roofColor = 0x505050;
                    isSpecial = true;
                    break;
                case 'cottage':
                    width = 5; depth = 4; height = 2.5;
                    wallColor = 0xD2B48C;
                    roofColor = 0x556B2F;
                    break;
                default:
                    width = 6; depth = 5; height = 3;
                    wallColor = 0xBDB76B;
                    roofColor = 0x8B4513;
            }
            
            // Calculate terrain heights at corners for foundation
            const corners = [
                { cx: x - width/2, cz: z - depth/2 },
                { cx: x + width/2, cz: z - depth/2 },
                { cx: x - width/2, cz: z + depth/2 },
                { cx: x + width/2, cz: z + depth/2 }
            ];
            
            let minTerrainY = terrainY;
            let maxTerrainY = terrainY;
            corners.forEach(c => {
                const h = getTerrainHeight(c.cx, c.cz);
                minTerrainY = Math.min(minTerrainY, h);
                maxTerrainY = Math.max(maxTerrainY, h);
            });
            
            // Foundation height to cover the slope
            const foundationHeight = maxTerrainY - minTerrainY + 0.5;
            const baseY = minTerrainY;
            
            // Create adaptive foundation using multiple segments
            const foundationMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
            
            // Create foundation segments to match terrain
            const segmentsX = 4;
            const segmentsZ = 4;
            const segWidth = width / segmentsX;
            const segDepth = depth / segmentsZ;
            
            for (let sx = 0; sx < segmentsX; sx++) {
                for (let sz = 0; sz < segmentsZ; sz++) {
                    const segX = -width/2 + segWidth/2 + sx * segWidth;
                    const segZ = -depth/2 + segDepth/2 + sz * segDepth;
                    const worldX = x + segX;
                    const worldZ = z + segZ;
                    const segTerrainY = getTerrainHeight(worldX, worldZ);
                    
                    // Height from terrain to building base
                    const segFoundHeight = (baseY + foundationHeight) - segTerrainY + 0.1;
                    
                    if (segFoundHeight > 0.05) {
                        const foundGeo = new THREE.BoxGeometry(segWidth + 0.05, segFoundHeight, segDepth + 0.05);
                        const foundSeg = new THREE.Mesh(foundGeo, foundationMat);
                        foundSeg.position.set(segX, segTerrainY - baseY + segFoundHeight/2, segZ);
                        foundSeg.castShadow = true;
                        foundSeg.receiveShadow = true;
                        building.add(foundSeg);
                    }
                }
            }
            
            // Building base level (on top of foundation)
            const buildingBaseY = foundationHeight;
            
            const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.85 });
            const wallThickness = 0.25;
            const doorWidth = 1.4;
            const doorHeight = 2.2;
            
            // Front wall - LEFT of door
            const frontLeftGeo = new THREE.BoxGeometry((width - doorWidth) / 2, height, wallThickness);
            const frontLeft = new THREE.Mesh(frontLeftGeo, wallMat);
            frontLeft.position.set(-(width/4 + doorWidth/4), buildingBaseY + height/2, depth/2);
            frontLeft.castShadow = true;
            frontLeft.receiveShadow = true;
            building.add(frontLeft);
            
            // Front wall - RIGHT of door
            const frontRight = new THREE.Mesh(frontLeftGeo, wallMat);
            frontRight.position.set((width/4 + doorWidth/4), buildingBaseY + height/2, depth/2);
            frontRight.castShadow = true;
            frontRight.receiveShadow = true;
            building.add(frontRight);
            
            // Front wall - ABOVE door
            const frontTopGeo = new THREE.BoxGeometry(doorWidth, height - doorHeight, wallThickness);
            const frontTop = new THREE.Mesh(frontTopGeo, wallMat);
            frontTop.position.set(0, buildingBaseY + height - (height - doorHeight)/2, depth/2);
            frontTop.castShadow = true;
            building.add(frontTop);
            
            // Back wall (solid)
            const backWallGeo = new THREE.BoxGeometry(width, height, wallThickness);
            const backWall = new THREE.Mesh(backWallGeo, wallMat);
            backWall.position.set(0, buildingBaseY + height/2, -depth/2);
            backWall.castShadow = true;
            backWall.receiveShadow = true;
            building.add(backWall);
            
            // Side walls
            const sideWallGeo = new THREE.BoxGeometry(wallThickness, height, depth);
            const leftWall = new THREE.Mesh(sideWallGeo, wallMat);
            leftWall.position.set(-width/2, buildingBaseY + height/2, 0);
            leftWall.castShadow = true;
            building.add(leftWall);
            
            const rightWall = new THREE.Mesh(sideWallGeo, wallMat);
            rightWall.position.set(width/2, buildingBaseY + height/2, 0);
            rightWall.castShadow = true;
            building.add(rightWall);
            
            // Roof
            const roofMat = new THREE.MeshStandardMaterial({ color: roofColor, roughness: 0.8 });
            if (type === 'tower') {
                const roofGeo = new THREE.ConeGeometry(width * 0.75, height * 0.4, 4);
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.set(0, buildingBaseY + height + height * 0.2, 0);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                building.add(roof);
            } else {
                const roofGeo = new THREE.BoxGeometry(width + 0.6, 0.3, depth + 0.6);
                const roofBase = new THREE.Mesh(roofGeo, roofMat);
                roofBase.position.set(0, buildingBaseY + height, 0);
                roofBase.castShadow = true;
                building.add(roofBase);
                
                // Pitched roof
                const pitchGeo = new THREE.CylinderGeometry(0, depth * 0.6, height * 0.35, 4);
                const pitch = new THREE.Mesh(pitchGeo, roofMat);
                pitch.position.set(0, buildingBaseY + height + height * 0.17, 0);
                pitch.rotation.y = Math.PI / 4;
                pitch.castShadow = true;
                building.add(pitch);
            }
            
            // Floor
            const floorGeo = new THREE.PlaneGeometry(width - 0.5, depth - 0.5);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.9 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = buildingBaseY + 0.05;
            floor.receiveShadow = true;
            building.add(floor);
            
            // Interior
            createInterior(building, width, depth, height, type, buildingBaseY);
            
            // Door frame
            const doorFrameMat = new THREE.MeshStandardMaterial({ color: 0x4A3C31 });
            const doorFrameGeo = new THREE.BoxGeometry(doorWidth + 0.2, 0.15, 0.3);
            const doorTop = new THREE.Mesh(doorFrameGeo, doorFrameMat);
            doorTop.position.set(0, buildingBaseY + doorHeight, depth/2 + 0.1);
            building.add(doorTop);
            
            // Windows
            const windowMat = new THREE.MeshStandardMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.5
            });
            
            [-width/3, width/3].forEach(wx => {
                const windowGeo = new THREE.BoxGeometry(0.8, 0.8, 0.15);
                const win = new THREE.Mesh(windowGeo, windowMat);
                win.position.set(wx, buildingBaseY + height * 0.55, depth/2 + 0.15);
                building.add(win);
            });
            
            // Add special features for specific building types
            if (type === 'windmill') {
                // Windmill blades
                const bladeGroup = new THREE.Group();
                const bladeMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.8 });
                for (let b = 0; b < 4; b++) {
                    const blade = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 0.1), bladeMat);
                    blade.position.y = 2;
                    blade.rotation.z = b * Math.PI / 2;
                    bladeGroup.add(blade);
                    // Blade frame
                    const frame = new THREE.Mesh(new THREE.BoxGeometry(0.1, 3.5, 0.05), bladeMat);
                    frame.position.set(0.15, 1.75, 0);
                    frame.rotation.z = b * Math.PI / 2;
                    bladeGroup.add(frame);
                }
                bladeGroup.position.set(0, buildingBaseY + height * 0.7, depth / 2 + 0.5);
                building.add(bladeGroup);
                // Store for animation
                building.userData.blades = bladeGroup;
            }

            if (type === 'church') {
                // Church steeple
                const steepleGeo = new THREE.ConeGeometry(1.5, 5, 4);
                const steeepleMat = new THREE.MeshStandardMaterial({ color: roofColor, metalness: 0.3 });
                const steeple = new THREE.Mesh(steepleGeo, steeepleMat);
                steeple.position.set(0, buildingBaseY + height + 3.5, -depth / 3);
                steeple.rotation.y = Math.PI / 4;
                building.add(steeple);
                // Cross
                const crossMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8 });
                const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.2, 0.15), crossMat);
                crossV.position.set(0, buildingBaseY + height + 6.5, -depth / 3);
                building.add(crossV);
                const crossH = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.15, 0.15), crossMat);
                crossH.position.set(0, buildingBaseY + height + 6.2, -depth / 3);
                building.add(crossH);
                // Rose window
                const roseGeo = new THREE.CircleGeometry(1.2, 16);
                const roseMat = new THREE.MeshStandardMaterial({
                    color: 0x4169E1,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const rose = new THREE.Mesh(roseGeo, roseMat);
                rose.position.set(0, buildingBaseY + height * 0.65, depth / 2 + 0.16);
                building.add(rose);
            }

            if (type === 'blacksmith') {
                // Chimney with smoke
                const chimneyGeo = new THREE.BoxGeometry(1.2, 3, 1.2);
                const chimneyMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.9 });
                const chimney = new THREE.Mesh(chimneyGeo, chimneyMat);
                chimney.position.set(width / 3, buildingBaseY + height + 1, -depth / 3);
                building.add(chimney);
                // Anvil outside
                const anvilBase = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.4, 0.4),
                    new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9 })
                );
                anvilBase.position.set(width / 2 + 1.5, buildingBaseY + 0.2, 0);
                building.add(anvilBase);
                const anvilTop = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.15, 0.5),
                    new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.95 })
                );
                anvilTop.position.set(width / 2 + 1.5, buildingBaseY + 0.48, 0);
                building.add(anvilTop);
                // Forge glow
                const forgeGlow = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 1, 0.5),
                    new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.6 })
                );
                forgeGlow.position.set(-width / 3, buildingBaseY + 0.5, depth / 2 - 0.5);
                building.add(forgeGlow);
            }

            if (type === 'tavern') {
                // Tavern sign
                const signPost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 2, 8),
                    new THREE.MeshStandardMaterial({ color: 0x4a3728 })
                );
                signPost.position.set(width / 2 + 0.5, buildingBaseY + 2.5, depth / 2);
                building.add(signPost);
                const signBoard = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 0.8, 0.1),
                    new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                );
                signBoard.position.set(width / 2 + 0.5, buildingBaseY + 3.2, depth / 2 + 0.4);
                building.add(signBoard);
                // Barrels outside
                for (let br = 0; br < 3; br++) {
                    const barrel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.35, 0.3, 0.7, 12),
                        new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 })
                    );
                    barrel.position.set(-width / 2 - 0.8, buildingBaseY + 0.35, depth / 4 - br * 0.8);
                    building.add(barrel);
                }
            }

            if (type === 'stable') {
                // Horse stall dividers
                const stallMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
                for (let s = 0; s < 4; s++) {
                    const divider = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2, depth - 1), stallMat);
                    divider.position.set(-width / 2 + 2.5 + s * 2.5, buildingBaseY + 1, 0);
                    building.add(divider);
                }
                // Hay bales
                const hayMat = new THREE.MeshStandardMaterial({ color: 0xDAA520 });
                for (let h = 0; h < 3; h++) {
                    const hay = new THREE.Mesh(new THREE.BoxGeometry(1, 0.6, 0.8), hayMat);
                    hay.position.set(width / 2 - 1.5, buildingBaseY + 0.3 + h * 0.5, -depth / 3 + h * 0.3);
                    hay.rotation.y = h * 0.2;
                    building.add(hay);
                }
            }

            if (type === 'ruins') {
                // Broken walls scattered
                const ruinMat = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 1 });
                for (let r = 0; r < 8; r++) {
                    const rubble = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5 + Math.random(), 0.3 + Math.random() * 0.5, 0.5 + Math.random()),
                        ruinMat
                    );
                    rubble.position.set(
                        (Math.random() - 0.5) * width,
                        buildingBaseY + 0.2,
                        (Math.random() - 0.5) * depth
                    );
                    rubble.rotation.set(Math.random() * 0.3, Math.random() * Math.PI, Math.random() * 0.3);
                    building.add(rubble);
                }
                // Partial standing wall
                const wallPiece = new THREE.Mesh(new THREE.BoxGeometry(3, 2.5, 0.4), ruinMat);
                wallPiece.position.set(-width / 4, buildingBaseY + 1.25, depth / 3);
                wallPiece.rotation.y = 0.2;
                building.add(wallPiece);
            }

            if (type === 'watchtower') {
                // Platform at top
                const platformGeo = new THREE.BoxGeometry(width + 1.5, 0.3, depth + 1.5);
                const platformMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
                const platform = new THREE.Mesh(platformGeo, platformMat);
                platform.position.y = buildingBaseY + height - 0.5;
                building.add(platform);
                // Battlements
                const bMat = new THREE.MeshStandardMaterial({ color: wallColor });
                for (let bx = -1; bx <= 1; bx++) {
                    for (let bz = -1; bz <= 1; bz++) {
                        if (Math.abs(bx) + Math.abs(bz) === 2) {
                            const battlement = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 0.8), bMat);
                            battlement.position.set(bx * (width / 2 + 0.4), buildingBaseY + height + 0.2, bz * (depth / 2 + 0.4));
                            building.add(battlement);
                        }
                    }
                }
                // Flag
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8), poleMat);
                pole.position.set(0, buildingBaseY + height + 1.25, 0);
                building.add(pole);
                const flagMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, side: THREE.DoubleSide });
                const flag = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.8), flagMat);
                flag.position.set(0.6, buildingBaseY + height + 2, 0);
                building.add(flag);
            }

            building.position.set(x, baseY, z);
            scene.add(building);
            
            // Collision - walls only (not door opening)
            const collisionY = baseY + buildingBaseY;
            
            // Left wall collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x - width/2, collisionY, z),
                width: wallThickness + 0.3,
                depth: depth + 0.3,
                canAutoJump: false
            });
            // Right wall collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x + width/2, collisionY, z),
                width: wallThickness + 0.3,
                depth: depth + 0.3,
                canAutoJump: false
            });
            // Back wall collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x, collisionY, z - depth/2),
                width: width + 0.3,
                depth: wallThickness + 0.3,
                canAutoJump: false
            });
            // Front wall LEFT collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x - (width/4 + doorWidth/4), collisionY, z + depth/2),
                width: (width - doorWidth) / 2 + 0.3,
                depth: wallThickness + 0.3,
                canAutoJump: false
            });
            // Front wall RIGHT collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x + (width/4 + doorWidth/4), collisionY, z + depth/2),
                width: (width - doorWidth) / 2 + 0.3,
                depth: wallThickness + 0.3,
                canAutoJump: false
            });
            
            buildings.push({ x, z, width, depth, height, type, baseY });
        }
        
        function createInterior(building, width, depth, height, type, buildingBaseY) {
            // Table
            const tableMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const tableGeo = new THREE.BoxGeometry(1.6, 0.08, 0.8);
            const table = new THREE.Mesh(tableGeo, tableMat);
            table.position.set(0, buildingBaseY + 0.7, 0);
            table.castShadow = true;
            building.add(table);
            
            // Table legs
            const legGeo = new THREE.BoxGeometry(0.08, 0.7, 0.08);
            [[-0.7, -0.3], [-0.7, 0.3], [0.7, -0.3], [0.7, 0.3]].forEach(([lx, lz]) => {
                const leg = new THREE.Mesh(legGeo, tableMat);
                leg.position.set(lx, buildingBaseY + 0.35, lz);
                building.add(leg);
            });
            
            // Chair
            const chairMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const chairSeat = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.04, 0.4), chairMat);
            chairSeat.position.set(-1.3, buildingBaseY + 0.45, 0);
            building.add(chairSeat);
            
            const chairBack = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.04), chairMat);
            chairBack.position.set(-1.3, buildingBaseY + 0.7, -0.2);
            building.add(chairBack);
            
            // Fireplace for house
            if (type === 'house' || type === 'shop') {
                const fireplaceGeo = new THREE.BoxGeometry(1.2, 1, 0.4);
                const fireplaceMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A });
                const fireplace = new THREE.Mesh(fireplaceGeo, fireplaceMat);
                fireplace.position.set(0, buildingBaseY + 0.5, -depth/2 + 0.4);
                building.add(fireplace);
                
                const fireLight = new THREE.PointLight(0xff6600, 0.6, 4);
                fireLight.position.set(0, buildingBaseY + 0.4, -depth/2 + 0.6);
                building.add(fireLight);
            }
            
            // Ceiling light
            const lightGeo = new THREE.CylinderGeometry(0.25, 0.3, 0.15, 8);
            const lightMat = new THREE.MeshStandardMaterial({ color: 0xB8860B });
            const ceilingLight = new THREE.Mesh(lightGeo, lightMat);
            ceilingLight.position.set(0, buildingBaseY + height - 0.4, 0);
            building.add(ceilingLight);
            
            const interiorLight = new THREE.PointLight(0xffee88, 0.5, 6);
            interiorLight.position.set(0, buildingBaseY + height - 0.5, 0);
            building.add(interiorLight);
        }
        
        function generateSettingsUI() {
            const container = document.getElementById('settingsContent');
            container.innerHTML = '';

            // Device mode setting
            const deviceCat = document.createElement('div');
            deviceCat.className = 'settings-category';
            const deviceTitle = document.createElement('div');
            deviceTitle.className = 'settings-category-title';
            deviceTitle.textContent = 'Device';
            deviceCat.appendChild(deviceTitle);

            const deviceRow = document.createElement('div');
            deviceRow.className = 'setting-row';
            const deviceLabel = document.createElement('span');
            deviceLabel.className = 'setting-label';
            deviceLabel.textContent = 'Input Mode';
            deviceRow.appendChild(deviceLabel);

            const deviceSelect = document.createElement('select');
            deviceSelect.style.cssText = 'background: #333; color: white; border: 1px solid #555; padding: 5px 10px; border-radius: 4px;';
            deviceSelect.innerHTML = `
                <option value="computer" ${deviceMode === 'computer' ? 'selected' : ''}>Computer</option>
                <option value="mobile" ${deviceMode === 'mobile' ? 'selected' : ''}>Mobile</option>
            `;
            deviceSelect.onchange = () => {
                deviceMode = deviceSelect.value;
                setCookie('deviceMode', deviceMode);
            };
            deviceRow.appendChild(deviceSelect);
            deviceCat.appendChild(deviceRow);

            // Clear saved data option
            const clearRow = document.createElement('div');
            clearRow.className = 'setting-row';
            const clearLabel = document.createElement('span');
            clearLabel.className = 'setting-label';
            clearLabel.textContent = 'Reset Device Data';
            clearRow.appendChild(clearLabel);

            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'Clear';
            clearBtn.style.cssText = 'background: #c44; color: white; border: none; padding: 5px 15px; border-radius: 4px; cursor: pointer;';
            clearBtn.onclick = () => {
                if (confirm('Clear saved device preferences? You will need to select your device again.')) {
                    setCookie('deviceMode', '', -1);
                    location.reload();
                }
            };
            clearRow.appendChild(clearBtn);
            deviceCat.appendChild(clearRow);
            container.appendChild(deviceCat);

            const categories = {
                'Gameplay': ['autoJump', 'autoCollectCoins'],
                'Movement': ['walkSpeed', 'sprintSpeed'],
                'Camera': ['sensitivity', 'invertY'],
                'Display': ['showDamageNumbers', 'showMinimap']
            };
            
            for (const [category, settingsList] of Object.entries(categories)) {
                const catDiv = document.createElement('div');
                catDiv.className = 'settings-category';
                
                const title = document.createElement('div');
                title.className = 'settings-category-title';
                title.textContent = category;
                catDiv.appendChild(title);
                
                settingsList.forEach(key => {
                    if (settings[key] === undefined) return;
                    
                    const row = document.createElement('div');
                    row.className = 'setting-row';
                    
                    const label = document.createElement('span');
                    label.className = 'setting-label';
                    label.textContent = key.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
                    row.appendChild(label);
                    
                    const value = settings[key];
                    
                    if (typeof value === 'boolean') {
                        const toggle = document.createElement('div');
                        toggle.className = 'toggle-switch' + (value ? ' on' : '');
                        toggle.onclick = () => {
                            settings[key] = !settings[key];
                            toggle.classList.toggle('on');
                        };
                        row.appendChild(toggle);
                    } else if (typeof value === 'number') {
                        const sliderContainer = document.createElement('div');
                        sliderContainer.className = 'slider-container';
                        
                        const slider = document.createElement('input');
                        slider.type = 'range';
                        slider.className = 'slider';
                        slider.min = 0;
                        slider.max = 100;
                        slider.value = value;
                        
                        const valDisplay = document.createElement('span');
                        valDisplay.className = 'slider-value';
                        valDisplay.textContent = value;
                        
                        slider.oninput = () => {
                            settings[key] = parseInt(slider.value);
                            valDisplay.textContent = slider.value;
                        };
                        
                        sliderContainer.appendChild(slider);
                        sliderContainer.appendChild(valDisplay);
                        row.appendChild(sliderContainer);
                    }
                    
                    catDiv.appendChild(row);
                });
                
                container.appendChild(catDiv);
            }
        }
        
        function setupHotbar() {
            const el = document.getElementById('hotbar');
            el.innerHTML = '';
            
            for (let i = 0; i < 6; i++) {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot' + (i === selectedSlot ? ' selected' : '');
                slot.onclick = () => selectSlot(i);
                
                const itemId = hotbar[i];
                if (itemId && itemDefs[itemId]) {
                    const item = itemDefs[itemId];
                    slot.innerHTML = `
                        <span class="slot-key">${i + 1}</span>
                        <span class="item-icon">${item.icon}</span>
                        <span class="item-name">${item.name}</span>
                        <div class="cooldown-overlay" id="cooldown${i}"></div>
                    `;
                } else {
                    slot.innerHTML = `<span class="slot-key">${i + 1}</span><span class="item-icon" style="opacity:0.2">+</span>`;
                }
                
                el.appendChild(slot);
            }
            updateWeaponView();
        }
        
        function selectSlot(index) {
            selectedSlot = index;
            document.querySelectorAll('.hotbar-slot').forEach((el, i) => {
                el.classList.toggle('selected', i === index);
            });
            updateWeaponView();
        }
        
        function updateWeaponView() {
            // No longer needed - using 3D sword
        }
        
        function selectDevice(mode) {
            deviceMode = mode;
            setCookie('deviceMode', mode);
            document.getElementById('deviceSelect').style.display = 'none';
            document.getElementById('startSection').style.display = 'block';
        }

        // Check for saved device mode on page load
        function initDeviceMode() {
            const savedMode = getCookie('deviceMode');
            if (savedMode) {
                deviceMode = savedMode;
                document.getElementById('deviceSelect').style.display = 'none';
                document.getElementById('startSection').style.display = 'block';
            }
        }
        
        function openShop() { document.getElementById('shopPanel').style.display = 'flex'; updateShopUI(); }
        function closeShop() { document.getElementById('shopPanel').style.display = 'none'; }
        
        function updateShopUI() {
            const el = document.getElementById('shopItems');
            el.innerHTML = '';

            // Add coin packages section
            const coinPackagesDiv = document.createElement('div');
            coinPackagesDiv.className = 'coin-packages';
            coinPackagesDiv.innerHTML = `
                <div class="coin-packages-title">üí∞ BUY COINS üí∞</div>
                <div class="coin-package" onclick="buyCoins('small')">
                    <div class="coin-package-info">
                        <div class="coin-package-name">Small Pack</div>
                        <div class="coin-package-coins">üí∞ 500 Coins</div>
                    </div>
                    <div class="coin-package-price">$4.99</div>
                </div>
                <div class="coin-package" onclick="buyCoins('medium')">
                    <div class="coin-package-info">
                        <div class="coin-package-name">Medium Pack</div>
                        <div class="coin-package-coins">üí∞ 1,200 Coins</div>
                    </div>
                    <div class="coin-package-price">$9.99</div>
                </div>
                <div class="coin-package" onclick="buyCoins('large')">
                    <div class="coin-package-info">
                        <div class="coin-package-name">Large Pack</div>
                        <div class="coin-package-coins">üí∞ 2,500 Coins</div>
                    </div>
                    <div class="coin-package-price">$19.99</div>
                </div>
                <div class="coin-package" onclick="buyCoins('mega')">
                    <div class="coin-package-info">
                        <div class="coin-package-name">Mega Pack</div>
                        <div class="coin-package-coins">üí∞ 6,000 Coins</div>
                    </div>
                    <div class="coin-package-price">$49.99</div>
                </div>
            `;
            el.appendChild(coinPackagesDiv);

            // Add generated weapons section (if any exist)
            if (generatedShopWeapons.length > 0) {
                const generatedDivider = document.createElement('div');
                generatedDivider.className = 'shop-divider';
                generatedDivider.style.cssText = 'background: linear-gradient(90deg, #a0f, #ff0, #a0f); color: #000; font-weight: bold;';
                generatedDivider.textContent = 'üé≤ AI-GENERATED WEAPONS üé≤';
                el.appendChild(generatedDivider);

                generatedShopWeapons.forEach((weapon, index) => {
                    const owned = inventory.ownedItems.includes(weapon.id);
                    const canAfford = inventory.coins >= weapon.price;
                    const rarityColor = getRarityColor(weapon.rarity);

                    const div = document.createElement('div');
                    div.className = 'shop-item';
                    div.style.cssText = `border-left: 3px solid ${rarityColor}; background: linear-gradient(90deg, rgba(160,0,255,0.1), transparent);`;
                    div.innerHTML = `
                        <span class="shop-item-icon">${weapon.icon}</span>
                        <div class="shop-item-info">
                            <div class="shop-item-name" style="color: ${rarityColor};">${weapon.name}</div>
                            <div class="shop-item-desc">${weapon.desc}</div>
                            <div style="font-size: 10px; color: #888;">DMG: ${weapon.damage} | ${weapon.rarity.toUpperCase()}</div>
                            ${weapon.special ? `<div style="color: #ff0; font-size: 9px;">‚ú® ${weapon.special}</div>` : ''}
                        </div>
                        <span class="shop-item-price">${owned ? '‚úì' : 'üí∞' + weapon.price}</span>
                        ${owned ? '' : `<button class="shop-buy-btn" onclick="buyGeneratedWeapon(${index})" ${canAfford ? '' : 'disabled'}>Buy</button>`}
                    `;
                    el.appendChild(div);
                });
            }

            // Add divider
            const divider = document.createElement('div');
            divider.className = 'shop-divider';
            divider.textContent = '‚öîÔ∏è WEAPONS & ITEMS ‚öîÔ∏è';
            el.appendChild(divider);

            // Add shop items
            shopItems.forEach(si => {
                const item = itemDefs[si.id];
                const owned = inventory.ownedItems.includes(si.id);
                const canAfford = inventory.coins >= si.price;

                const div = document.createElement('div');
                div.className = 'shop-item';
                div.innerHTML = `
                    <span class="shop-item-icon">${item.icon}</span>
                    <div class="shop-item-info">
                        <div class="shop-item-name">${item.name}</div>
                        <div class="shop-item-desc">${item.desc}</div>
                    </div>
                    <span class="shop-item-price">${owned ? '‚úì' : 'üí∞' + si.price}</span>
                    ${owned ? '' : `<button class="shop-buy-btn" onclick="buyItem('${si.id}', ${si.price})" ${canAfford ? '' : 'disabled'}>Buy</button>`}
                `;
                el.appendChild(div);
            });

            document.getElementById('menuCoins').textContent = 'üí∞ ' + inventory.coins;
        }
        
        function buyItem(itemId, price) {
            if (inventory.coins >= price && !inventory.ownedItems.includes(itemId)) {
                inventory.coins -= price;
                inventory.ownedItems.push(itemId);
                const emptySlot = hotbar.findIndex(s => s === null);
                if (emptySlot !== -1) hotbar[emptySlot] = itemId;
                updateShopUI();
                setupHotbar();
                saveCoinsToCloud(); // Save to cloud after purchase
            }
        }

        async function buyCoins(coinPackage) {
            // Require authentication to purchase coins
            if (!authenticatedUsername) {
                alert('Please log in or create an account to purchase coins. Your coins will be saved to your account.');
                showAuthModal();
                return;
            }

            try {
                const response = await fetch('/api/create-checkout-session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ coinPackage, userId: authenticatedUsername })
                });

                const data = await response.json();

                if (data.url) {
                    // Open Stripe Checkout in a new tab
                    window.open(data.url, '_blank');
                } else {
                    alert(data.error || 'Error creating checkout session');
                }
            } catch (error) {
                console.error('Checkout error:', error);
                alert('Could not connect to payment service. Please check your connection and try again.');
            }
        }

        // Check if user just completed a payment
        async function checkPaymentSuccess() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('success') === 'true') {
                const sessionId = urlParams.get('session_id');
                if (sessionId) {
                    try {
                        const response = await fetch('/api/verify-session', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ sessionId })
                        });
                        const data = await response.json();
                        if (data.coins) {
                            inventory.coins += data.coins;
                            saveCoinsToCloud();
                            alert(`Payment successful! ${data.coins} coins have been added to your account!`);
                        } else {
                            alert('Payment verification failed. Please contact support.');
                        }
                    } catch (error) {
                        console.error('Payment verification error:', error);
                        alert('Could not verify payment. Please contact support.');
                    }
                }
                // Clean up URL
                window.history.replaceState({}, document.title, window.location.pathname);
            } else if (urlParams.get('canceled') === 'true') {
                alert('Payment was canceled');
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }

        // ========== AI COIN PRICING ==========
        let currentAIPrice = null;
        let priceDebounceTimer = null;

        function openCustomCoinModal() {
            document.getElementById('customCoinModal').style.display = 'flex';
            document.getElementById('coinAmount').value = 500;
            calculateAIPrice(500);
        }

        function closeCustomCoinModal() {
            document.getElementById('customCoinModal').style.display = 'none';
        }

        document.addEventListener('DOMContentLoaded', () => {
            const coinInput = document.getElementById('coinAmount');
            if (coinInput) {
                coinInput.addEventListener('input', (e) => {
                    clearTimeout(priceDebounceTimer);
                    priceDebounceTimer = setTimeout(() => {
                        const coins = parseInt(e.target.value) || 0;
                        if (coins >= 50 && coins <= 50000) {
                            calculateAIPrice(coins);
                        } else {
                            document.getElementById('priceDisplay').textContent = 'Enter 50-50,000 coins';
                            document.getElementById('priceDisplay').style.color = '#ff6600';
                            document.getElementById('aiReasoning').textContent = '';
                        }
                    }, 300);
                });
            }
        });

        async function calculateAIPrice(coins) {
            document.getElementById('priceDisplay').textContent = 'AI is calculating...';
            document.getElementById('priceDisplay').style.color = '#ffff00';
            document.getElementById('aiReasoning').textContent = '';
            document.getElementById('buyCoinsBtn').disabled = true;

            try {
                const response = await fetch('/api/ai-coin-pricing', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ coins })
                });

                const data = await response.json();
                if (data.price && data.url) {
                    currentAIPrice = data;
                    document.getElementById('priceDisplay').textContent = `$${data.price.toFixed(2)} for ${coins} coins`;
                    document.getElementById('priceDisplay').style.color = '#00ff00';
                    document.getElementById('aiReasoning').textContent = data.reasoning || '';
                    document.getElementById('buyCoinsBtn').disabled = false;
                } else if (data.price && !data.url) {
                    currentAIPrice = null;
                    document.getElementById('priceDisplay').textContent = data.stripeError || 'Payment temporarily unavailable';
                    document.getElementById('priceDisplay').style.color = '#ff6600';
                    document.getElementById('aiReasoning').textContent = '';
                    document.getElementById('buyCoinsBtn').disabled = true;
                } else {
                    document.getElementById('priceDisplay').textContent = 'Error calculating price';
                    document.getElementById('priceDisplay').style.color = '#ff0000';
                }
            } catch (error) {
                console.error('AI pricing error:', error);
                document.getElementById('priceDisplay').textContent = 'Connection error';
                document.getElementById('priceDisplay').style.color = '#ff0000';
            }
        }

        async function purchaseAICoins() {
            if (!currentAIPrice || !currentAIPrice.url) {
                alert('Please wait for price calculation');
                return;
            }
            window.location.href = currentAIPrice.url;
        }

        // ========== INVENTORY MANAGEMENT ==========
        let generatedWeapons = JSON.parse(localStorage.getItem('generatedWeapons') || '[]');
        let generatedShopWeapons = JSON.parse(localStorage.getItem('generatedShopWeapons') || '[]');
        let inventoryOrder = JSON.parse(localStorage.getItem('inventoryOrder') || '[]');

        function openInventory() {
            document.getElementById('inventoryPanel').style.display = 'flex';
            renderInventory();
        }

        function closeInventory() {
            document.getElementById('inventoryPanel').style.display = 'none';
        }

        function saveInventoryOrder() {
            localStorage.setItem('inventoryOrder', JSON.stringify(inventoryOrder));
        }

        function saveHotbar() {
            localStorage.setItem('hotbarState', JSON.stringify(hotbar));
        }

        function loadHotbar() {
            const saved = localStorage.getItem('hotbarState');
            if (saved) {
                const savedHotbar = JSON.parse(saved);
                for (let i = 0; i < 6; i++) {
                    if (savedHotbar[i] && (itemDefs[savedHotbar[i]] || generatedWeapons.find(w => w.id === savedHotbar[i]))) {
                        hotbar[i] = savedHotbar[i];
                    }
                }
            }
        }

        function renderInventory() {
            // Render hotbar config
            const hotbarConfig = document.getElementById('hotbarConfig');
            hotbarConfig.innerHTML = '';
            for (let i = 0; i < 6; i++) {
                const itemId = hotbar[i];
                const item = itemId ? (itemDefs[itemId] || generatedWeapons.find(w => w.id === itemId)) : null;
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot' + (i === selectedSlot ? ' selected' : '');
                slot.style.cssText = 'width: 60px; height: 60px; cursor: pointer; position: relative; transition: all 0.2s;';
                slot.setAttribute('data-slot-index', i);

                if (item) {
                    slot.draggable = true;
                    slot.innerHTML = `
                        <span class="item-icon">${item.icon}</span>
                        <span class="item-name">${item.name}</span>
                    `;

                    // Drag from hotbar
                    slot.ondragstart = (e) => {
                        e.dataTransfer.setData('weaponId', itemId);
                        e.dataTransfer.setData('fromHotbar', i.toString());
                        slot.style.opacity = '0.5';
                    };
                    slot.ondragend = (e) => {
                        slot.style.opacity = '1';
                    };
                } else {
                    slot.innerHTML = `<span style="color: #444;">Empty</span>`;
                }

                // Click to unequip
                slot.onclick = () => {
                    if (item) {
                        hotbar[i] = null;
                        renderInventory();
                        setupHotbar();
                    }
                };

                // Right-click context menu
                slot.oncontextmenu = (e) => {
                    e.preventDefault();
                    if (item) {
                        if (confirm(`Unequip ${item.name}?`)) {
                            hotbar[i] = null;
                            renderInventory();
                            setupHotbar();
                        }
                    }
                };

                slot.ondragover = (e) => {
                    e.preventDefault();
                    slot.style.background = 'rgba(255, 255, 0, 0.3)';
                };

                slot.ondragleave = (e) => {
                    slot.style.background = '';
                };

                slot.ondrop = (e) => {
                    e.preventDefault();
                    slot.style.background = '';

                    const weaponId = e.dataTransfer.getData('weaponId');
                    const fromHotbarIndex = e.dataTransfer.getData('fromHotbar');

                    if (weaponId) {
                        if (fromHotbarIndex !== '') {
                            // Swapping between hotbar slots
                            const fromIndex = parseInt(fromHotbarIndex);
                            const currentWeapon = hotbar[i];
                            hotbar[i] = weaponId;
                            hotbar[fromIndex] = currentWeapon;
                        } else {
                            // Moving from inventory to hotbar
                            const oldSlot = hotbar.indexOf(weaponId);
                            if (oldSlot !== -1) hotbar[oldSlot] = null;

                            // If slot is occupied, swap
                            if (hotbar[i]) {
                                const temp = hotbar[i];
                                hotbar[i] = weaponId;
                                // Put the displaced weapon in the old slot if available
                                if (oldSlot !== -1) {
                                    hotbar[oldSlot] = temp;
                                }
                            } else {
                                hotbar[i] = weaponId;
                            }
                        }
                        renderInventory();
                        setupHotbar();
                    }
                };
                hotbarConfig.appendChild(slot);
            }

            // Render all owned weapons
            const grid = document.getElementById('inventoryGrid');
            grid.innerHTML = '';

            const allWeapons = [...inventory.ownedItems, ...generatedWeapons.map(w => w.id)];
            const uniqueWeapons = [...new Set(allWeapons)];

            // Update inventory order
            const newWeapons = uniqueWeapons.filter(w => !inventoryOrder.includes(w));
            inventoryOrder = [...inventoryOrder.filter(w => uniqueWeapons.includes(w)), ...newWeapons];
            saveInventoryOrder();

            inventoryOrder.forEach((weaponId, index) => {
                const item = itemDefs[weaponId] || generatedWeapons.find(w => w.id === weaponId);
                if (!item) return;

                const equipped = hotbar.includes(weaponId);
                const div = document.createElement('div');
                div.draggable = true;
                div.setAttribute('data-weapon-id', weaponId);
                div.setAttribute('data-inventory-index', index);
                div.style.cssText = `
                    background: ${equipped ? 'rgba(0,255,0,0.2)' : 'rgba(255,255,255,0.05)'};
                    border: 2px solid ${equipped ? '#0f0' : '#444'};
                    border-radius: 8px;
                    padding: 10px;
                    text-align: center;
                    cursor: grab;
                    transition: all 0.2s;
                    position: relative;
                `;
                div.innerHTML = `
                    <div style="font-size: 24px;">${item.icon}</div>
                    <div style="color: white; font-size: 10px;">${item.name}</div>
                    <div style="color: #888; font-size: 8px;">DMG: ${item.damage || 0}</div>
                    ${item.rarity ? `<div style="color: ${getRarityColor(item.rarity)}; font-size: 8px;">${item.rarity.toUpperCase()}</div>` : ''}
                    ${equipped ? '<div style="position: absolute; top: 2px; right: 2px; color: #0f0; font-size: 10px;">‚úì</div>' : ''}
                `;

                div.ondragstart = (e) => {
                    e.dataTransfer.setData('weaponId', weaponId);
                    e.dataTransfer.setData('inventoryIndex', index.toString());
                    div.style.opacity = '0.5';
                };

                div.ondragend = (e) => {
                    div.style.opacity = '1';
                };

                div.ondragover = (e) => {
                    e.preventDefault();
                    div.style.transform = 'scale(1.1)';
                    div.style.borderColor = '#ff0';
                    div.style.boxShadow = '0 0 15px rgba(255,255,0,0.6)';
                };

                div.ondragleave = (e) => {
                    div.style.transform = '';
                    div.style.borderColor = equipped ? '#0f0' : '#444';
                    div.style.boxShadow = '';
                };

                div.ondrop = (e) => {
                    e.preventDefault();
                    // Smooth transition on drop
                    div.style.transition = 'all 0.2s ease';
                    div.style.transform = 'scale(1.05)';
                    div.style.boxShadow = '';
                    setTimeout(() => {
                        div.style.transform = '';
                        div.style.borderColor = equipped ? '#0f0' : '#444';
                        div.style.transition = '';
                    }, 150);

                    const draggedWeaponId = e.dataTransfer.getData('weaponId');
                    const draggedInventoryIndex = e.dataTransfer.getData('inventoryIndex');

                    if (draggedInventoryIndex !== '' && draggedWeaponId !== weaponId) {
                        // Reorder within inventory
                        const fromIndex = parseInt(draggedInventoryIndex);
                        const toIndex = index;

                        const temp = inventoryOrder[fromIndex];
                        inventoryOrder.splice(fromIndex, 1);
                        inventoryOrder.splice(toIndex, 0, temp);

                        saveInventoryOrder();
                        renderInventory();
                    }
                };

                // Click to equip/unequip with visual feedback
                div.onclick = () => {
                    // Visual click feedback
                    div.style.transform = 'scale(0.95)';
                    setTimeout(() => { div.style.transform = ''; }, 100);

                    if (equipped) {
                        // Unequip
                        const slotIndex = hotbar.indexOf(weaponId);
                        if (slotIndex !== -1) {
                            hotbar[slotIndex] = null;
                            showNotification(`${item.name} unequipped`);
                        }
                    } else {
                        // Equip to first empty slot
                        const emptySlot = hotbar.findIndex(s => s === null);
                        if (emptySlot !== -1) {
                            hotbar[emptySlot] = weaponId;
                            showNotification(`${item.name} equipped to slot ${emptySlot + 1}`);
                        } else {
                            showNotification('Hotbar full! Unequip a weapon first.');
                            return;
                        }
                    }
                    renderInventory();
                    setupHotbar();
                    saveHotbar();
                };

                // Right-click context menu
                div.oncontextmenu = (e) => {
                    e.preventDefault();
                    if (equipped) {
                        const slotIndex = hotbar.indexOf(weaponId);
                        if (slotIndex !== -1 && confirm(`Unequip ${item.name} from slot ${slotIndex + 1}?`)) {
                            hotbar[slotIndex] = null;
                            renderInventory();
                            setupHotbar();
                        }
                    } else {
                        const emptySlot = hotbar.findIndex(s => s === null);
                        if (emptySlot !== -1 && confirm(`Equip ${item.name} to slot ${emptySlot + 1}?`)) {
                            hotbar[emptySlot] = weaponId;
                            renderInventory();
                            setupHotbar();
                        } else if (emptySlot === -1) {
                            alert('No empty hotbar slots available. Unequip a weapon first.');
                        }
                    }
                };

                grid.appendChild(div);
            });

            // Update generate button if all base weapons owned
            const baseWeaponCount = Object.keys(itemDefs).length;
            const ownedCount = inventory.ownedItems.length;
            const btn = document.getElementById('generateWeaponBtn');
            if (ownedCount >= baseWeaponCount * 0.8) {
                btn.style.display = 'block';
            }
        }

        function getRarityColor(rarity) {
            const colors = {
                common: '#aaa',
                uncommon: '#0f0',
                rare: '#00f',
                epic: '#a0f',
                legendary: '#ff0'
            };
            return colors[rarity] || '#fff';
        }

        function showNotification(message, duration = 2000) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
                background: rgba(0,0,0,0.9); color: #ff0; padding: 15px 25px;
                border-radius: 8px; z-index: 99999; font-size: 14px;
                border: 1px solid #ff0; animation: fadeInOut ${duration}ms ease-in-out;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), duration);
        }

        async function generateNewWeapon() {
            const btn = document.getElementById('generateWeaponBtn');
            btn.textContent = 'Generating...';
            btn.disabled = true;

            try {
                const response = await fetch('/api/generate-weapon', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ownedWeapons: [...inventory.ownedItems, ...generatedWeapons.map(w => w.id)],
                        playerLevel: currentWave,
                        preferredType: null
                    })
                });

                const data = await response.json();
                if (data.success && data.weapon) {
                    // Add to shop (NOT directly to inventory - must purchase!)
                    generatedShopWeapons.push(data.weapon);
                    localStorage.setItem('generatedShopWeapons', JSON.stringify(generatedShopWeapons));

                    // Add to itemDefs so it can be displayed
                    itemDefs[data.weapon.id] = data.weapon;

                    // Show weapon details and prompt to buy
                    const special = data.weapon.special ? `\nSpecial: ${data.weapon.special}` : '';
                    alert(`New weapon generated!\n\n${data.weapon.name} (${data.weapon.rarity.toUpperCase()})\n${data.weapon.desc}\nDamage: ${data.weapon.damage}${special}\n\nPrice: ${data.weapon.price} coins\n\nCheck the shop to purchase!`);

                    // Open shop to show the new weapon
                    openShop();
                } else {
                    alert('Failed to generate weapon');
                }
            } catch (error) {
                console.error('Weapon generation error:', error);
                alert('Error connecting to AI');
            }

            btn.textContent = 'Generate New Weapon (AI)';
            btn.disabled = false;
        }

        function buyGeneratedWeapon(index) {
            const weapon = generatedShopWeapons[index];
            if (!weapon) return;

            if (inventory.coins >= weapon.price && !inventory.ownedItems.includes(weapon.id)) {
                // Deduct coins
                inventory.coins -= weapon.price;

                // Add to owned items
                inventory.ownedItems.push(weapon.id);

                // Move from shop to owned generated weapons
                generatedWeapons.push(weapon);
                localStorage.setItem('generatedWeapons', JSON.stringify(generatedWeapons));

                // Remove from shop
                generatedShopWeapons.splice(index, 1);
                localStorage.setItem('generatedShopWeapons', JSON.stringify(generatedShopWeapons));

                // Auto-equip to empty slot if available
                const emptySlot = hotbar.findIndex(s => s === null);
                if (emptySlot !== -1) {
                    hotbar[emptySlot] = weapon.id;
                    saveHotbar();
                }

                // Update UIs
                updateShopUI();
                setupHotbar();
                saveCoinsToCloud();

                showNotification(`Purchased ${weapon.name}!`);
            } else if (inventory.coins < weapon.price) {
                showNotification('Not enough coins!');
            }
        }

        // Load generated weapons into itemDefs on startup
        generatedWeapons.forEach(w => {
            if (w && w.id) itemDefs[w.id] = w;
        });

        // Load generated shop weapons into itemDefs on startup
        generatedShopWeapons.forEach(w => {
            if (w && w.id) itemDefs[w.id] = w;
        });

        // Load saved hotbar on startup
        loadHotbar();

        function openSettings() { generateSettingsUI(); document.getElementById('settingsPanel').style.display = 'flex'; }
        function closeSettings() { document.getElementById('settingsPanel').style.display = 'none'; }
        function quitGame() { location.reload(); }
        
        function enterFullscreen() {
            const el = document.documentElement;
            if (el.requestFullscreen) el.requestFullscreen();
            else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        }
        
        function setupInput() {
            document.addEventListener('keydown', (e) => {
                // Block game input while chat is open
                if (isChatOpen) {
                    if (e.code === 'Enter') {
                        sendChatMessage();
                    } else if (e.code === 'Escape') {
                        closeChatInput();
                    }
                    return;
                }

                // ESC to return to menu
                if (e.code === 'Escape' && gameRunning) {
                    if (isMultiplayer) {
                        leaveMultiplayer();
                    } else {
                        backToMenu();
                    }
                    return;
                }

                keys[e.code] = true;
                if (e.code >= 'Digit1' && e.code <= 'Digit6') {
                    selectSlot(parseInt(e.code.replace('Digit', '')) - 1);
                }

                // Open chat with T key in multiplayer
                if (e.code === 'KeyT' && isMultiplayer && gameRunning) {
                    e.preventDefault();
                    openChatInput();
                }
            });
            document.addEventListener('keyup', (e) => {
                if (isChatOpen) return;
                keys[e.code] = false;
            });
            
            if (deviceMode === 'computer') setupComputerControls();
            else setupMobileControls();
        }
        
        function setupComputerControls() {
            const canvas = renderer.domElement;

            // Request pointer lock on canvas click
            canvas.addEventListener('click', (e) => {
                if (gameRunning && document.pointerLockElement !== canvas) {
                    canvas.requestPointerLock();
                }
            });

            // Use mousedown for attacks (works better with pointer lock)
            document.addEventListener('mousedown', (e) => {
                if (!gameRunning) return;
                if (document.pointerLockElement === canvas) {
                    if (e.button === 0) { // Left click = attack
                        useCurrentItem();
                    }
                }
            });

            // Handle pointer lock change
            document.addEventListener('pointerlockchange', () => {
                const clickMsg = document.getElementById('clickToPlay');
                if (document.pointerLockElement === canvas) {
                    clickMsg.style.display = 'none';
                } else if (gameRunning && deviceMode === 'computer') {
                    clickMsg.style.display = 'block';
                }
            });

            // Mouse movement with pointer lock
            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvas && gameRunning) {
                    const sens = settings.sensitivity / 8000;
                    playerState.rotation.y -= e.movementX * sens;
                    playerState.rotation.x -= e.movementY * sens * (settings.invertY ? -1 : 1);
                    playerState.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, playerState.rotation.x));
                }
            });

            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        function setupMobileControls() {
            document.body.classList.add('mobile-mode');
            
            const joystickZone = document.getElementById('joystickZone');
            const joystickBase = document.getElementById('joystickBase');
            const joystickKnob = document.getElementById('joystickKnob');
            
            let moveTouchId = null;
            let lookTouchId = null;
            let moveStartX = 0, moveStartY = 0;
            let lookStartX = 0, lookStartY = 0;
            
            document.addEventListener('touchstart', (e) => {
                if (!gameRunning) return;
                
                const jRect = joystickZone.getBoundingClientRect();
                const aRect = document.getElementById('attackBtn').getBoundingClientRect();
                const jRect2 = document.getElementById('jumpBtn').getBoundingClientRect();
                const dRect = document.getElementById('dashBtn').getBoundingClientRect();
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    const tx = t.clientX, ty = t.clientY;
                    
                    // Check buttons
                    if (tx >= aRect.left && tx <= aRect.right && ty >= aRect.top && ty <= aRect.bottom) {
                        useCurrentItem(); continue;
                    }
                    if (tx >= jRect2.left && tx <= jRect2.right && ty >= jRect2.top && ty <= jRect2.bottom) {
                        jump(); continue;
                    }
                    if (tx >= dRect.left && tx <= dRect.right && ty >= dRect.top && ty <= dRect.bottom) {
                        dash(); continue;
                    }
                    
                    // Joystick
                    if (tx >= jRect.left && tx <= jRect.right && ty >= jRect.top && ty <= jRect.bottom) {
                        if (moveTouchId === null) {
                            moveTouchId = t.identifier;
                            const bRect = joystickBase.getBoundingClientRect();
                            moveStartX = bRect.left + bRect.width / 2;
                            moveStartY = bRect.top + bRect.height / 2;
                            joystickActive = true;
                        }
                        continue;
                    }
                    
                    // Look
                    if (lookTouchId === null) {
                        lookTouchId = t.identifier;
                        lookStartX = tx;
                        lookStartY = ty;
                    }
                }
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                if (!gameRunning) return;
                
                for (let i = 0; i < e.touches.length; i++) {
                    const t = e.touches[i];
                    
                    // Joystick - FIXED DIRECTION
                    if (t.identifier === moveTouchId) {
                        const dx = t.clientX - moveStartX;
                        const dy = t.clientY - moveStartY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const maxDist = 35;
                        
                        if (dist > 0) {
                            const clampedDist = Math.min(dist, maxDist);
                            const ratio = clampedDist / maxDist;
                            
                            // X is left/right (strafe), Y is forward/back
                            // Up on screen (negative dy) = forward in game
                            joystickX = (dx / dist) * ratio;
                            joystickY = (-dy / dist) * ratio;
                            
                            const vx = (dx / dist) * clampedDist;
                            const vy = (dy / dist) * clampedDist;
                            joystickKnob.style.transform = `translate(${vx}px, ${vy}px)`;
                        } else {
                            joystickX = 0;
                            joystickY = 0;
                            joystickKnob.style.transform = 'translate(0, 0)';
                        }
                    }
                    
                    // Look
                    if (t.identifier === lookTouchId) {
                        const sens = settings.sensitivity / 1500;
                        const dx = t.clientX - lookStartX;
                        const dy = t.clientY - lookStartY;
                        
                        playerState.rotation.y -= dx * sens;
                        playerState.rotation.x -= dy * sens * (settings.invertY ? -1 : 1);
                        playerState.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, playerState.rotation.x));
                        
                        lookStartX = t.clientX;
                        lookStartY = t.clientY;
                    }
                }
            }, { passive: true });
            
            document.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === moveTouchId) {
                        moveTouchId = null;
                        joystickActive = false;
                        joystickX = 0;
                        joystickY = 0;
                        joystickKnob.style.transform = 'translate(0, 0)';
                    }
                    if (t.identifier === lookTouchId) {
                        lookTouchId = null;
                    }
                }
            }, { passive: true });
        }
        
        let minimapCtx;
        function setupMinimap() {
            const c = document.getElementById('minimapCanvas');
            c.width = 90; c.height = 90;
            minimapCtx = c.getContext('2d');
        }
        
        function updateMinimap() {
            if (!minimapCtx || !settings.showMinimap) return;
            minimapCtx.fillStyle = 'rgba(20,40,20,0.9)';
            minimapCtx.fillRect(0, 0, 90, 90);
            
            const scale = 0.25;
            const cx = 45, cy = 45;
            
            // Buildings
            minimapCtx.fillStyle = '#886644';
            buildings.forEach(b => {
                const bx = cx + (b.x - playerState.position.x) * scale;
                const by = cy + (b.z - playerState.position.z) * scale;
                minimapCtx.fillRect(bx - 3, by - 3, 6, 6);
            });
            
            // Enemies
            minimapCtx.fillStyle = '#ff4444';
            enemies.forEach(e => {
                if (!e.mesh) return;
                const ex = cx + (e.mesh.position.x - playerState.position.x) * scale;
                const ey = cy + (e.mesh.position.z - playerState.position.z) * scale;
                if (ex > 0 && ex < 90 && ey > 0 && ey < 90) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(ex, ey, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            // Coins
            minimapCtx.fillStyle = 'gold';
            coins.forEach(c => {
                if (!c.mesh) return;
                const coinX = cx + (c.mesh.position.x - playerState.position.x) * scale;
                const coinY = cy + (c.mesh.position.z - playerState.position.z) * scale;
                if (coinX > 0 && coinX < 90 && coinY > 0 && coinY < 90) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(coinX, coinY, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            // Player
            minimapCtx.fillStyle = '#44ff44';
            minimapCtx.beginPath();
            minimapCtx.arc(cx, cy, 3, 0, Math.PI * 2);
            minimapCtx.fill();
            
            minimapCtx.strokeStyle = '#88ff88';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(cx, cy);
            minimapCtx.lineTo(cx - Math.sin(playerState.rotation.y) * 8, cy - Math.cos(playerState.rotation.y) * 8);
            minimapCtx.stroke();
        }
        
        function updateHUD() {
            const hp = (playerState.health / playerState.maxHealth) * 100;
            document.querySelector('#healthBar .bar-fill').style.width = hp + '%';
            document.querySelector('#healthBar .bar-text').textContent = Math.ceil(playerState.health) + '/' + playerState.maxHealth;
            
            const ep = (playerState.energy / playerState.maxEnergy) * 100;
            document.querySelector('#energyBar .bar-fill').style.width = ep + '%';
            document.querySelector('#energyBar .bar-text').textContent = Math.ceil(playerState.energy) + '/' + playerState.maxEnergy;
            
            document.getElementById('waveNum').textContent = currentWave;
            document.getElementById('score').textContent = playerState.score;
            document.getElementById('coinsDisplay').textContent = 'üí∞ ' + inventory.coins;
            
            for (let i = 0; i < 6; i++) {
                const el = document.getElementById('cooldown' + i);
                if (!el) continue;
                const itemId = hotbar[i];
                if (itemId && itemCooldowns[itemId] > 0) {
                    el.style.display = 'block';
                    el.textContent = Math.ceil(itemCooldowns[itemId] / 1000);
                } else {
                    el.style.display = 'none';
                }
            }
        }
        
        function useCurrentItem() {
            const itemId = hotbar[selectedSlot];
            if (!itemId) return;
            const item = itemDefs[itemId];
            if (!item || itemCooldowns[itemId] > 0) return;
            if (item.energy && playerState.energy < item.energy) return;
            
            itemCooldowns[itemId] = item.cooldown;
            if (item.energy) playerState.energy -= item.energy;

            // In multiplayer, check for player hits
            if (isMultiplayer && (item.type === 'weapon' || item.type === 'ranged' || (item.type === 'ability' && item.damage))) {
                sendMultiplayerAttack();
            }

            // Handle by item type for easier management
            if (item.type === 'weapon') {
                // Melee weapons with different ranges
                const ranges = { spear: 3.5, gungnir: 3.5, halberd: 3.2, bo_staff: 3.0, whip: 3.5, holy_lance: 3.2,
                                 dagger: 1.8, claws: 1.8, venom_dagger: 1.8, nunchucks: 2.0, sickle: 2.2 };
                meleeAttack(item.damage, ranges[itemId] || 2.5);
            }
            else if (item.type === 'ranged') {
                // Ranged weapons
                const colors = { bow: 0x8B4513, crossbow: 0x444444, shuriken: 0xcccccc, javelin: 0x8B4513,
                                boomerang: 0xDEB887, kunai: 0x333333, chakram: 0xffd700, blowdart: 0x228B22 };
                shootProjectile(item.damage, colors[itemId] || 0xaaaaaa);
            }
            else if (item.type === 'ability' && item.damage) {
                // Magic/projectile abilities
                const colors = {
                    fireball: 0xff4400, iceball: 0x00ccff, lightning: 0xffff00, poison: 0x00ff00,
                    laser: 0xff0000, meteor: 0xff6600, tornado: 0x888888, earthquake: 0x8B4513,
                    tsunami: 0x0066ff, vortex: 0x440088, solar: 0xffff00, lunar: 0xaaaaff,
                    arcane: 0xff00ff, nature: 0x00aa00, shadow: 0x222222, holy: 0xffffcc,
                    plasma: 0xaa00ff, gravity: 0x000000, chain_lightning: 0x00ffff, frost_nova: 0x00ffff,
                    fire_storm: 0xff2200, supernova: 0xffaa00, apocalypse: 0x330000, genesis: 0xffffff,
                    oblivion: 0x000000, grenade: 0x556b2f, dynamite: 0xff0000, molotov: 0xff4500,
                    flashbang: 0xffffff, cluster_bomb: 0xff6600, nuke: 0x00ff00,
                    summon_wolf: 0x808080, summon_dragon: 0xff0000, summon_golem: 0x8B4513,
                    summon_phoenix: 0xff6600, summon_demon: 0x8b0000
                };
                shootProjectile(item.damage, colors[itemId] || 0xffffff);
            }
            else {
                // Utility abilities
                switch (itemId) {
                    case 'shield':
                        playerState.defense += 20;
                        setTimeout(() => playerState.defense -= 20, 4000);
                        break;
                    case 'medkit':
                        playerState.health = Math.min(playerState.maxHealth, playerState.health + item.healing);
                        break;
                    case 'megaHeal':
                        playerState.health = playerState.maxHealth;
                        break;
                    case 'jumpPad':
                        playerState.velocity.y = 0.25;
                        playerState.isGrounded = false;
                        break;
                    case 'speedBoost':
                        playerState.speed *= 2;
                        playerState.sprintSpeed *= 2;
                        setTimeout(() => { playerState.speed /= 2; playerState.sprintSpeed /= 2; }, 3000);
                        break;
                    case 'rage':
                        playerState.rageModeActive = true;
                        setTimeout(() => { playerState.rageModeActive = false; }, 5000);
                        break;
                    case 'invisibility':
                        playerState.invisible = true;
                        setTimeout(() => { playerState.invisible = false; }, 5000);
                        break;
                    case 'teleport':
                        const dir = new THREE.Vector3();
                        camera.getWorldDirection(dir);
                        playerState.position.x += dir.x * 10;
                        playerState.position.z += dir.z * 10;
                        break;
                    case 'reflect':
                        playerState.reflecting = true;
                        setTimeout(() => { playerState.reflecting = false; }, 4000);
                        break;
                    case 'lifesteal':
                        playerState.lifestealActive = true;
                        setTimeout(() => { playerState.lifestealActive = false; }, 6000);
                        break;
                    case 'timestop':
                        playerState.timestopActive = true;
                        setTimeout(() => { playerState.timestopActive = false; }, 3000);
                        break;
                    case 'clone':
                        // Visual effect only for now
                        break;
                    case 'berserk':
                        playerState.berserkActive = true;
                        setTimeout(() => { playerState.berserkActive = false; }, 5000);
                        break;
                    case 'fortify':
                        playerState.defense += 50;
                        setTimeout(() => playerState.defense -= 50, 6000);
                        break;
                    case 'regenerate':
                        playerState.regenerating = true;
                        setTimeout(() => { playerState.regenerating = false; }, 10000);
                        break;
                    case 'energize':
                        playerState.energy = Math.min(playerState.maxEnergy, playerState.energy + 50);
                        break;
                    case 'smoke_bomb':
                        // Escape utility
                        break;
                }
            }
        }
        
        function meleeAttack(damage, range = 2.5) {
            // Apply damage bonuses
            if (playerState.rageModeActive) damage *= 2;
            if (playerState.berserkActive) damage *= 3;

            // Start sword swing animation
            swordSwinging = true;
            swordSwingTime = 0;
            if (swordMesh) swordMesh.visible = true;

            const raycaster = new THREE.Raycaster();
            raycaster.far = range;
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            raycaster.set(camera.position, dir);

            // Create slash particle effect
            const slashPos = camera.position.clone().add(dir.clone().multiplyScalar(1));
            createSlashParticles(slashPos, dir, 0xccccff);

            const enemyMeshes = enemies.map(e => e.mesh).filter(m => m);

            // Check hits against all enemy parts
            let hitEnemy = null;
            enemies.forEach(e => {
                if (!e.mesh) return;
                const enemyPos = e.mesh.position;
                const distToEnemy = camera.position.distanceTo(enemyPos);
                if (distToEnemy < range) {
                    // Check if enemy is roughly in front of player
                    const toEnemy = enemyPos.clone().sub(camera.position).normalize();
                    const dot = toEnemy.dot(dir);
                    if (dot > 0.5) {
                        hitEnemy = e;
                    }
                }
            });

            if (hitEnemy) {
                damageEnemy(hitEnemy, damage, Math.random() < 0.15);
                // Hit particles on enemy
                const hitPos = hitEnemy.mesh.position.clone();
                hitPos.y += 0.8;
                createHitParticles(hitPos, 0xff4400);
            }

            if (boss && boss.mesh) {
                const bossPos = boss.mesh.position;
                const distToBoss = camera.position.distanceTo(bossPos);
                if (distToBoss < 3) {
                    const toBoss = bossPos.clone().sub(camera.position).normalize();
                    const dot = toBoss.dot(dir);
                    if (dot > 0.4) {
                        damageBoss(damage, Math.random() < 0.15);
                        // Hit particles on boss
                        const hitPos = boss.mesh.position.clone();
                        hitPos.y += 1.5;
                        createHitParticles(hitPos, 0xff0000);
                    }
                }
            }
        }
        
        function shootProjectile(damage, color) {
            // Apply damage bonuses
            if (playerState.rageModeActive) damage *= 2;
            if (playerState.berserkActive) damage *= 3;

            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);

            // Cast particles at player position
            const castPos = camera.position.clone().add(dir.clone().multiplyScalar(0.5));
            createMagicParticles(castPos, color, 8, 0.05);

            const geo = new THREE.SphereGeometry(0.15, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color });
            const proj = new THREE.Mesh(geo, mat);
            proj.position.copy(camera.position);
            scene.add(proj);

            // Add glow effect to projectile
            const glowGeo = new THREE.SphereGeometry(0.22, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            proj.add(glow);

            projectiles.push({ mesh: proj, direction: dir.clone(), speed: 0.25, damage, life: 3000, color: color, trailTimer: 0 });
        }
        
        function jump() {
            if (playerState.isGrounded) {
                playerState.velocity.y = 0.1;
                playerState.isGrounded = false;
            }
        }
        
        function dash() {
            if (playerState.energy < 10) return;
            playerState.energy -= 10;
            
            let mx = 0, mz = 0;
            if (deviceMode === 'mobile') {
                mx = joystickX;
                mz = joystickY;
            } else {
                if (keys['KeyW']) mz = -1;
                if (keys['KeyS']) mz = 1;
                if (keys['KeyA']) mx = -1;
                if (keys['KeyD']) mx = 1;
            }
            
            const sin = Math.sin(playerState.rotation.y);
            const cos = Math.cos(playerState.rotation.y);
            const wx = mx * cos + mz * sin;
            const wz = mz * cos - mx * sin;

            if (wx === 0 && wz === 0) return;
            const len = Math.sqrt(wx * wx + wz * wz);
            
            const newX = playerState.position.x + (wx / len) * 2;
            const newZ = playerState.position.z + (wz / len) * 2;
            
            if (!checkCollision(newX, newZ)) {
                playerState.position.x = newX;
                playerState.position.z = newZ;
            }
        }
        
        function checkCollision(x, z) {
            const r = 0.35;
            for (const col of colliders) {
                const dx = x - col.position.x;
                const dz = z - col.position.z;
                
                if (col.type === 'cylinder' || col.type === 'sphere') {
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < col.radius + r) {
                        if (settings.autoJump && col.canAutoJump && playerState.isGrounded) {
                            playerState.velocity.y = 0.08;
                            playerState.isGrounded = false;
                            return false;
                        }
                        return true;
                    }
                } else if (col.type === 'box') {
                    if (Math.abs(dx) < col.width / 2 + r && Math.abs(dz) < col.depth / 2 + r) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Enemy types with different stats and appearances - more detailed
        const enemyTypes = [
            { name: 'Grunt', bodyColor: 0x8B4513, skinColor: 0xDEB887, eyeColor: 0xff3300,
              armorColor: 0x654321, accentColor: 0xA0522D, glowColor: null,
              weapon: 'sword', weaponColor: 0xcccccc, health: 1.0, damage: 1.0, speed: 1.0,
              hasCape: false, hasAura: false, scarCount: 1, scale: 1.0 },
            { name: 'Brute', bodyColor: 0x8B0000, skinColor: 0xCD5C5C, eyeColor: 0xffff00,
              armorColor: 0x2F1010, accentColor: 0xff4444, glowColor: 0xff2200,
              weapon: 'axe', weaponColor: 0x555555, health: 1.8, damage: 1.6, speed: 0.7,
              hasCape: false, hasAura: true, scarCount: 3, scale: 1.15 },
            { name: 'Assassin', bodyColor: 0x1a0a1a, skinColor: 0x9370DB, eyeColor: 0x00ffff,
              armorColor: 0x2d1f3d, accentColor: 0x8A2BE2, glowColor: 0x00ffff,
              weapon: 'dagger', weaponColor: 0x222222, health: 0.6, damage: 1.3, speed: 1.5,
              hasCape: true, hasAura: false, scarCount: 0, scale: 0.9 },
            { name: 'Mage', bodyColor: 0x191970, skinColor: 0xB0C4DE, eyeColor: 0xff00ff,
              armorColor: 0x0a0a40, accentColor: 0x4169E1, glowColor: 0x9400D3,
              weapon: 'staff', weaponColor: 0x9400D3, health: 0.7, damage: 1.8, speed: 0.9,
              hasCape: true, hasAura: true, scarCount: 0, scale: 1.0 },
            { name: 'Knight', bodyColor: 0x2F4F4F, skinColor: 0xC0C0C0, eyeColor: 0xff4400,
              armorColor: 0x708090, accentColor: 0xFFD700, glowColor: null,
              weapon: 'hammer', weaponColor: 0x4a4a4a, health: 2.2, damage: 2.0, speed: 0.6,
              hasCape: true, hasAura: false, scarCount: 2, scale: 1.1 }
        ];

        // Check if position is inside or too close to a building
        function isInsideBuilding(x, z, margin = 2) {
            for (const b of buildings) {
                const halfW = b.width / 2 + margin;
                const halfD = b.depth / 2 + margin;
                if (x > b.x - halfW && x < b.x + halfW &&
                    z > b.z - halfD && z < b.z + halfD) {
                    return true;
                }
            }
            return false;
        }

        // Calculate terrain slope and return height + rotation to match hill angle
        function getTerrainDataForEnemy(x, z) {
            const sampleDist = 0.4;
            const centerY = getTerrainHeight(x, z);
            const frontY = getTerrainHeight(x, z + sampleDist);
            const backY = getTerrainHeight(x, z - sampleDist);
            const leftY = getTerrainHeight(x - sampleDist, z);
            const rightY = getTerrainHeight(x + sampleDist, z);

            // Calculate slope angles
            const slopeX = Math.atan2(rightY - leftY, sampleDist * 2);
            const slopeZ = Math.atan2(frontY - backY, sampleDist * 2);

            return { y: centerY, rotX: slopeZ, rotZ: -slopeX };
        }

        function spawnEnemy() {
            // Try to find a valid spawn position (not inside buildings)
            let x, z, attempts = 0;
            do {
                const angle = Math.random() * Math.PI * 2;
                const distance = 18 + Math.random() * 12;
                x = playerState.position.x + Math.cos(angle) * distance;
                z = playerState.position.z + Math.sin(angle) * distance;
                attempts++;
            } while (isInsideBuilding(x, z) && attempts < 10);

            const terrain = getTerrainDataForEnemy(x, z);

            // Pick random enemy type
            const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];

            // Create enemy group for body parts
            const enemyGroup = new THREE.Group();

            // Body (torso) with armor
            const bodyGeo = new THREE.CylinderGeometry(0.28, 0.34, 0.85, 12);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: type.armorColor,
                roughness: 0.4,
                metalness: type.name === 'Knight' ? 0.7 : 0.2
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            enemyGroup.add(body);

            // Chest plate / armor detail
            const chestGeo = new THREE.BoxGeometry(0.45, 0.35, 0.2);
            const chestMat = new THREE.MeshStandardMaterial({
                color: type.bodyColor,
                roughness: 0.3,
                metalness: type.name === 'Knight' ? 0.8 : 0.3
            });
            const chest = new THREE.Mesh(chestGeo, chestMat);
            chest.position.set(0, 0.7, 0.12);
            chest.castShadow = true;
            enemyGroup.add(chest);

            // Belt
            const beltGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.08, 12);
            const beltMat = new THREE.MeshStandardMaterial({ color: type.accentColor, roughness: 0.5, metalness: 0.4 });
            const belt = new THREE.Mesh(beltGeo, beltMat);
            belt.position.y = 0.25;
            enemyGroup.add(belt);

            // Belt buckle
            const buckleMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.9, roughness: 0.2 });
            const buckle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.08, 0.05), buckleMat);
            buckle.position.set(0, 0.25, 0.36);
            enemyGroup.add(buckle);

            // Head with better detail
            const headGeo = new THREE.SphereGeometry(0.24, 16, 14);
            const headMat = new THREE.MeshStandardMaterial({
                color: type.skinColor,
                roughness: 0.7,
                metalness: 0.1
            });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.18;
            head.castShadow = true;
            enemyGroup.add(head);

            // Type-specific headgear
            if (type.name === 'Knight') {
                // Helmet
                const helmetGeo = new THREE.SphereGeometry(0.27, 12, 10, 0, Math.PI * 2, 0, Math.PI * 0.6);
                const helmetMat = new THREE.MeshStandardMaterial({ color: type.armorColor, metalness: 0.8, roughness: 0.3 });
                const helmet = new THREE.Mesh(helmetGeo, helmetMat);
                helmet.position.y = 1.25;
                enemyGroup.add(helmet);
                // Helmet visor
                const visorGeo = new THREE.BoxGeometry(0.3, 0.08, 0.15);
                const visor = new THREE.Mesh(visorGeo, new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9 }));
                visor.position.set(0, 1.18, 0.18);
                enemyGroup.add(visor);
            } else if (type.name === 'Mage') {
                // Wizard hood
                const hoodGeo = new THREE.ConeGeometry(0.3, 0.4, 8);
                const hoodMat = new THREE.MeshStandardMaterial({ color: type.armorColor, roughness: 0.8 });
                const hood = new THREE.Mesh(hoodGeo, hoodMat);
                hood.position.y = 1.45;
                enemyGroup.add(hood);
            } else if (type.name === 'Assassin') {
                // Hood/mask
                const maskGeo = new THREE.SphereGeometry(0.26, 12, 10, 0, Math.PI * 2, 0, Math.PI * 0.7);
                const maskMat = new THREE.MeshStandardMaterial({ color: 0x1a0a1a, roughness: 0.9 });
                const mask = new THREE.Mesh(maskGeo, maskMat);
                mask.position.y = 1.22;
                enemyGroup.add(mask);
            } else if (type.name === 'Brute') {
                // Horns
                const hornGeo = new THREE.ConeGeometry(0.06, 0.2, 6);
                const hornMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 });
                const leftHorn = new THREE.Mesh(hornGeo, hornMat);
                leftHorn.position.set(-0.15, 1.35, 0);
                leftHorn.rotation.z = 0.4;
                enemyGroup.add(leftHorn);
                const rightHorn = new THREE.Mesh(hornGeo, hornMat);
                rightHorn.position.set(0.15, 1.35, 0);
                rightHorn.rotation.z = -0.4;
                enemyGroup.add(rightHorn);
            }

            // Eyes with glow effect
            const eyeGeo = new THREE.SphereGeometry(0.055, 10, 10);
            const eyeMat = new THREE.MeshStandardMaterial({
                color: type.eyeColor,
                emissive: type.eyeColor,
                emissiveIntensity: 0.8
            });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.09, 1.2, 0.19);
            enemyGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.09, 1.2, 0.19);
            enemyGroup.add(rightEye);

            // Eye pupils
            const pupilGeo = new THREE.SphereGeometry(0.025, 8, 8);
            const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.set(-0.09, 1.2, 0.24);
            enemyGroup.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
            rightPupil.position.set(0.09, 1.2, 0.24);
            enemyGroup.add(rightPupil);

            // Mouth with teeth
            const mouthGeo = new THREE.BoxGeometry(0.14, 0.05, 0.06);
            const mouthMat = new THREE.MeshStandardMaterial({ color: 0x220000 });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, 1.06, 0.19);
            enemyGroup.add(mouth);

            // Teeth
            for (let i = -2; i <= 2; i++) {
                const toothGeo = new THREE.BoxGeometry(0.02, 0.03, 0.02);
                const toothMat = new THREE.MeshStandardMaterial({ color: 0xffffee });
                const tooth = new THREE.Mesh(toothGeo, toothMat);
                tooth.position.set(i * 0.025, 1.045, 0.22);
                enemyGroup.add(tooth);
            }

            // Shoulder pads
            const shoulderGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const shoulderMat = new THREE.MeshStandardMaterial({
                color: type.bodyColor,
                metalness: type.name === 'Knight' ? 0.8 : 0.3,
                roughness: 0.4
            });
            const leftShoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
            leftShoulder.position.set(-0.42, 0.95, 0);
            leftShoulder.scale.set(1, 0.7, 0.8);
            enemyGroup.add(leftShoulder);

            const rightShoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
            rightShoulder.position.set(0.42, 0.95, 0);
            rightShoulder.scale.set(1, 0.7, 0.8);
            enemyGroup.add(rightShoulder);

            // Arms with better detail
            const upperArmGeo = new THREE.CylinderGeometry(0.07, 0.08, 0.3, 10);
            const armMat = new THREE.MeshStandardMaterial({ color: type.skinColor, roughness: 0.7 });

            const leftArm = new THREE.Group();
            const leftUpperArm = new THREE.Mesh(upperArmGeo, armMat);
            leftUpperArm.position.y = -0.15;
            leftArm.add(leftUpperArm);
            // Forearm with armor
            const forearmGeo = new THREE.CylinderGeometry(0.055, 0.07, 0.28, 8);
            const forearmMat = new THREE.MeshStandardMaterial({ color: type.armorColor, roughness: 0.5, metalness: 0.3 });
            const leftForearm = new THREE.Mesh(forearmGeo, forearmMat);
            leftForearm.position.y = -0.38;
            leftArm.add(leftForearm);
            // Hand
            const handGeo = new THREE.SphereGeometry(0.06, 8, 8);
            const leftHand = new THREE.Mesh(handGeo, armMat);
            leftHand.position.y = -0.52;
            leftArm.add(leftHand);
            leftArm.position.set(-0.42, 0.85, 0);
            leftArm.rotation.z = 0.2;
            enemyGroup.add(leftArm);

            const rightArm = new THREE.Group();
            const rightUpperArm = new THREE.Mesh(upperArmGeo, armMat);
            rightUpperArm.position.y = -0.15;
            rightArm.add(rightUpperArm);
            const rightForearm = new THREE.Mesh(forearmGeo, forearmMat);
            rightForearm.position.y = -0.38;
            rightArm.add(rightForearm);
            const rightHand = new THREE.Mesh(handGeo, armMat);
            rightHand.position.y = -0.52;
            rightArm.add(rightHand);
            rightArm.position.set(0.42, 0.85, 0);
            rightArm.rotation.z = -0.2;
            enemyGroup.add(rightArm);

            // Add weapon to right hand
            const weaponGroup = new THREE.Group();
            const weaponMat = new THREE.MeshStandardMaterial({ color: type.weaponColor, metalness: 0.9, roughness: 0.2 });

            if (type.weapon === 'sword') {
                // Detailed sword
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.55, 0.02), weaponMat);
                blade.position.y = -0.32;
                weaponGroup.add(blade);
                // Sword edge highlight
                const edgeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1, roughness: 0.1 });
                const edge = new THREE.Mesh(new THREE.BoxGeometry(0.052, 0.55, 0.005), edgeMat);
                edge.position.set(0, -0.32, 0.01);
                weaponGroup.add(edge);
                // Guard
                const guard = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.03, 0.04),
                    new THREE.MeshStandardMaterial({ color: 0xDAA520, metalness: 0.8 }));
                guard.position.y = -0.02;
                weaponGroup.add(guard);
                // Handle
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.14, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.9 }));
                handle.position.y = 0.05;
                weaponGroup.add(handle);
                // Pommel
                const pommel = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0xDAA520, metalness: 0.8 }));
                pommel.position.y = 0.14;
                weaponGroup.add(pommel);
            } else if (type.weapon === 'axe') {
                // Detailed axe
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.035, 0.7, 8),
                    new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 }));
                handle.position.y = -0.4;
                weaponGroup.add(handle);
                // Axe head - curved
                const axeHeadShape = new THREE.Shape();
                axeHeadShape.moveTo(0, 0);
                axeHeadShape.quadraticCurveTo(0.2, 0.1, 0.18, 0.2);
                axeHeadShape.lineTo(0.05, 0.2);
                axeHeadShape.lineTo(0.05, -0.2);
                axeHeadShape.lineTo(0.18, -0.2);
                axeHeadShape.quadraticCurveTo(0.2, -0.1, 0, 0);
                const axeHeadGeo = new THREE.ExtrudeGeometry(axeHeadShape, { depth: 0.03, bevelEnabled: false });
                const axeHead = new THREE.Mesh(axeHeadGeo, weaponMat);
                axeHead.position.set(-0.02, -0.65, -0.015);
                axeHead.rotation.z = Math.PI;
                weaponGroup.add(axeHead);
            } else if (type.weapon === 'dagger') {
                // Sleek dagger
                const blade = new THREE.Mesh(new THREE.ConeGeometry(0.03, 0.3, 4), weaponMat);
                blade.position.y = -0.2;
                blade.rotation.z = Math.PI;
                weaponGroup.add(blade);
                const guard = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.03),
                    new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.7 }));
                guard.position.y = -0.03;
                weaponGroup.add(guard);
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.022, 0.1, 6),
                    new THREE.MeshStandardMaterial({ color: 0x1a0a1a }));
                handle.position.y = 0.03;
                weaponGroup.add(handle);
            } else if (type.weapon === 'staff') {
                // Magical staff
                const staff = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.035, 1.1, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.7 }));
                staff.position.y = -0.6;
                weaponGroup.add(staff);
                // Staff rings
                for (let i = 0; i < 3; i++) {
                    const ring = new THREE.Mesh(new THREE.TorusGeometry(0.04, 0.008, 8, 16),
                        new THREE.MeshStandardMaterial({ color: 0xDAA520, metalness: 0.9 }));
                    ring.position.y = -0.2 - i * 0.25;
                    ring.rotation.x = Math.PI / 2;
                    weaponGroup.add(ring);
                }
                // Crystal orb
                const orb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16),
                    new THREE.MeshStandardMaterial({
                        color: type.weaponColor,
                        emissive: type.weaponColor,
                        emissiveIntensity: 0.7,
                        transparent: true,
                        opacity: 0.9
                    }));
                orb.position.y = -1.15;
                weaponGroup.add(orb);
                // Orb glow
                const glow = new THREE.Mesh(new THREE.SphereGeometry(0.13, 12, 12),
                    new THREE.MeshBasicMaterial({
                        color: type.weaponColor,
                        transparent: true,
                        opacity: 0.3
                    }));
                glow.position.y = -1.15;
                weaponGroup.add(glow);
            } else if (type.weapon === 'hammer') {
                // War hammer
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.04, 0.6, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.7 }));
                handle.position.y = -0.35;
                weaponGroup.add(handle);
                // Leather grip
                const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.042, 0.042, 0.2, 8),
                    new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.9 }));
                grip.position.y = -0.1;
                weaponGroup.add(grip);
                // Hammer head
                const hammerHead = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.15, 0.18), weaponMat);
                hammerHead.position.y = -0.65;
                weaponGroup.add(hammerHead);
                // Metal bands
                const bandMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.9 });
                const band1 = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.02, 0.2), bandMat);
                band1.position.y = -0.58;
                weaponGroup.add(band1);
                const band2 = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.02, 0.2), bandMat);
                band2.position.y = -0.72;
                weaponGroup.add(band2);
            }

            weaponGroup.position.set(0.42, 0.32, 0.18);
            weaponGroup.rotation.x = -0.6;
            enemyGroup.add(weaponGroup);

            // Legs with boots
            const thighGeo = new THREE.CylinderGeometry(0.09, 0.1, 0.3, 10);
            const legMat = new THREE.MeshStandardMaterial({ color: type.armorColor, roughness: 0.6 });
            const bootMat = new THREE.MeshStandardMaterial({ color: type.bodyColor, roughness: 0.5, metalness: 0.2 });

            const leftLeg = new THREE.Group();
            const leftThigh = new THREE.Mesh(thighGeo, legMat);
            leftThigh.position.y = -0.15;
            leftLeg.add(leftThigh);
            const leftShin = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.08, 0.28, 8), legMat);
            leftShin.position.y = -0.38;
            leftLeg.add(leftShin);
            const leftBoot = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.18), bootMat);
            leftBoot.position.set(0, -0.52, 0.03);
            leftLeg.add(leftBoot);
            leftLeg.position.set(-0.14, 0.22, 0);
            enemyGroup.add(leftLeg);

            const rightLeg = new THREE.Group();
            const rightThigh = new THREE.Mesh(thighGeo, legMat);
            rightThigh.position.y = -0.15;
            rightLeg.add(rightThigh);
            const rightShin = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.08, 0.28, 8), legMat);
            rightShin.position.y = -0.38;
            rightLeg.add(rightShin);
            const rightBoot = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.18), bootMat);
            rightBoot.position.set(0, -0.52, 0.03);
            rightLeg.add(rightBoot);
            rightLeg.position.set(0.14, 0.22, 0);
            enemyGroup.add(rightLeg);

            // Add cape for certain enemy types
            if (type.hasCape) {
                const capeGroup = new THREE.Group();
                // Cape main body - flowing cloth
                const capeGeo = new THREE.PlaneGeometry(0.7, 0.9, 4, 6);
                const capeMat = new THREE.MeshStandardMaterial({
                    color: type.name === 'Knight' ? 0x8B0000 : type.armorColor,
                    roughness: 0.9,
                    side: THREE.DoubleSide
                });
                const cape = new THREE.Mesh(capeGeo, capeMat);
                cape.position.set(0, 0.5, -0.35);
                cape.rotation.x = 0.2;
                capeGroup.add(cape);
                // Cape collar
                const collarGeo = new THREE.TorusGeometry(0.32, 0.04, 8, 16, Math.PI);
                const collarMat = new THREE.MeshStandardMaterial({ color: type.accentColor, metalness: 0.6 });
                const collar = new THREE.Mesh(collarGeo, collarMat);
                collar.position.set(0, 1.0, -0.15);
                collar.rotation.x = Math.PI / 2;
                collar.rotation.z = Math.PI;
                capeGroup.add(collar);
                enemyGroup.add(capeGroup);
            }

            // Add glowing aura for certain enemy types
            if (type.hasAura && type.glowColor) {
                const auraGeo = new THREE.SphereGeometry(0.8, 12, 12);
                const auraMat = new THREE.MeshBasicMaterial({
                    color: type.glowColor,
                    transparent: true,
                    opacity: 0.15
                });
                const aura = new THREE.Mesh(auraGeo, auraMat);
                aura.position.y = 0.7;
                enemyGroup.add(aura);
                // Inner aura glow
                const innerAuraGeo = new THREE.SphereGeometry(0.5, 10, 10);
                const innerAuraMat = new THREE.MeshBasicMaterial({
                    color: type.glowColor,
                    transparent: true,
                    opacity: 0.25
                });
                const innerAura = new THREE.Mesh(innerAuraGeo, innerAuraMat);
                innerAura.position.y = 0.7;
                enemyGroup.add(innerAura);
            }

            // Add battle scars/markings
            for (let s = 0; s < type.scarCount; s++) {
                const scarGeo = new THREE.BoxGeometry(0.02, 0.12 + Math.random() * 0.08, 0.01);
                const scarMat = new THREE.MeshStandardMaterial({ color: 0x330000 });
                const scar = new THREE.Mesh(scarGeo, scarMat);
                // Random position on face/body
                if (s === 0) {
                    scar.position.set(-0.05 + Math.random() * 0.1, 1.15, 0.23);
                    scar.rotation.z = -0.3 + Math.random() * 0.6;
                } else {
                    scar.position.set((Math.random() - 0.5) * 0.3, 0.5 + Math.random() * 0.4, 0.25);
                    scar.rotation.z = -0.5 + Math.random();
                }
                enemyGroup.add(scar);
            }

            // Add armor rivets/details for Knight
            if (type.name === 'Knight') {
                const rivetMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9 });
                for (let r = 0; r < 6; r++) {
                    const rivet = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), rivetMat);
                    rivet.position.set(
                        -0.18 + (r % 3) * 0.18,
                        0.55 + Math.floor(r / 3) * 0.2,
                        0.22
                    );
                    enemyGroup.add(rivet);
                }
            }

            // Add magical runes for Mage
            if (type.name === 'Mage') {
                const runeMat = new THREE.MeshBasicMaterial({
                    color: type.weaponColor,
                    transparent: true,
                    opacity: 0.8
                });
                // Floating rune circles
                for (let r = 0; r < 3; r++) {
                    const runeRing = new THREE.Mesh(new THREE.TorusGeometry(0.08 + r * 0.03, 0.008, 8, 16), runeMat);
                    runeRing.position.set((r - 1) * 0.25, 0.6 + Math.sin(r) * 0.1, 0.35);
                    runeRing.rotation.x = Math.PI / 2 + Math.random() * 0.3;
                    enemyGroup.add(runeRing);
                }
            }

            // Add spikes for Brute
            if (type.name === 'Brute') {
                const spikeMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8 });
                // Shoulder spikes
                for (let sp = 0; sp < 4; sp++) {
                    const spike = new THREE.Mesh(new THREE.ConeGeometry(0.03, 0.12, 6), spikeMat);
                    const side = sp < 2 ? -1 : 1;
                    spike.position.set(side * 0.48, 0.95 + (sp % 2) * 0.08, (sp % 2) * 0.05);
                    spike.rotation.z = side * 0.8;
                    enemyGroup.add(spike);
                }
                // Back spikes
                for (let bs = 0; bs < 3; bs++) {
                    const backSpike = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.15, 6), spikeMat);
                    backSpike.position.set((bs - 1) * 0.15, 0.8 + bs * 0.05, -0.3);
                    backSpike.rotation.x = 0.5;
                    enemyGroup.add(backSpike);
                }
            }

            // Add smoke/shadow effect for Assassin
            if (type.name === 'Assassin') {
                const smokeMat = new THREE.MeshBasicMaterial({
                    color: 0x1a0a2a,
                    transparent: true,
                    opacity: 0.3
                });
                for (let sm = 0; sm < 5; sm++) {
                    const smoke = new THREE.Mesh(new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 8, 8), smokeMat);
                    smoke.position.set(
                        (Math.random() - 0.5) * 0.6,
                        Math.random() * 0.5,
                        (Math.random() - 0.5) * 0.6
                    );
                    enemyGroup.add(smoke);
                }
            }

            // Apply type-specific scale
            enemyGroup.scale.setScalar(type.scale);

            enemyGroup.position.set(x, terrain.y + 0.4, z);
            enemyGroup.rotation.x = terrain.rotX * 0.5;
            enemyGroup.rotation.z = terrain.rotZ * 0.5;
            scene.add(enemyGroup);

            const baseHealth = 30 * (1 + currentWave * 0.08);
            const baseDamage = 10 + currentWave * 1.5;
            const baseSpeed = 0.004 + currentWave * 0.0003;

            enemies.push({
                mesh: enemyGroup,
                type: type.name,
                health: baseHealth * type.health,
                maxHealth: baseHealth * type.health,
                damage: baseDamage * type.damage,
                speed: baseSpeed * type.speed,
                attackCooldown: 0,
                radius: 0.5,
                leftArm: leftArm,
                rightArm: rightArm,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                animTime: Math.random() * Math.PI * 2
            });
        }
        
        function spawnBoss() {
            // Try to find a valid spawn position (not inside buildings)
            let x, z, attempts = 0;
            do {
                const angle = Math.random() * Math.PI * 2;
                x = playerState.position.x + Math.cos(angle) * 28;
                z = playerState.position.z + Math.sin(angle) * 28;
                attempts++;
            } while (isInsideBuilding(x, z, 3) && attempts < 10);

            const terrain = getTerrainDataForEnemy(x, z);
            
            // Create boss group
            const bossGroup = new THREE.Group();
            
            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.7, 0.9, 1.8, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x440000, emissive: 0x220000, emissiveIntensity: 0.2, roughness: 0.6 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.2;
            body.castShadow = true;
            bossGroup.add(body);
            
            // Head
            const headGeo = new THREE.SphereGeometry(0.5, 14, 12);
            const headMat = new THREE.MeshStandardMaterial({ color: 0x660000, roughness: 0.5 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.4;
            head.castShadow = true;
            bossGroup.add(head);
            
            // Glowing eyes
            const eyeGeo = new THREE.SphereGeometry(0.1, 10, 10);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 });
            
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.18, 2.5, 0.4);
            bossGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.18, 2.5, 0.4);
            bossGroup.add(rightEye);
            
            // Mouth/teeth
            const mouthGeo = new THREE.BoxGeometry(0.3, 0.1, 0.1);
            const mouthMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, 2.25, 0.45);
            bossGroup.add(mouth);
            
            // Horns
            const hornGeo = new THREE.ConeGeometry(0.1, 0.5, 8);
            const hornMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4 });
            
            const leftHorn = new THREE.Mesh(hornGeo, hornMat);
            leftHorn.position.set(-0.35, 2.8, 0);
            leftHorn.rotation.z = 0.4;
            bossGroup.add(leftHorn);
            
            const rightHorn = new THREE.Mesh(hornGeo, hornMat);
            rightHorn.position.set(0.35, 2.8, 0);
            rightHorn.rotation.z = -0.4;
            bossGroup.add(rightHorn);
            
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.15, 0.2, 1.2, 10);
            const armMat = new THREE.MeshStandardMaterial({ color: 0x550000, roughness: 0.6 });
            
            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(-0.95, 1.4, 0);
            leftArm.rotation.z = 0.4;
            bossGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(0.95, 1.4, 0);
            rightArm.rotation.z = -0.4;
            bossGroup.add(rightArm);
            
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.9, 10);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x330000, roughness: 0.7 });
            
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.3, 0.45, 0);
            bossGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.3, 0.45, 0);
            bossGroup.add(rightLeg);
            
            bossGroup.position.set(x, terrain.y + 0.45, z);
            bossGroup.rotation.x = terrain.rotX * 0.5;
            bossGroup.rotation.z = terrain.rotZ * 0.5;
            scene.add(bossGroup);
            
            boss = {
                mesh: bossGroup,
                health: 180 + currentWave * 25,
                maxHealth: 180 + currentWave * 25,
                damage: 20 + currentWave * 3,
                speed: 0.004,
                attackCooldown: 0,
                leftArm: leftArm,
                rightArm: rightArm,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                animTime: 0
            };
            
            document.getElementById('bossHealth').style.display = 'block';
            document.getElementById('bossName').textContent = 'BOSS - Wave ' + currentWave;
            announceWave('‚ö†Ô∏è BOSS');
        }
        
        function damageEnemy(enemy, damage, isCrit) {
            if (enemy.dying) return; // Don't damage dying enemies
            enemy.health -= damage;
            if (settings.showDamageNumbers) showDamageNumber(enemy.mesh.position, damage, isCrit);

            // Flash all meshes in the enemy group white
            enemy.mesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.emissive = new THREE.Color(0xffffff);
                    child.material.emissiveIntensity = 1;
                    setTimeout(() => {
                        if (child.material) child.material.emissiveIntensity = 0;
                    }, 80);
                }
            });

            if (enemy.health <= 0) killEnemy(enemy);
        }
        
        function damageBoss(damage, isCrit) {
            boss.health -= damage;
            if (settings.showDamageNumbers) showDamageNumber(boss.mesh.position, damage, isCrit);
            document.getElementById('bossFill').style.width = (boss.health / boss.maxHealth * 100) + '%';
            if (boss.health <= 0) killBoss();
        }
        
        function showDamageNumber(pos, damage, isCrit) {
            const sp = pos.clone().project(camera);
            const x = (sp.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-sp.y * 0.5 + 0.5) * window.innerHeight;
            
            const div = document.createElement('div');
            div.className = 'damage-number';
            div.textContent = Math.round(damage);
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.style.color = isCrit ? '#ffff00' : '#ffffff';
            div.style.fontSize = isCrit ? '20px' : '14px';
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }
        
        function killEnemy(enemy) {
            if (enemy.dying) return;
            enemy.dying = true;

            // Death particles
            const deathPos = enemy.mesh.position.clone();
            deathPos.y += 0.7;
            createDeathParticles(deathPos, 0x880000);

            spawnCoin(enemy.mesh.position.clone());

            playerState.score += 100;
            playerState.kills++;
            playerState.health = Math.min(playerState.maxHealth, playerState.health + 2);
            playerState.energy = Math.min(playerState.maxEnergy, playerState.energy + 5);
            updateHUD();

            // Death animation: fall over and fade out
            const startY = enemy.mesh.position.y;
            const startRotation = enemy.mesh.rotation.x;
            let deathTime = 0;
            const deathDuration = 600;

            function animateDeath() {
                deathTime += 16;
                const progress = Math.min(deathTime / deathDuration, 1);

                // Fall backwards
                enemy.mesh.rotation.x = startRotation + progress * (Math.PI / 2);
                enemy.mesh.position.y = startY - progress * 0.5;

                // Fade out all materials
                enemy.mesh.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.transparent = true;
                        child.material.opacity = 1 - progress;
                    }
                });

                if (progress < 1) {
                    requestAnimationFrame(animateDeath);
                } else {
                    // Remove enemy after animation
                    scene.remove(enemy.mesh);
                    const idx = enemies.indexOf(enemy);
                    if (idx > -1) enemies.splice(idx, 1);
                    checkWaveComplete();
                }
            }

            animateDeath();
        }
        
        function killBoss() {
            // Massive death explosion for boss
            const bossPos = boss.mesh.position.clone();
            bossPos.y += 1.2;
            createExplosionParticles(bossPos, 0xff0000, 0xff6600);
            createDeathParticles(bossPos, 0x660000);
            createMagicParticles(bossPos, 0xffff00, 20, 0.1);
            // Extra explosions around boss
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const offsetPos = bossPos.clone();
                    offsetPos.x += (Math.random() - 0.5) * 2;
                    offsetPos.y += (Math.random() - 0.5) * 1;
                    offsetPos.z += (Math.random() - 0.5) * 2;
                    createExplosionParticles(offsetPos, 0xff4400, 0xffaa00);
                }, i * 150);
            }

            for (let i = 0; i < 6; i++) {
                const pos = boss.mesh.position.clone();
                pos.x += (Math.random() - 0.5) * 3;
                pos.z += (Math.random() - 0.5) * 3;
                spawnCoin(pos);
            }

            scene.remove(boss.mesh);
            playerState.score += 1000;
            playerState.health = playerState.maxHealth;
            playerState.energy = playerState.maxEnergy;

            boss = null;
            document.getElementById('bossHealth').style.display = 'none';
            announceWave('BOSS DEFEATED!');
            updateHUD();

            setTimeout(() => { currentWave++; startWave(); }, 3000);
        }
        
        function spawnCoin(position) {
            const geo = new THREE.CylinderGeometry(0.2, 0.2, 0.06, 16);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.1 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(position);
            const terrainY = getTerrainHeight(position.x, position.z);
            mesh.position.y = terrainY + 0.5;
            mesh.rotation.x = Math.PI / 2;
            scene.add(mesh);
            
            coins.push({ mesh, value: 5 + Math.floor(currentWave / 2), bobOffset: Math.random() * Math.PI * 2, baseY: terrainY + 0.5 });
        }
        
        function damagePlayer(damage) {
            const finalDamage = Math.max(1, damage - playerState.defense);
            playerState.health -= finalDamage;
            
            const v = document.createElement('div');
            v.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle,transparent 40%,rgba(255,0,0,0.25) 100%);pointer-events:none;z-index:150;';
            document.body.appendChild(v);
            setTimeout(() => v.remove(), 150);
            
            if (playerState.health <= 0) gameOver();
            updateHUD();
        }
        
        function announceWave(text) {
            const el = document.getElementById('waveAnnounce');
            el.textContent = text;
            el.style.opacity = '1';
            setTimeout(() => el.style.opacity = '0', 2000);
        }
        
        function startWave() {
            waveInProgress = true;
            announceWave('WAVE ' + currentWave);
            
            const count = 3 + currentWave * 2;
            let spawned = 0;
            const interval = setInterval(() => {
                if (spawned >= count) {
                    clearInterval(interval);
                    if (currentWave % 5 === 0) setTimeout(spawnBoss, 2000);
                    return;
                }
                spawnEnemy();
                spawned++;
            }, 800);
        }
        
        function checkWaveComplete() {
            if (enemies.length === 0 && !boss && waveInProgress) {
                waveInProgress = false;
                playerState.score += currentWave * 50;
                playerState.health = Math.min(playerState.maxHealth, playerState.health + 10);
                announceWave('WAVE COMPLETE!');
                setTimeout(() => { currentWave++; startWave(); }, 3000);
            }
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalWave').textContent = currentWave;
            document.getElementById('finalScore').textContent = playerState.score;
            document.getElementById('finalCoins').textContent = inventory.coins;
            document.getElementById('gameOver').style.display = 'flex';
            document.getElementById('clickToPlay').style.display = 'none';
            // Release pointer lock so user can click buttons
            if (document.exitPointerLock) document.exitPointerLock();
            saveCoinsToCloud(); // Save coins when game ends
        }
        
        // Get terrain height at any position
        function updatePlayer(dt) {
            // VERY SLOW speeds
            const baseSpeed = 0.015 + (settings.walkSpeed - 50) * 0.0003;
            const baseSprint = 0.025 + (settings.sprintSpeed - 50) * 0.0005;
            
            const isSprint = keys['ShiftLeft'];
            const speed = isSprint ? baseSprint : baseSpeed;
            
            let mx = 0, mz = 0;
            
            if (deviceMode === 'mobile') {
                // joystickX = strafe (left/right), joystickY = forward/back
                mx = joystickX;
                mz = joystickY;
            } else {
                if (keys['KeyW']) mz = -1;  // Forward
                if (keys['KeyS']) mz = 1; // Backward
                if (keys['KeyA']) mx = -1; // Strafe left
                if (keys['KeyD']) mx = 1;  // Strafe right
                if (mx !== 0 && mz !== 0) {
                    const len = Math.sqrt(mx * mx + mz * mz);
                    mx /= len;
                    mz /= len;
                }
            }
            
            // Calculate world movement based on camera direction
            // Forward (positive mz) moves in camera's look direction
            const sin = Math.sin(playerState.rotation.y);
            const cos = Math.cos(playerState.rotation.y);

            // Standard FPS movement relative to camera direction
            // W = forward (where you're looking), S = backward, A = strafe left, D = strafe right
            const worldMoveX = mx * cos + mz * sin;
            const worldMoveZ = mz * cos - mx * sin;
            
            const moveAmount = speed * dt;
            const newX = playerState.position.x + worldMoveX * moveAmount;
            const newZ = playerState.position.z + worldMoveZ * moveAmount;
            
            if (!checkCollision(newX, newZ)) {
                playerState.position.x = newX;
                playerState.position.z = newZ;
            } else {
                if (!checkCollision(newX, playerState.position.z)) playerState.position.x = newX;
                else if (!checkCollision(playerState.position.x, newZ)) playerState.position.z = newZ;
            }
            
            playerState.position.x = Math.max(-120, Math.min(120, playerState.position.x));
            playerState.position.z = Math.max(-120, Math.min(120, playerState.position.z));
            
            // Gravity and terrain following
            const terrainY = getTerrainHeight(playerState.position.x, playerState.position.z);
            const groundY = terrainY + 1.7;
            
            playerState.velocity.y -= 0.004;
            playerState.position.y += playerState.velocity.y;
            
            if (playerState.position.y <= groundY) {
                playerState.position.y = groundY;
                playerState.velocity.y = 0;
                playerState.isGrounded = true;
            }
            
            if (deviceMode === 'computer' && keys['Space']) { jump(); keys['Space'] = false; }
            
            camera.position.copy(playerState.position);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = playerState.rotation.y;
            camera.rotation.x = playerState.rotation.x;
            
            if (player) player.position.copy(playerState.position);
            
            // Update sword position and animation
            if (swordMesh) {
                if (swordSwinging) {
                    swordSwingTime += dt;
                    
                    // Sword swing animation (300ms total)
                    const swingDuration = 300;
                    const progress = Math.min(swordSwingTime / swingDuration, 1);
                    
                    // Swing arc from right to left
                    const swingAngle = Math.sin(progress * Math.PI) * 1.5;
                    
                    // Position sword in front of camera
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    
                    const right = new THREE.Vector3();
                    right.crossVectors(camera.up, dir).normalize();
                    
                    // Start position (right side)
                    const startOffset = 0.4 - progress * 0.6;
                    
                    swordMesh.position.copy(camera.position);
                    swordMesh.position.add(dir.clone().multiplyScalar(0.5));
                    swordMesh.position.add(right.clone().multiplyScalar(startOffset));
                    swordMesh.position.y -= 0.3;
                    
                    // Rotate sword during swing
                    swordMesh.rotation.set(
                        camera.rotation.x - 0.5 + swingAngle * 0.3,
                        camera.rotation.y + swingAngle,
                        -0.3 + swingAngle * 0.5
                    );
                    
                    if (progress >= 1) {
                        swordSwinging = false;
                        swordMesh.visible = false;
                    }
                }
            }
        }
        
        function updateEnemies(dt) {
            enemies.forEach((e, idx) => {
                if (!e.mesh || e.dying) return;
                
                const toPlayer = playerState.position.clone().sub(e.mesh.position);
                toPlayer.y = 0;
                const dist = toPlayer.length();
                toPlayer.normalize();
                
                e.mesh.lookAt(new THREE.Vector3(playerState.position.x, e.mesh.position.y, playerState.position.z));
                
                let isMoving = false;
                
                if (dist > 1.3) {
                    // Calculate new position
                    let newX = e.mesh.position.x + toPlayer.x * e.speed * dt;
                    let newZ = e.mesh.position.z + toPlayer.z * e.speed * dt;
                    
                    // Check collision with other enemies
                    let canMove = true;
                    enemies.forEach((other, otherIdx) => {
                        if (idx === otherIdx || !other.mesh) return;
                        
                        const dx = newX - other.mesh.position.x;
                        const dz = newZ - other.mesh.position.z;
                        const distToOther = Math.sqrt(dx * dx + dz * dz);
                        
                        // If too close to another enemy, push apart
                        if (distToOther < 1.0) {
                            canMove = false;
                            // Push away from the other enemy
                            if (distToOther > 0.1) {
                                const pushX = (dx / distToOther) * 0.02;
                                const pushZ = (dz / distToOther) * 0.02;
                                e.mesh.position.x += pushX;
                                e.mesh.position.z += pushZ;
                            }
                        }
                    });
                    
                    if (canMove) {
                        e.mesh.position.x = newX;
                        e.mesh.position.z = newZ;
                        isMoving = true;
                    }
                }
                
                // Update position and rotation to match terrain slope
                const terrain = getTerrainDataForEnemy(e.mesh.position.x, e.mesh.position.z);
                e.mesh.position.y = terrain.y + 0.4;
                e.mesh.rotation.x = terrain.rotX * 0.5;
                e.mesh.rotation.z = terrain.rotZ * 0.5;
                
                // Animate arms and legs while moving
                if (isMoving && e.leftArm && e.rightArm && e.leftLeg && e.rightLeg) {
                    e.animTime += dt * 0.012;
                    const swing = Math.sin(e.animTime) * 0.6;
                    
                    // Arms swing opposite to legs
                    e.leftArm.rotation.x = swing;
                    e.rightArm.rotation.x = -swing;
                    
                    // Legs swing
                    e.leftLeg.rotation.x = -swing * 0.8;
                    e.rightLeg.rotation.x = swing * 0.8;
                } else if (e.leftArm && e.rightArm && e.leftLeg && e.rightLeg) {
                    // Reset to idle pose
                    e.leftArm.rotation.x *= 0.9;
                    e.rightArm.rotation.x *= 0.9;
                    e.leftLeg.rotation.x *= 0.9;
                    e.rightLeg.rotation.x *= 0.9;
                }
                
                if (dist < 1.8 && e.attackCooldown <= 0) {
                    damagePlayer(e.damage);
                    e.attackCooldown = 1500;
                }
                
                e.attackCooldown -= dt;
            });
        }
        
        function updateBoss(dt) {
            if (!boss || !boss.mesh) return;
            
            const toPlayer = playerState.position.clone().sub(boss.mesh.position);
            toPlayer.y = 0;
            const dist = toPlayer.length();
            toPlayer.normalize();
            
            boss.mesh.lookAt(new THREE.Vector3(playerState.position.x, boss.mesh.position.y, playerState.position.z));
            
            let isMoving = false;
            
            if (dist > 2) {
                boss.mesh.position.x += toPlayer.x * boss.speed * dt;
                boss.mesh.position.z += toPlayer.z * boss.speed * dt;
                isMoving = true;
            }
            
            // Update position and rotation to match terrain slope
            const terrain = getTerrainDataForEnemy(boss.mesh.position.x, boss.mesh.position.z);
            boss.mesh.position.y = terrain.y + 0.45;
            boss.mesh.rotation.x = terrain.rotX * 0.5;
            boss.mesh.rotation.z = terrain.rotZ * 0.5;
            
            // Animate arms and legs
            if (isMoving && boss.leftArm && boss.rightArm && boss.leftLeg && boss.rightLeg) {
                boss.animTime += dt * 0.008;
                const swing = Math.sin(boss.animTime) * 0.5;
                
                boss.leftArm.rotation.x = swing;
                boss.rightArm.rotation.x = -swing;
                boss.leftLeg.rotation.x = -swing * 0.7;
                boss.rightLeg.rotation.x = swing * 0.7;
            }
            
            if (dist < 3 && boss.attackCooldown <= 0) {
                damagePlayer(boss.damage);
                boss.attackCooldown = 2000;
            }
            
            boss.attackCooldown -= dt;
        }
        
        function updateProjectiles(dt) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.mesh.position.add(p.direction.clone().multiplyScalar(p.speed * dt / 16));
                p.life -= dt;

                // Create particle trail
                p.trailTimer = (p.trailTimer || 0) + dt;
                if (p.trailTimer > 30 && p.color) {
                    p.trailTimer = 0;
                    createProjectileTrail(p.mesh.position.clone(), p.color);
                }

                let hitSomething = false;

                enemies.forEach(e => {
                    if (!e.mesh || hitSomething) return;
                    if (p.mesh.position.distanceTo(e.mesh.position) < 0.9) {
                        damageEnemy(e, p.damage, false);
                        // Explosion particles on impact
                        const impactPos = p.mesh.position.clone();
                        impactPos.y += 0.5;
                        createExplosionParticles(impactPos, p.color || 0xff4400, 0xffaa00);
                        p.life = 0;
                        hitSomething = true;
                    }
                });

                if (boss && boss.mesh && p.mesh.position.distanceTo(boss.mesh.position) < 1.4) {
                    damageBoss(p.damage, false);
                    // Big explosion on boss
                    const impactPos = p.mesh.position.clone();
                    createExplosionParticles(impactPos, p.color || 0xff0000, 0xff6600);
                    p.life = 0;
                    hitSomething = true;
                }

                if (p.life <= 0) {
                    // Fizzle particles if it didn't hit anything
                    if (!hitSomething) {
                        createParticles(p.mesh.position.clone(), p.color || 0xaaaaaa, 5, 0.02, 0.04, 200, 0.5);
                    }
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }
        }
        
        function updateCoins(dt) {
            const collectRange = settings.autoCollectCoins ? 2.5 : 1;
            
            for (let i = coins.length - 1; i >= 0; i--) {
                const c = coins[i];
                
                c.mesh.rotation.z += 0.02;
                const baseY = c.baseY || 0.5;
                c.mesh.position.y = baseY + Math.sin(Date.now() * 0.003 + c.bobOffset) * 0.08;
                
                const dx = c.mesh.position.x - playerState.position.x;
                const dz = c.mesh.position.z - playerState.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist < collectRange) {
                    inventory.coins += c.value;
                    
                    const div = document.createElement('div');
                    div.className = 'coin-pickup';
                    div.textContent = '+' + c.value + ' üí∞';
                    div.style.left = '50%';
                    div.style.top = '35%';
                    document.body.appendChild(div);
                    setTimeout(() => div.remove(), 1000);
                    
                    scene.remove(c.mesh);
                    coins.splice(i, 1);
                    updateHUD();
                }
            }
        }
        
        function updateCooldowns(dt) {
            for (const id in itemCooldowns) {
                if (itemCooldowns[id] > 0) itemCooldowns[id] -= dt;
            }
            
            if (playerState.energy < playerState.maxEnergy) {
                playerState.energy = Math.min(playerState.maxEnergy, playerState.energy + dt * 0.002);
            }
        }
        
        let lastTime = 0;
        let lastSaveTime = 0;
        function gameLoop(timestamp) {
            requestAnimationFrame(gameLoop);

            const dt = Math.min(timestamp - lastTime, 50);
            lastTime = timestamp;

            if (!gameRunning) {
                return;
            }

            updatePlayer(dt);

            // In multiplayer, update remote players and sync position
            if (isMultiplayer) {
                updateRemotePlayers(dt);
                syncPositionToServer();
            } else {
                // Solo mode - update AI enemies and boss
                updateEnemies(dt);
                updateBoss(dt);
            }

            updateProjectiles(dt);
            updateCoins(dt);
            updateCooldowns(dt);
            updateParticles(dt);
            updateHUD();
            updateMinimap();

            // Auto-save coins every 15 seconds
            if (timestamp - lastSaveTime > 15000) {
                lastSaveTime = timestamp;
                saveCoinsToCloud();
            }

            renderScene();
        }

        function renderScene() {
            if (composer && settings.hyperRealisticGraphics !== false) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // ========== MULTIPLAYER FUNCTIONS ==========

        async function joinMultiplayer() {
            const nameInput = document.getElementById('playerNameInput');
            const nameWarning = document.getElementById('nameWarning');

            if (isAuthenticated && authenticatedUsername) {
                // Authenticated users always use their account username
                playerName = authenticatedUsername;
                nameInput.value = playerName;
                nameInput.disabled = true;
                nameWarning.style.display = 'none';
            } else {
                nameInput.disabled = false;
                // Guest flow: process player name from input
                let rawName = (nameInput.value || '').trim();

                // Sanitize HTML special characters
                rawName = rawName.replace(/[<>&"']/g, '');

                if (rawName.length > 0) {
                    try {
                        const filterResponse = await fetch('/api/filter-chat', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: rawName })
                        });
                        const filterData = await filterResponse.json();
                        if (filterData.wasCensored) {
                            nameWarning.textContent = 'Name contained inappropriate content and was modified.';
                            nameWarning.style.display = 'block';
                            playerName = filterData.filtered;
                        } else {
                            playerName = filterData.filtered;
                            nameWarning.style.display = 'none';
                        }
                    } catch (_e) {
                        playerName = rawName;
                        nameWarning.style.display = 'none';
                    }
                } else {
                    playerName = 'Guest_' + Math.random().toString(36).substr(2, 4);
                    nameWarning.style.display = 'none';
                }

                nameInput.value = playerName;
            }

            document.getElementById('menu').style.display = 'none';
            document.getElementById('multiplayerLobby').style.display = 'flex';
            document.getElementById('retryConnectionBtn').style.display = 'none';
            document.getElementById('connectionSpinner').style.display = 'block';
            connectionAttempts = 0;
            attemptConnection();
        }

        function scheduleRetry(detailsEl, reason) {
            if (isRetrying) return;
            if (connectionAttempts >= MAX_RECONNECT_ATTEMPTS) {
                handleConnectionFailure('Maximum retry attempts reached.');
                return;
            }
            isRetrying = true;
            const delay = INITIAL_RECONNECT_DELAY * Math.pow(2, connectionAttempts - 1);
            if (detailsEl) detailsEl.textContent = `${reason} Retrying in ${delay / 1000}s...`;
            reconnectTimeout = setTimeout(() => {
                isRetrying = false;
                attemptConnection();
            }, delay);
        }

        function cleanupSocket() {
            if (multiplayerSocket) {
                multiplayerSocket.onopen = null;
                multiplayerSocket.onmessage = null;
                multiplayerSocket.onerror = null;
                multiplayerSocket.onclose = null;
                try { multiplayerSocket.close(); } catch (_e) { /* ignore */ }
                multiplayerSocket = null;
            }
        }

        function attemptConnection(url) {
            const wsUrl = url || 'wss://game.hadijaffri.partykit.dev/parties/game/arena-main';
            connectionAttempts++;
            isRetrying = false;
            const statusEl = document.getElementById('lobbyStatus');
            const detailsEl = document.getElementById('connectionDetails');

            if (connectionAttempts > MAX_RECONNECT_ATTEMPTS) {
                handleConnectionFailure('Maximum retry attempts reached.');
                return;
            }

            statusEl.textContent = `Connecting to server... (Attempt ${connectionAttempts}/${MAX_RECONNECT_ATTEMPTS})`;
            detailsEl.textContent = '';

            // Clear any existing timeouts
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
                connectionTimeout = null;
            }
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            // Clean up any previous socket
            cleanupSocket();

            // Pre-flight check - detect server offline vs network issue
            const httpUrl = wsUrl.replace('wss://', 'https://').replace('ws://', 'http://');
            fetch(httpUrl, { method: 'GET', mode: 'no-cors' }).catch(() => {
                // If pre-flight fails, server might be offline - still attempt WebSocket
                // but note it for the user
                detailsEl.textContent = 'Server may be offline, attempting connection...';
            });

            // Set connection timeout
            connectionTimeout = setTimeout(() => {
                if (multiplayerSocket && multiplayerSocket.readyState !== WebSocket.OPEN) {
                    console.warn('Connection timeout after 10 seconds');
                    // Null out onclose before closing to prevent double-retry
                    if (multiplayerSocket) multiplayerSocket.onclose = null;
                    cleanupSocket();
                    scheduleRetry(detailsEl, 'Connection timed out.');
                }
            }, CONNECTION_TIMEOUT_MS);

            try {
                multiplayerSocket = new WebSocket(wsUrl);

                multiplayerSocket.onopen = () => {
                    if (connectionTimeout) {
                        clearTimeout(connectionTimeout);
                        connectionTimeout = null;
                    }
                    connectionAttempts = 0;
                    isRetrying = false;
                    document.getElementById('connectionDetails').textContent = '';
                    document.getElementById('lobbyStatus').textContent = 'Connected! Joining match...';
                    multiplayerSocket.send(JSON.stringify({
                        type: 'join',
                        name: playerName,
                        weapon: hotbar[selectedSlot] || 'sword'
                    }));
                };

                multiplayerSocket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleMultiplayerMessage(data);
                    } catch (e) {
                        console.error('Error parsing message:', e);
                    }
                };

                multiplayerSocket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };

                multiplayerSocket.onclose = () => {
                    if (connectionTimeout) {
                        clearTimeout(connectionTimeout);
                        connectionTimeout = null;
                    }

                    if (isMultiplayer) {
                        handleDisconnectDuringGame();
                    } else if (connectionAttempts <= MAX_RECONNECT_ATTEMPTS && document.getElementById('multiplayerLobby').style.display === 'flex') {
                        scheduleRetry(detailsEl, 'Connection lost.');
                    }
                };
            } catch (e) {
                console.error('Failed to connect:', e);
                handleConnectionFailure('Failed to create connection: ' + e.message);
            }
        }

        function handleConnectionFailure(message) {
            document.getElementById('lobbyStatus').textContent = 'Connection failed';
            document.getElementById('connectionDetails').textContent = message + ' Check your internet connection.';
            document.getElementById('connectionSpinner').style.display = 'none';
            document.getElementById('retryConnectionBtn').style.display = 'block';
        }

        function handleDisconnectDuringGame() {
            document.getElementById('lobbyStatus').textContent = 'Disconnected from server. Reconnecting...';
            document.getElementById('multiplayerLobby').style.display = 'flex';
            document.getElementById('connectionSpinner').style.display = 'block';
            document.getElementById('retryConnectionBtn').style.display = 'none';
            connectionAttempts = 0;
            isRetrying = false;
            attemptConnection();
        }

        function retryConnection() {
            document.getElementById('retryConnectionBtn').style.display = 'none';
            document.getElementById('connectionSpinner').style.display = 'block';
            connectionAttempts = 0;
            isRetrying = false;
            attemptConnection();
        }

        function handleMultiplayerMessage(data) {
            switch (data.type) {
                case 'game_state':
                    myPlayerId = data.playerId;
                    matchTimeRemaining = data.timeRemaining;
                    // Start the multiplayer game
                    startMultiplayerGame();
                    // Add existing players
                    data.players.forEach(p => {
                        if (p.id !== myPlayerId) {
                            createRemotePlayer(p);
                        }
                    });
                    updatePlayerCount();
                    break;

                case 'player_joined':
                    if (data.player.id !== myPlayerId) {
                        createRemotePlayer(data.player);
                        addKillFeedMessage(`${data.player.name} joined the match`, '#00ff00');
                        // Create voice peer connection if voice chat is active
                        if (voiceChatEnabled) {
                            createPeerConnection(data.player.id, true);
                        }
                        // Cancel empty lobby timer and dismiss prompt
                        if (emptyLobbyTimer) {
                            clearTimeout(emptyLobbyTimer);
                            emptyLobbyTimer = null;
                        }
                        dismissEmptyLobbyPrompt();
                    }
                    updatePlayerCount();
                    break;

                case 'player_left':
                    removeRemotePlayer(data.playerId);
                    addKillFeedMessage(`${data.playerName} left the match`, '#ff6600');
                    // Clean up voice peer connection
                    if (peerConnections[data.playerId]) {
                        peerConnections[data.playerId].close();
                        delete peerConnections[data.playerId];
                    }
                    const voiceInd = document.getElementById('voice-ind-' + data.playerId);
                    if (voiceInd) voiceInd.remove();
                    updatePlayerCount();
                    break;

                case 'player_position':
                    updateRemotePlayerPosition(data);
                    break;

                case 'player_attack':
                    showRemotePlayerAttack(data);
                    break;

                case 'player_damaged':
                    if (data.targetId === myPlayerId) {
                        damagePlayer(data.damage);
                    } else {
                        updateRemotePlayerHealth(data.targetId, data.health);
                    }
                    break;

                case 'player_killed':
                    addKillFeedMessage(`${data.killerName} killed ${data.targetName}`, '#ff4444');
                    if (data.targetId === myPlayerId) {
                        // We died - show respawn
                        showDeathScreen(data.killerName);
                    }
                    break;

                case 'player_respawned':
                    if (data.playerId === myPlayerId) {
                        playerState.health = data.health;
                        playerState.position.set(data.position.x, data.position.y, data.position.z);
                        hideDeathScreen();
                    } else {
                        updateRemotePlayerPosition({
                            playerId: data.playerId,
                            position: data.position,
                            health: data.health
                        });
                    }
                    break;

                case 'time_update':
                    matchTimeRemaining = data.timeRemaining;
                    updateMatchTimer();
                    break;

                case 'match_start':
                    matchTimeRemaining = data.matchDuration;
                    addKillFeedMessage('Match started!', '#ffff00');
                    break;

                case 'match_end':
                    endMultiplayerMatch(data);
                    break;

                case 'chat':
                    addChatMessage(data.playerName, data.message, data.playerId === myPlayerId ? '#88ccff' : '#ffcc00');
                    break;

                case 'chat_error':
                    addChatMessage('System', data.message, '#ff4444');
                    break;

                case 'voice_offer':
                    handleVoiceOffer(data.senderId, data.sdp);
                    break;

                case 'voice_answer':
                    handleVoiceAnswer(data.senderId, data.sdp);
                    break;

                case 'voice_ice_candidate':
                    handleVoiceIceCandidate(data.senderId, data.candidate);
                    break;
            }
        }

        function startMultiplayerGame() {
            isMultiplayer = true;
            renderer.domElement.style.display = 'block';
            document.getElementById('multiplayerLobby').style.display = 'none';
            document.getElementById('menu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('coinsDisplay').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('hotbar').style.display = 'flex';
            document.getElementById('multiplayerHUD').style.display = 'block';
            document.getElementById('statsPanel').style.display = 'none'; // Hide wave/score in MP
            document.getElementById('minimap').style.display = 'block';

            // Start empty lobby timer - if alone for 15s, prompt to switch to solo
            if (emptyLobbyTimer) clearTimeout(emptyLobbyTimer);
            emptyLobbyTimer = setTimeout(() => {
                if (isMultiplayer && Object.keys(remotePlayers).length === 0) {
                    showEmptyLobbyPrompt();
                }
            }, 15000);

            // Show/hide voice chat button based on age verification
            const voiceBtn = document.getElementById('voiceChatBtn');
            if (voiceBtn) {
                voiceBtn.style.display = getCookie('voiceChatAge') === 'under13' ? 'none' : 'flex';
            }

            setupInput();
            showChatContainer();

            if (deviceMode === 'mobile') {
                document.getElementById('mobileControls').style.display = 'block';
            } else {
                renderer.domElement.requestPointerLock();
            }

            // Reset player state
            playerState.health = playerState.maxHealth;
            playerState.energy = playerState.maxEnergy;
            playerState.position.set(Math.random() * 40 - 20, 1.7, Math.random() * 40 - 20);

            gameRunning = true;
            updateMatchTimer();
        }

        function createRemotePlayer(playerData) {
            if (remotePlayers[playerData.id]) return;

            const group = new THREE.Group();

            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.3, 0.35, 1.0, 10);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2244aa, roughness: 0.7 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.7;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeo = new THREE.SphereGeometry(0.22, 12, 10);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffcc99, roughness: 0.8 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.4;
            head.castShadow = true;
            group.add(head);

            // Name tag
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(playerData.name, 128, 42);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(2, 0.5, 1);
            sprite.position.y = 2.0;
            group.add(sprite);

            // Health bar background
            const healthBgGeo = new THREE.PlaneGeometry(1, 0.1);
            const healthBgMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const healthBg = new THREE.Mesh(healthBgGeo, healthBgMat);
            healthBg.position.y = 1.8;
            group.add(healthBg);

            // Health bar fill
            const healthFillGeo = new THREE.PlaneGeometry(1, 0.1);
            const healthFillMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const healthFill = new THREE.Mesh(healthFillGeo, healthFillMat);
            healthFill.position.y = 1.8;
            healthFill.position.z = 0.01;
            group.add(healthFill);

            group.position.set(
                playerData.position?.x || 0,
                playerData.position?.y || 1.7,
                playerData.position?.z || 0
            );

            scene.add(group);

            remotePlayers[playerData.id] = {
                mesh: group,
                name: playerData.name,
                health: playerData.health || 100,
                maxHealth: playerData.maxHealth || 100,
                healthBar: healthFill,
                targetPosition: new THREE.Vector3(),
                targetRotation: { x: 0, y: 0 }
            };
        }

        function removeRemotePlayer(playerId) {
            const player = remotePlayers[playerId];
            if (player) {
                scene.remove(player.mesh);
                delete remotePlayers[playerId];
            }
        }

        function updateRemotePlayerPosition(data) {
            const player = remotePlayers[data.playerId];
            if (player) {
                player.targetPosition.set(data.position.x, data.position.y, data.position.z);
                player.targetRotation = data.rotation || { x: 0, y: 0 };
                if (data.health !== undefined) {
                    player.health = data.health;
                    updateRemotePlayerHealthBar(player);
                }
            }
        }

        function updateRemotePlayerHealth(playerId, health) {
            const player = remotePlayers[playerId];
            if (player) {
                player.health = health;
                updateRemotePlayerHealthBar(player);
            }
        }

        function updateRemotePlayerHealthBar(player) {
            const healthPercent = player.health / player.maxHealth;
            player.healthBar.scale.x = Math.max(0.01, healthPercent);
            player.healthBar.position.x = (healthPercent - 1) * 0.5;
            player.healthBar.material.color.setHex(healthPercent > 0.5 ? 0x00ff00 : healthPercent > 0.25 ? 0xffff00 : 0xff0000);
        }

        function showRemotePlayerAttack(data) {
            const player = remotePlayers[data.playerId];
            if (player && player.mesh) {
                // Flash effect
                player.mesh.traverse(child => {
                    if (child.isMesh && child.material && child.material.emissive) {
                        child.material.emissive.setHex(0xff0000);
                        setTimeout(() => child.material.emissive.setHex(0x000000), 150);
                    }
                });
            }
        }

        function syncPositionToServer() {
            if (!multiplayerSocket || !isMultiplayer || !gameRunning || multiplayerSocket.readyState !== WebSocket.OPEN) return;

            const now = Date.now();
            if (now - lastPositionSync < 50) return; // 20 updates per second
            lastPositionSync = now;

            multiplayerSocket.send(JSON.stringify({
                type: 'position',
                position: {
                    x: playerState.position.x,
                    y: playerState.position.y,
                    z: playerState.position.z
                },
                rotation: playerState.rotation,
                weapon: hotbar[selectedSlot] || 'sword'
            }));
        }

        function sendMultiplayerAttack() {
            if (!multiplayerSocket || !isMultiplayer || multiplayerSocket.readyState !== WebSocket.OPEN) return;

            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);

            multiplayerSocket.send(JSON.stringify({
                type: 'attack',
                weapon: hotbar[selectedSlot] || 'sword',
                position: {
                    x: playerState.position.x,
                    y: playerState.position.y,
                    z: playerState.position.z
                },
                direction: { x: dir.x, y: dir.y, z: dir.z }
            }));

            // Check for hits on other players
            checkMultiplayerHits();
        }

        function checkMultiplayerHits() {
            const itemId = hotbar[selectedSlot];
            const item = itemDefs[itemId];
            if (!item) return;

            let damage = item.damage || 15;
            if (playerState.rageModeActive) damage *= 2;
            if (playerState.berserkActive) damage *= 3;

            const range = item.type === 'ranged' ? 20 : 2.5;
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);

            for (const playerId in remotePlayers) {
                const rp = remotePlayers[playerId];
                if (!rp.mesh) continue;

                const toPlayer = rp.mesh.position.clone().sub(playerState.position);
                const dist = toPlayer.length();

                if (dist < range) {
                    // Check angle for melee
                    if (item.type !== 'ranged') {
                        const angle = dir.angleTo(toPlayer.normalize());
                        if (angle > Math.PI / 4) continue; // Must be facing the target
                    }

                    // Send damage to server
                    if (multiplayerSocket && multiplayerSocket.readyState === WebSocket.OPEN) {
                        multiplayerSocket.send(JSON.stringify({
                            type: 'damage',
                            targetId: playerId,
                            damage: damage
                        }));
                    }
                }
            }
        }

        function updateRemotePlayers(dt) {
            for (const playerId in remotePlayers) {
                const player = remotePlayers[playerId];
                if (!player.mesh) continue;

                // Smooth interpolation
                player.mesh.position.lerp(player.targetPosition, 0.15);
                player.mesh.rotation.y = player.targetRotation.y || 0;

                // Make health bar face camera
                player.mesh.children.forEach(child => {
                    if (child.isSprite || child.geometry?.type === 'PlaneGeometry') {
                        child.lookAt(camera.position);
                    }
                });
            }
        }

        function updateMatchTimer() {
            const minutes = Math.floor(matchTimeRemaining / 60000);
            const seconds = Math.floor((matchTimeRemaining % 60000) / 1000);
            const timerEl = document.getElementById('matchTimer');
            if (timerEl) {
                timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                if (matchTimeRemaining < 60000) {
                    timerEl.style.color = '#ff4444';
                }
            }
        }

        function addKillFeedMessage(message, color) {
            const feed = document.getElementById('killFeed');
            if (!feed) return;

            const div = document.createElement('div');
            div.style.cssText = `background: rgba(0,0,0,0.7); color: ${color}; padding: 5px 10px; margin-bottom: 5px; border-radius: 5px; font-size: 12px; animation: fadeOut 3s forwards;`;
            div.textContent = message;
            feed.insertBefore(div, feed.firstChild);

            setTimeout(() => div.remove(), 3000);

            // Keep only last 5 messages
            while (feed.children.length > 5) {
                feed.removeChild(feed.lastChild);
            }
        }

        function updatePlayerCount() {
            const count = Object.keys(remotePlayers).length + 1;
            const countEl = document.getElementById('playerCount');
            if (countEl) countEl.textContent = `Players: ${count}`;
        }

        function showDeathScreen(killerName) {
            const overlay = document.createElement('div');
            overlay.id = 'deathOverlay';
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(100,0,0,0.5);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:200;';
            overlay.innerHTML = `
                <h1 style="color: #ff4444; font-size: 48px;">YOU DIED</h1>
                <p style="color: white; font-size: 18px;">Killed by ${killerName}</p>
                <p style="color: #aaa; font-size: 14px;">Respawning in 3 seconds...</p>
            `;
            document.body.appendChild(overlay);

            setTimeout(() => {
                if (multiplayerSocket && isMultiplayer && multiplayerSocket.readyState === WebSocket.OPEN) {
                    multiplayerSocket.send(JSON.stringify({ type: 'respawn' }));
                }
            }, 3000);
        }

        function hideDeathScreen() {
            const overlay = document.getElementById('deathOverlay');
            if (overlay) overlay.remove();
        }

        function endMultiplayerMatch(data) {
            gameRunning = false;
            document.getElementById('matchEndScreen').style.display = 'flex';

            const isWinner = data.winnerId === myPlayerId;
            document.getElementById('matchResult').textContent = isWinner ? 'VICTORY!' : 'MATCH OVER';
            document.getElementById('matchResult').style.color = isWinner ? '#00ff00' : 'gold';
            document.getElementById('matchWinner').textContent = `Winner: ${data.winnerName} (${data.winnerKills} kills)`;

            let scoreboardHTML = '<table style="width:100%;color:white;border-collapse:collapse;">';
            scoreboardHTML += '<tr style="border-bottom:1px solid gold;"><th style="padding:8px;">Rank</th><th>Player</th><th>Kills</th><th>Deaths</th></tr>';
            data.scoreboard.forEach((p, i) => {
                const isMe = p.id === myPlayerId;
                scoreboardHTML += `<tr style="background:${isMe ? 'rgba(100,100,255,0.3)' : 'transparent'};">
                    <td style="padding:8px;text-align:center;">${i + 1}</td>
                    <td>${p.name}</td>
                    <td style="text-align:center;color:#00ff00;">${p.kills}</td>
                    <td style="text-align:center;color:#ff4444;">${p.deaths}</td>
                </tr>`;
            });
            scoreboardHTML += '</table>';
            document.getElementById('finalScoreboard').innerHTML = scoreboardHTML;

            if (isWinner) {
                document.getElementById('matchReward').textContent = `Reward: +${data.reward} coins!`;
                inventory.coins += data.reward;
                saveCoinsToCloud();
            } else {
                document.getElementById('matchReward').textContent = '';
            }
        }

        function leaveMultiplayer() {
            isMultiplayer = false;
            gameRunning = false;

            // Disable voice chat
            disableVoiceChat();

            // Clear empty lobby timer
            if (emptyLobbyTimer) {
                clearTimeout(emptyLobbyTimer);
                emptyLobbyTimer = null;
            }
            dismissEmptyLobbyPrompt();

            // Clear any pending reconnect/timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
                connectionTimeout = null;
            }
            connectionAttempts = 0;
            isRetrying = false;

            cleanupSocket();

            // Clean up remote players
            for (const playerId in remotePlayers) {
                removeRemotePlayer(playerId);
            }
            remotePlayers = {};

            // Hide multiplayer UI
            document.getElementById('multiplayerLobby').style.display = 'none';
            document.getElementById('multiplayerHUD').style.display = 'none';
            document.getElementById('matchEndScreen').style.display = 'none';
            hideChatContainer();
            hideDeathScreen();

            // Hide canvas and show menu
            renderer.domElement.style.display = 'none';
            if (document.exitPointerLock) document.exitPointerLock();
            document.getElementById('menu').style.display = 'flex';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('coinsDisplay').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('hotbar').style.display = 'none';
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('mobileControls').style.display = 'none';

            document.getElementById('menuCoins').textContent = 'üí∞ ' + inventory.coins;

            // Release pointer lock
            if (document.exitPointerLock) document.exitPointerLock();
        }

        function leaveLobby() {
            // Clear empty lobby timer
            if (emptyLobbyTimer) {
                clearTimeout(emptyLobbyTimer);
                emptyLobbyTimer = null;
            }

            // Clear any pending reconnect/timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
            if (connectionTimeout) {
                clearTimeout(connectionTimeout);
                connectionTimeout = null;
            }
            connectionAttempts = 0;
            isRetrying = false;

            cleanupSocket();
            document.getElementById('multiplayerLobby').style.display = 'none';
            document.getElementById('menu').style.display = 'flex';
        }

        // ========== CHAT SYSTEM ==========
        let isChatOpen = false;
        const MAX_VISIBLE_MESSAGES = 20;
        const MESSAGE_FADE_TIME = 10000;

        function openChatInput() {
            isChatOpen = true;
            const container = document.getElementById('chatInputContainer');
            const input = document.getElementById('chatInput');
            container.style.display = 'block';
            document.getElementById('chatHint').style.display = 'none';
            input.value = '';
            input.focus();

            // Release pointer lock while typing
            if (document.exitPointerLock) document.exitPointerLock();

            // Clear movement keys to stop player from running
            Object.keys(keys).forEach(k => { keys[k] = false; });
        }

        function closeChatInput() {
            isChatOpen = false;
            const container = document.getElementById('chatInputContainer');
            container.style.display = 'none';
            document.getElementById('chatHint').style.display = 'block';

            // Re-engage pointer lock
            if (deviceMode === 'computer' && renderer && renderer.domElement) {
                renderer.domElement.requestPointerLock();
            }
        }

        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = (input.value || '').trim();
            closeChatInput();

            if (!message || !multiplayerSocket || multiplayerSocket.readyState !== WebSocket.OPEN) return;

            try {
                const response = await fetch('/api/filter-chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message })
                });
                const data = await response.json();
                const filtered = data.filtered || message;

                multiplayerSocket.send(JSON.stringify({
                    type: 'chat',
                    message: filtered
                }));
            } catch (_e) {
                // If filter fails, send original
                multiplayerSocket.send(JSON.stringify({
                    type: 'chat',
                    message: message.slice(0, 200)
                }));
            }
        }

        function addChatMessage(playerNameStr, message, color) {
            const container = document.getElementById('chatMessages');
            if (!container) return;

            const div = document.createElement('div');
            div.style.cssText = 'background: rgba(0,0,0,0.6); padding: 3px 8px; border-radius: 4px; font-size: 12px; pointer-events: none;';

            const nameSpan = document.createElement('span');
            nameSpan.style.cssText = `color: ${color || '#ffcc00'}; font-weight: bold;`;
            nameSpan.textContent = playerNameStr + ': ';

            const msgSpan = document.createElement('span');
            msgSpan.style.color = '#fff';
            msgSpan.textContent = message;

            div.appendChild(nameSpan);
            div.appendChild(msgSpan);
            container.appendChild(div);

            // Fade out after MESSAGE_FADE_TIME
            setTimeout(() => {
                div.style.transition = 'opacity 1s';
                div.style.opacity = '0';
                setTimeout(() => div.remove(), 1000);
            }, MESSAGE_FADE_TIME);

            // Keep max visible messages
            while (container.children.length > MAX_VISIBLE_MESSAGES) {
                container.removeChild(container.firstChild);
            }
        }

        function showChatContainer() {
            const container = document.getElementById('chatContainer');
            if (container) container.style.display = 'block';
        }

        function hideChatContainer() {
            const container = document.getElementById('chatContainer');
            if (container) container.style.display = 'none';
            if (isChatOpen) closeChatInput();
        }

        // ========== AUTH SYSTEM ==========

        function showAuthModal() {
            document.getElementById('authModal').style.display = 'flex';
            document.getElementById('menu').style.display = 'none';
        }

        function hideAuthModal() {
            document.getElementById('authModal').style.display = 'none';
        }

        function switchAuthTab(tab) {
            const tabs = document.querySelectorAll('.auth-tab');
            const loginForm = document.getElementById('loginForm');
            const signupForm = document.getElementById('signupForm');

            tabs.forEach(t => t.classList.remove('active'));

            if (tab === 'login') {
                tabs[0].classList.add('active');
                loginForm.classList.add('active');
                signupForm.classList.remove('active');
            } else {
                tabs[1].classList.add('active');
                signupForm.classList.add('active');
                loginForm.classList.remove('active');
            }

            // Clear errors
            document.getElementById('loginError').textContent = '';
            document.getElementById('signupError').textContent = '';
        }

        function validateUsernameRealtime() {
            const input = document.getElementById('signupUsername');
            const statusEl = document.getElementById('usernameStatus');
            const username = (input.value || '').trim();

            if (usernameValidationTimer) clearTimeout(usernameValidationTimer);

            if (username.length === 0) {
                statusEl.textContent = '';
                statusEl.className = 'username-status';
                input.classList.remove('valid', 'invalid');
                return;
            }

            if (username.length < 3) {
                statusEl.textContent = 'Username must be at least 3 characters.';
                statusEl.className = 'username-status invalid';
                input.classList.remove('valid');
                input.classList.add('invalid');
                return;
            }

            if (!/^[a-zA-Z0-9_]+$/.test(username)) {
                statusEl.textContent = 'Only letters, numbers, and underscores allowed.';
                statusEl.className = 'username-status invalid';
                input.classList.remove('valid');
                input.classList.add('invalid');
                return;
            }

            statusEl.textContent = 'Checking...';
            statusEl.className = 'username-status checking';

            usernameValidationTimer = setTimeout(async () => {
                try {
                    const resp = await fetch('/api/validate-username', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username })
                    });
                    const data = await resp.json();
                    // Only update if input hasn't changed
                    if (input.value.trim() === username) {
                        if (data.valid) {
                            statusEl.textContent = data.reason || 'Username looks good!';
                            statusEl.className = 'username-status valid';
                            input.classList.remove('invalid');
                            input.classList.add('valid');
                        } else {
                            statusEl.textContent = data.reason || 'Username not available.';
                            statusEl.className = 'username-status invalid';
                            input.classList.remove('valid');
                            input.classList.add('invalid');
                        }
                    }
                } catch (_e) {
                    if (input.value.trim() === username) {
                        statusEl.textContent = 'Could not validate. Try again.';
                        statusEl.className = 'username-status checking';
                    }
                }
            }, 500);
        }

        function submitLogin() {
            const username = (document.getElementById('loginUsername').value || '').trim();
            const password = document.getElementById('loginPassword').value || '';
            const errorEl = document.getElementById('loginError');
            const spinner = document.getElementById('loginSpinner');
            const submitBtn = document.querySelector('#loginForm .auth-submit-btn');

            errorEl.textContent = '';

            if (!username || !password) {
                errorEl.textContent = 'Please enter username and password.';
                return;
            }

            spinner.style.display = 'block';
            if (submitBtn) submitBtn.disabled = true;
            connectToSocialServerForAuth('login', { username, password, deviceId });
        }

        async function submitSignup() {
            const username = (document.getElementById('signupUsername').value || '').trim();
            const password = document.getElementById('signupPassword').value || '';
            const confirmPassword = document.getElementById('signupConfirmPassword').value || '';
            const errorEl = document.getElementById('signupError');
            const spinner = document.getElementById('signupSpinner');
            const submitBtn = document.querySelector('#signupForm .auth-submit-btn');

            errorEl.textContent = '';

            if (!username || username.length < 3) {
                errorEl.textContent = 'Username must be at least 3 characters.';
                return;
            }

            if (!/^[a-zA-Z0-9_]+$/.test(username)) {
                errorEl.textContent = 'Username can only contain letters, numbers, and underscores.';
                return;
            }

            if (password.length < 6) {
                errorEl.textContent = 'Password must be at least 6 characters.';
                return;
            }

            if (password !== confirmPassword) {
                errorEl.textContent = 'Passwords do not match.';
                return;
            }

            // Validate username appropriateness before creating account
            spinner.style.display = 'block';
            if (submitBtn) submitBtn.disabled = true;
            try {
                const validateResp = await fetch('/api/validate-username', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username })
                });
                const validateData = await validateResp.json();
                if (!validateData.valid) {
                    spinner.style.display = 'none';
                    if (submitBtn) submitBtn.disabled = false;
                    errorEl.textContent = validateData.reason || 'Username is not appropriate.';
                    return;
                }
            } catch (_e) {
                // If validation service is down, allow signup with basic validation only
                console.error('Username validation service unavailable, proceeding with basic validation');
            }

            connectToSocialServerForAuth('signup', { username, password, deviceId });
        }

        let authTimeout = null;

        function authConnectionFailed(action, message) {
            const loginSpinner = document.getElementById('loginSpinner');
            const signupSpinner = document.getElementById('signupSpinner');
            const loginBtn = document.querySelector('#loginForm .auth-submit-btn');
            const signupBtn = document.querySelector('#signupForm .auth-submit-btn');
            if (loginSpinner) loginSpinner.style.display = 'none';
            if (signupSpinner) signupSpinner.style.display = 'none';
            if (loginBtn) loginBtn.disabled = false;
            if (signupBtn) signupBtn.disabled = false;
            if (authTimeout) { clearTimeout(authTimeout); authTimeout = null; }

            if (action === 'check_auth') {
                // Auto-login failed - clear stale cookies and show auth modal
                isAuthenticated = false;
                authToken = null;
                authenticatedUsername = null;
                setCookie('authToken', '', -1);
                setCookie('authUsername', '', -1);
                try {
                    localStorage.removeItem('authToken');
                    localStorage.removeItem('authUsername');
                } catch (e) { /* ignore */ }
                showAuthModal();
            } else {
                const errorEl = document.getElementById(action === 'login' ? 'loginError' : 'signupError');
                if (errorEl) errorEl.textContent = message || 'Connection error. Please try again.';
            }
        }

        function connectToSocialServerForAuth(action, credentials) {
            // Close any existing social socket
            if (socialSocket) {
                try { socialSocket.close(); } catch (_e) { /* ignore */ }
                socialSocket = null;
            }
            if (authTimeout) { clearTimeout(authTimeout); authTimeout = null; }

            // Timeout: if no response in 10 seconds, treat as failure
            authTimeout = setTimeout(() => {
                authTimeout = null;
                console.error('Auth connection timed out for action:', action);
                if (socialSocket) {
                    try { socialSocket.close(); } catch (_e) { /* ignore */ }
                    socialSocket = null;
                }
                authConnectionFailed(action, 'Connection timed out. Please try again.');
            }, 10000);

            try {
                socialSocket = new WebSocket('wss://game.hadijaffri.partykit.dev/parties/social/social-hub');

                socialSocket.onopen = () => {
                    socialSocket.send(JSON.stringify({
                        type: action,
                        ...credentials
                    }));
                };

                socialSocket.onmessage = (event) => {
                    if (authTimeout) { clearTimeout(authTimeout); authTimeout = null; }
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'auth_success' || data.type === 'auth_error' || data.type === 'auth_expired') {
                            handleAuthResponse(data);
                        } else {
                            handleSocialMessage(data);
                        }
                    } catch (e) {
                        console.error('Error parsing auth message:', e);
                    }
                };

                socialSocket.onerror = () => {
                    authConnectionFailed(action, 'Connection error. Please try again.');
                };

                socialSocket.onclose = () => {
                    // Only null out if this is still the active socket
                    if (socialSocket && socialSocket.readyState === WebSocket.CLOSED) {
                        socialSocket = null;
                    }
                };
            } catch (e) {
                console.error('Failed to connect for auth:', e);
                authConnectionFailed(action, 'Failed to connect. Please try again.');
            }
        }

        function handleAuthResponse(data) {
            if (authTimeout) { clearTimeout(authTimeout); authTimeout = null; }
            const loginSpinner = document.getElementById('loginSpinner');
            const signupSpinner = document.getElementById('signupSpinner');
            const loginBtn = document.querySelector('#loginForm .auth-submit-btn');
            const signupBtn = document.querySelector('#signupForm .auth-submit-btn');
            if (loginSpinner) loginSpinner.style.display = 'none';
            if (signupSpinner) signupSpinner.style.display = 'none';
            if (loginBtn) loginBtn.disabled = false;
            if (signupBtn) signupBtn.disabled = false;

            if (data.type === 'auth_success') {
                isAuthenticated = true;
                authToken = data.token;
                authenticatedUsername = data.username;
                playerName = data.username;
                if (data.deviceId) {
                    // Update deviceId cookie if server returned one (for login with existing account)
                    setCookie('deviceId', data.deviceId);
                }
                // Save auth for 365 days and also in localStorage as backup
                setCookie('authToken', data.token, 365);
                setCookie('authUsername', data.username, 365);
                try {
                    localStorage.setItem('authToken', data.token);
                    localStorage.setItem('authUsername', data.username);
                } catch (e) {
                    console.log('localStorage not available');
                }

                // Update social data
                myFriendCode = data.friendCode || '';
                friendsList = data.friends || [];
                pendingRequests = data.pendingRequests || [];
                friendsServers = data.friendsServers || [];

                hideAuthModal();
                document.getElementById('menu').style.display = 'flex';
            } else if (data.type === 'auth_error') {
                // If auth modal isn't visible, this was a background check_auth - show modal
                const authModal = document.getElementById('authModal');
                if (authModal.style.display === 'none' || authModal.style.display === '') {
                    isAuthenticated = false;
                    authToken = null;
                    authenticatedUsername = null;
                    setCookie('authToken', '', -1);
                    setCookie('authUsername', '', -1);
                    showAuthModal();
                } else {
                    const loginForm = document.getElementById('loginForm');
                    const isLoginTab = loginForm.classList.contains('active');
                    const errorEl = document.getElementById(isLoginTab ? 'loginError' : 'signupError');
                    if (errorEl) errorEl.textContent = data.message || 'Authentication failed.';
                }
            } else if (data.type === 'auth_expired') {
                // Token expired, clear and show auth modal
                isAuthenticated = false;
                authToken = null;
                authenticatedUsername = null;
                setCookie('authToken', '', -1);
                setCookie('authUsername', '', -1);
                try {
                    localStorage.removeItem('authToken');
                    localStorage.removeItem('authUsername');
                } catch (e) { /* ignore */ }
                showAuthModal();
            }
        }

        function continueAsGuest() {
            isAuthenticated = false;
            authToken = null;
            authenticatedUsername = null;
            playerName = 'Guest_' + Math.random().toString(36).substr(2, 4);
            hideAuthModal();
            document.getElementById('menu').style.display = 'flex';
        }

        function tryAutoLogin() {
            // Try to get auth from cookies first, then localStorage as fallback
            let savedToken = getCookie('authToken');
            let savedUsername = getCookie('authUsername');

            if (!savedToken || !savedUsername) {
                try {
                    savedToken = localStorage.getItem('authToken');
                    savedUsername = localStorage.getItem('authUsername');
                    // If found in localStorage, restore to cookies
                    if (savedToken && savedUsername) {
                        setCookie('authToken', savedToken, 365);
                        setCookie('authUsername', savedUsername, 365);
                    }
                } catch (e) {
                    console.log('localStorage not available');
                }
            }

            if (savedToken && savedUsername) {
                // Try auto-login with saved token
                authenticatedUsername = savedUsername;
                playerName = savedUsername;
                connectToSocialServerForAuth('check_auth', { token: savedToken, deviceId });
            } else {
                // No saved session, show auth modal
                showAuthModal();
            }
        }

        // ========== EMPTY LOBBY FUNCTIONS ==========

        function showEmptyLobbyPrompt() {
            document.getElementById('emptyLobbyPrompt').style.display = 'flex';
        }

        function dismissEmptyLobbyPrompt() {
            document.getElementById('emptyLobbyPrompt').style.display = 'none';
        }

        function switchToSoloFromMultiplayer() {
            dismissEmptyLobbyPrompt();
            leaveMultiplayer();
            startGame();
        }

        // ========== FRIENDS SYSTEM ==========

        function connectToSocialServer() {
            if (socialSocket && socialSocket.readyState === WebSocket.OPEN) return;

            try {
                socialSocket = new WebSocket('wss://game.hadijaffri.partykit.dev/parties/social/social-hub');

                socialSocket.onopen = () => {
                    if (isAuthenticated && authToken) {
                        // Use check_auth for authenticated users
                        socialSocket.send(JSON.stringify({
                            type: 'check_auth',
                            token: authToken,
                            deviceId: deviceId
                        }));
                    } else {
                        // Guest mode - use register
                        socialSocket.send(JSON.stringify({
                            type: 'register',
                            deviceId: deviceId,
                            username: playerName
                        }));
                    }
                };

                socialSocket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'auth_success') {
                            // Update social data from auth response
                            myFriendCode = data.friendCode || '';
                            friendsList = data.friends || [];
                            pendingRequests = data.pendingRequests || [];
                            friendsServers = data.friendsServers || [];
                            updateFriendsUI();
                        } else if (data.type === 'auth_expired') {
                            // Fall back to register
                            socialSocket.send(JSON.stringify({
                                type: 'register',
                                deviceId: deviceId,
                                username: playerName
                            }));
                        } else {
                            handleSocialMessage(data);
                        }
                    } catch (e) {
                        console.error('Error parsing social message:', e);
                    }
                };

                socialSocket.onerror = (error) => {
                    console.error('Social WebSocket error:', error);
                };

                socialSocket.onclose = () => {
                    socialSocket = null;
                };
            } catch (e) {
                console.error('Failed to connect to social server:', e);
            }
        }

        function handleSocialMessage(data) {
            switch (data.type) {
                case 'registered':
                    myFriendCode = data.friendCode;
                    friendsList = data.friends || [];
                    pendingRequests = data.pendingRequests || [];
                    friendsServers = data.friendsServers || [];
                    updateFriendsUI();
                    break;

                case 'friend_request_sent':
                    document.getElementById('friendRequestStatus').textContent = 'Friend request sent!';
                    document.getElementById('friendRequestStatus').style.color = '#2ecc71';
                    document.getElementById('addFriendInput').value = '';
                    break;

                case 'friend_request_error':
                    document.getElementById('friendRequestStatus').textContent = data.message;
                    document.getElementById('friendRequestStatus').style.color = '#ff4444';
                    break;

                case 'friend_request_received':
                    showFriendRequestToast(data.fromUsername, data.fromFriendCode, data.fromDeviceId);
                    pendingRequests.push({ fromDeviceId: data.fromDeviceId, fromUsername: data.fromUsername, fromFriendCode: data.fromFriendCode });
                    updatePendingRequestsUI();
                    break;

                case 'friend_request_accepted':
                    showNotification(`${data.username} accepted your friend request!`, '#2ecc71');
                    friendsList.push({ deviceId: data.deviceId, username: data.username, friendCode: data.friendCode, online: true });
                    updateFriendsListUI();
                    break;

                case 'friends_updated':
                    friendsList = data.friends || [];
                    pendingRequests = data.pendingRequests || [];
                    if (data.friendsServers) friendsServers = data.friendsServers;
                    updateFriendsUI();
                    break;

                case 'friends_server_created':
                    showNotification('Friends server created!', '#9b59b6');
                    // Refresh servers list
                    if (socialSocket && socialSocket.readyState === WebSocket.OPEN) {
                        socialSocket.send(JSON.stringify({ type: 'get_friends', deviceId }));
                    }
                    break;

                case 'friends_server_available':
                    showNotification(`${data.hostUsername} started a friends server!`, '#9b59b6');
                    friendsServers.push({ roomId: data.roomId, hostUsername: data.hostUsername, hostDeviceId: data.hostDeviceId });
                    updateFriendsServersUI();
                    break;

                case 'friends_server_closed':
                    friendsServers = friendsServers.filter(s => s.roomId !== data.roomId);
                    updateFriendsServersUI();
                    break;

                case 'join_approved':
                    joinFriendsServer(data.wsUrl);
                    break;

                case 'join_denied':
                    showNotification(data.reason, '#ff4444');
                    break;
            }
        }

        function openFriendsPanel() {
            isFriendsPanelOpen = true;
            document.getElementById('friendsPanel').style.display = 'flex';
            connectToSocialServer();
        }

        function closeFriendsPanel() {
            isFriendsPanelOpen = false;
            document.getElementById('friendsPanel').style.display = 'none';
        }

        function updateFriendsUI() {
            document.getElementById('myFriendCode').textContent = myFriendCode;
            updatePendingRequestsUI();
            updateFriendsListUI();
            updateFriendsServersUI();
        }

        function sendFriendRequest() {
            const input = document.getElementById('addFriendInput');
            const code = (input.value || '').trim();
            if (!code) return;

            if (!socialSocket || socialSocket.readyState !== WebSocket.OPEN) {
                connectToSocialServer();
                setTimeout(() => sendFriendRequest(), 1000);
                return;
            }

            socialSocket.send(JSON.stringify({
                type: 'send_friend_request',
                deviceId: deviceId,
                targetFriendCode: code
            }));
        }

        function respondToFriendRequest(fromDeviceId, accept) {
            if (!socialSocket || socialSocket.readyState !== WebSocket.OPEN) return;

            socialSocket.send(JSON.stringify({
                type: 'respond_friend_request',
                deviceId: deviceId,
                fromDeviceId: fromDeviceId,
                accept: accept
            }));

            // Remove toast if exists
            const toast = document.getElementById('toast-' + fromDeviceId);
            if (toast) toast.remove();
        }

        function removeFriend(friendDeviceId) {
            if (!socialSocket || socialSocket.readyState !== WebSocket.OPEN) return;

            socialSocket.send(JSON.stringify({
                type: 'remove_friend',
                deviceId: deviceId,
                friendDeviceId: friendDeviceId
            }));
        }

        function updatePendingRequestsUI() {
            const section = document.getElementById('pendingRequestsSection');
            const list = document.getElementById('pendingRequestsList');
            if (!section || !list) return;

            if (pendingRequests.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            list.innerHTML = pendingRequests.map(r => `
                <div style="display: flex; align-items: center; justify-content: space-between; background: rgba(230,126,34,0.1); border: 1px solid rgba(230,126,34,0.3); border-radius: 8px; padding: 8px; margin-bottom: 5px;">
                    <div>
                        <div style="color: white; font-size: 12px; font-weight: bold;">${r.fromUsername}</div>
                        <div style="color: #888; font-size: 10px;">${r.fromFriendCode}</div>
                    </div>
                    <div style="display: flex; gap: 5px;">
                        <button onclick="respondToFriendRequest('${r.fromDeviceId}', true)" style="background: #2ecc71; color: white; border: none; border-radius: 5px; padding: 4px 10px; font-size: 11px; cursor: pointer;">Accept</button>
                        <button onclick="respondToFriendRequest('${r.fromDeviceId}', false)" style="background: #e74c3c; color: white; border: none; border-radius: 5px; padding: 4px 10px; font-size: 11px; cursor: pointer;">Decline</button>
                    </div>
                </div>
            `).join('');
        }

        function updateFriendsListUI() {
            const container = document.getElementById('friendsListContainer');
            if (!container) return;

            if (friendsList.length === 0) {
                container.innerHTML = '<div style="color: #888; font-size: 12px; text-align: center;">No friends yet. Add someone using their friend code!</div>';
                return;
            }

            container.innerHTML = friendsList.map(f => `
                <div style="display: flex; align-items: center; justify-content: space-between; background: rgba(46,204,113,0.1); border: 1px solid rgba(46,204,113,0.2); border-radius: 8px; padding: 8px; margin-bottom: 5px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: ${f.online ? '#2ecc71' : '#888'};"></div>
                        <div>
                            <div style="color: white; font-size: 12px; font-weight: bold;">${f.username}</div>
                            <div style="color: #888; font-size: 10px;">${f.friendCode}</div>
                        </div>
                    </div>
                    <button onclick="removeFriend('${f.deviceId}')" style="background: none; border: 1px solid #e74c3c; color: #e74c3c; border-radius: 5px; padding: 3px 8px; font-size: 10px; cursor: pointer;">Remove</button>
                </div>
            `).join('');
        }

        function updateFriendsServersUI() {
            const container = document.getElementById('friendsServersList');
            if (!container) return;

            if (friendsServers.length === 0) {
                container.innerHTML = '<div style="color: #888; font-size: 12px; text-align: center;">No active friends servers.</div>';
                return;
            }

            container.innerHTML = friendsServers.map(s => `
                <div style="display: flex; align-items: center; justify-content: space-between; background: rgba(155,89,182,0.1); border: 1px solid rgba(155,89,182,0.3); border-radius: 8px; padding: 8px; margin-bottom: 5px;">
                    <div>
                        <div style="color: white; font-size: 12px; font-weight: bold;">${s.hostUsername}'s Server</div>
                        <div style="color: #888; font-size: 10px;">Room: ${s.roomId}</div>
                    </div>
                    <button onclick="requestJoinFriendsServer('${s.roomId}')" class="menu-btn" style="padding: 5px 12px; font-size: 11px; background: linear-gradient(135deg, #9b59b6, #8e44ad);">Join</button>
                </div>
            `).join('');
        }

        function createFriendsServer() {
            if (!socialSocket || socialSocket.readyState !== WebSocket.OPEN) {
                showNotification('Not connected to social server.', '#ff4444');
                return;
            }

            socialSocket.send(JSON.stringify({
                type: 'create_friends_server',
                deviceId: deviceId
            }));
        }

        function requestJoinFriendsServer(roomId) {
            if (!socialSocket || socialSocket.readyState !== WebSocket.OPEN) {
                showNotification('Not connected to social server.', '#ff4444');
                return;
            }

            socialSocket.send(JSON.stringify({
                type: 'validate_join',
                deviceId: deviceId,
                roomId: roomId
            }));
        }

        function joinFriendsServer(wsUrl) {
            closeFriendsPanel();
            document.getElementById('menu').style.display = 'none';
            document.getElementById('multiplayerLobby').style.display = 'flex';
            document.getElementById('retryConnectionBtn').style.display = 'none';
            document.getElementById('connectionSpinner').style.display = 'block';
            connectionAttempts = 0;
            isRetrying = false;
            attemptConnection(wsUrl);
        }

        function showFriendRequestToast(fromUsername, fromFriendCode, fromDeviceId) {
            const container = document.getElementById('notificationContainer');
            if (!container) return;

            const toast = document.createElement('div');
            toast.id = 'toast-' + fromDeviceId;
            toast.className = 'friend-request-toast';
            toast.style.pointerEvents = 'auto';
            toast.innerHTML = `
                <div style="font-size: 12px; font-weight: bold; color: #3498db; margin-bottom: 4px;">Friend Request</div>
                <div style="font-size: 11px; color: white; margin-bottom: 2px;">${fromUsername}</div>
                <div style="font-size: 10px; color: #888; margin-bottom: 8px;">${fromFriendCode}</div>
                <div style="display: flex; gap: 5px;">
                    <button onclick="respondToFriendRequest('${fromDeviceId}', true)" style="background: #2ecc71; color: white; border: none; border-radius: 5px; padding: 4px 12px; font-size: 11px; cursor: pointer;">Accept</button>
                    <button onclick="respondToFriendRequest('${fromDeviceId}', false)" style="background: #e74c3c; color: white; border: none; border-radius: 5px; padding: 4px 12px; font-size: 11px; cursor: pointer;">Decline</button>
                </div>
            `;
            container.appendChild(toast);

            // Auto-remove after 30 seconds
            setTimeout(() => { if (toast.parentNode) toast.remove(); }, 30000);
        }

        function showNotification(message, color) {
            const container = document.getElementById('notificationContainer');
            if (!container) return;

            const toast = document.createElement('div');
            toast.className = 'notification-toast';
            toast.style.pointerEvents = 'none';
            toast.innerHTML = `<div style="font-size: 12px; color: ${color || '#fff'};">${message}</div>`;
            container.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }

        // ========== DOB AGE GATE ==========

        function initDobDropdowns() {
            const monthSelect = document.getElementById('dobMonth');
            const daySelect = document.getElementById('dobDay');
            const yearSelect = document.getElementById('dobYear');

            const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
            months.forEach((m, i) => {
                const opt = document.createElement('option');
                opt.value = i + 1;
                opt.textContent = m;
                monthSelect.appendChild(opt);
            });

            for (let d = 1; d <= 31; d++) {
                const opt = document.createElement('option');
                opt.value = d;
                opt.textContent = d;
                daySelect.appendChild(opt);
            }

            const currentYear = new Date().getFullYear();
            for (let y = currentYear; y >= currentYear - 100; y--) {
                const opt = document.createElement('option');
                opt.value = y;
                opt.textContent = y;
                yearSelect.appendChild(opt);
            }
        }

        function openDobModal() {
            initDobDropdowns();
            document.getElementById('dobModal').style.display = 'flex';
            document.getElementById('dobError').style.display = 'none';
        }

        function closeDobModal() {
            document.getElementById('dobModal').style.display = 'none';
        }

        function submitDobVerification() {
            const month = parseInt(document.getElementById('dobMonth').value);
            const day = parseInt(document.getElementById('dobDay').value);
            const year = parseInt(document.getElementById('dobYear').value);

            if (!month || !day || !year) {
                document.getElementById('dobError').textContent = 'Please fill in all fields.';
                document.getElementById('dobError').style.display = 'block';
                return;
            }

            const dob = new Date(year, month - 1, day);
            const today = new Date();
            let age = today.getFullYear() - dob.getFullYear();
            const monthDiff = today.getMonth() - dob.getMonth();
            if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < dob.getDate())) {
                age--;
            }

            if (age < 13) {
                setCookie('voiceChatAge', 'under13');
                document.getElementById('dobError').textContent = 'You must be 13 or older to use voice chat.';
                document.getElementById('dobError').style.display = 'block';
                const voiceBtn = document.getElementById('voiceChatBtn');
                if (voiceBtn) voiceBtn.style.display = 'none';
                setTimeout(() => closeDobModal(), 2000);
                return;
            }

            setCookie('voiceChatAge', 'verified');
            closeDobModal();
            enableVoiceChat();
        }

        // ========== VOICE CHAT ==========

        function toggleVoiceChat() {
            if (voiceChatEnabled) {
                disableVoiceChat();
            } else {
                // Check age verification
                const ageStatus = getCookie('voiceChatAge');
                if (ageStatus === 'under13') {
                    showNotification('Voice chat is not available.', '#ff4444');
                    return;
                }
                if (ageStatus !== 'verified') {
                    openDobModal();
                    return;
                }
                enableVoiceChat();
            }
        }

        async function enableVoiceChat() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                voiceChatEnabled = true;
                voiceChatMuted = false;
                updateVoiceChatButton();

                // Set up audio monitoring for speaking indicator
                audioContextVoice = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContextVoice.createMediaStreamSource(localStream);
                localAnalyser = audioContextVoice.createAnalyser();
                localAnalyser.fftSize = 256;
                source.connect(localAnalyser);

                // Create peer connections to all existing remote players
                for (const playerId in remotePlayers) {
                    createPeerConnection(playerId, true);
                }

                monitorAudioLevel();
            } catch (e) {
                console.error('Failed to enable voice chat:', e);
                showNotification('Could not access microphone.', '#ff4444');
            }
        }

        function disableVoiceChat() {
            voiceChatEnabled = false;
            voiceChatMuted = false;

            // Stop local stream
            if (localStream) {
                localStream.getTracks().forEach(t => t.stop());
                localStream = null;
            }

            // Close all peer connections
            for (const playerId in peerConnections) {
                if (peerConnections[playerId]) {
                    peerConnections[playerId].close();
                }
            }
            peerConnections = {};

            // Close audio context
            if (audioContextVoice) {
                audioContextVoice.close();
                audioContextVoice = null;
            }
            localAnalyser = null;

            updateVoiceChatButton();
            clearVoiceIndicators();
        }

        function toggleMic() {
            if (!voiceChatEnabled || !localStream) return;
            voiceChatMuted = !voiceChatMuted;
            localStream.getAudioTracks().forEach(t => { t.enabled = !voiceChatMuted; });
            updateVoiceChatButton();
        }

        function updateVoiceChatButton() {
            const btn = document.getElementById('voiceChatBtn');
            if (!btn) return;

            if (!voiceChatEnabled) {
                btn.textContent = 'üé§';
                btn.className = 'voice-chat-btn';
            } else if (voiceChatMuted) {
                btn.textContent = 'üîá';
                btn.className = 'voice-chat-btn voice-muted';
                btn.onclick = toggleMic;
            } else {
                btn.textContent = 'üé§';
                btn.className = 'voice-chat-btn voice-active';
                btn.onclick = toggleMic;
            }
        }

        function createPeerConnection(playerId, isInitiator) {
            if (peerConnections[playerId]) return;

            const pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            });

            peerConnections[playerId] = pc;

            // Add local stream tracks
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });
            }

            // Handle incoming audio
            pc.ontrack = (event) => {
                const audio = new Audio();
                audio.srcObject = event.streams[0];
                audio.play();

                // Monitor remote audio level
                monitorRemoteAudio(playerId, event.streams[0]);
            };

            // ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate && multiplayerSocket && multiplayerSocket.readyState === WebSocket.OPEN) {
                    multiplayerSocket.send(JSON.stringify({
                        type: 'voice_ice_candidate',
                        targetId: playerId,
                        candidate: event.candidate
                    }));
                }
            };

            pc.onconnectionstatechange = () => {
                if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                    pc.close();
                    delete peerConnections[playerId];
                }
            };

            // If initiator, create offer
            if (isInitiator) {
                pc.createOffer().then(offer => {
                    return pc.setLocalDescription(offer);
                }).then(() => {
                    if (multiplayerSocket && multiplayerSocket.readyState === WebSocket.OPEN) {
                        multiplayerSocket.send(JSON.stringify({
                            type: 'voice_offer',
                            targetId: playerId,
                            sdp: pc.localDescription
                        }));
                    }
                }).catch(e => console.error('Offer creation failed:', e));
            }
        }

        function handleVoiceOffer(senderId, sdp) {
            if (!voiceChatEnabled) return;
            createPeerConnection(senderId, false);
            const pc = peerConnections[senderId];
            if (!pc) return;

            pc.setRemoteDescription(new RTCSessionDescription(sdp)).then(() => {
                return pc.createAnswer();
            }).then(answer => {
                return pc.setLocalDescription(answer);
            }).then(() => {
                if (multiplayerSocket && multiplayerSocket.readyState === WebSocket.OPEN) {
                    multiplayerSocket.send(JSON.stringify({
                        type: 'voice_answer',
                        targetId: senderId,
                        sdp: pc.localDescription
                    }));
                }
            }).catch(e => console.error('Answer creation failed:', e));
        }

        function handleVoiceAnswer(senderId, sdp) {
            const pc = peerConnections[senderId];
            if (!pc) return;
            pc.setRemoteDescription(new RTCSessionDescription(sdp))
                .catch(e => console.error('Set remote description failed:', e));
        }

        function handleVoiceIceCandidate(senderId, candidate) {
            const pc = peerConnections[senderId];
            if (!pc) return;
            pc.addIceCandidate(new RTCIceCandidate(candidate))
                .catch(e => console.error('Add ICE candidate failed:', e));
        }

        function monitorAudioLevel() {
            if (!voiceChatEnabled || !localAnalyser) return;

            const data = new Uint8Array(localAnalyser.frequencyBinCount);
            localAnalyser.getByteFrequencyData(data);
            const avg = data.reduce((a, b) => a + b, 0) / data.length;

            const btn = document.getElementById('voiceChatBtn');
            if (btn && voiceChatEnabled && !voiceChatMuted) {
                if (avg > 30) {
                    btn.style.boxShadow = '0 0 15px rgba(46, 204, 113, 0.8)';
                } else {
                    btn.style.boxShadow = '';
                }
            }

            requestAnimationFrame(monitorAudioLevel);
        }

        function monitorRemoteAudio(playerId, stream) {
            if (!audioContextVoice) return;

            const source = audioContextVoice.createMediaStreamSource(stream);
            const analyser = audioContextVoice.createAnalyser();
            analyser.fftSize = 256;
            source.connect(analyser);

            function check() {
                if (!peerConnections[playerId]) return;

                const data = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(data);
                const avg = data.reduce((a, b) => a + b, 0) / data.length;

                updateVoiceIndicator(playerId, avg > 30);
                requestAnimationFrame(check);
            }
            check();
        }

        function updateVoiceIndicator(playerId, isSpeaking) {
            const container = document.getElementById('voiceIndicators');
            if (!container) return;

            let indicator = document.getElementById('voice-ind-' + playerId);
            const player = remotePlayers[playerId];
            const name = player ? player.name : playerId.slice(0, 6);

            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'voice-ind-' + playerId;
                indicator.style.cssText = 'background: rgba(0,0,0,0.7); padding: 3px 8px; border-radius: 4px; font-size: 11px; display: flex; align-items: center; gap: 5px;';
                indicator.innerHTML = `<span class="voice-dot"></span><span style="color: white;">${name}</span>`;
                container.appendChild(indicator);
            }

            const dot = indicator.querySelector('.voice-dot');
            if (dot) {
                dot.style.cssText = `width: 8px; height: 8px; border-radius: 50%; background: ${isSpeaking ? '#2ecc71' : '#888'}; transition: background 0.2s;`;
            }
        }

        function clearVoiceIndicators() {
            const container = document.getElementById('voiceIndicators');
            if (container) container.innerHTML = '';
        }

        // ========== END MULTIPLAYER FUNCTIONS ==========

        function startGame() {
            enterFullscreen();
            renderer.domElement.style.display = 'block';
            document.getElementById('menu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('coinsDisplay').style.display = 'block';
            document.getElementById('statsPanel').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('hotbar').style.display = 'flex';

            setupInput();

            if (deviceMode === 'mobile') {
                document.getElementById('mobileControls').style.display = 'block';
            } else {
                // Request pointer lock - if it fails, user can click canvas to lock
                renderer.domElement.requestPointerLock();
            }

            gameRunning = true;
            startWave();
        }
        
        function restartGame() {
            playerState.position.set(0, 1.7, 0);
            playerState.velocity.set(0, 0, 0);
            playerState.rotation = { x: 0, y: 0 };
            playerState.health = playerState.maxHealth;
            playerState.energy = playerState.maxEnergy;
            playerState.score = 0;
            playerState.kills = 0;
            playerState.isGrounded = true;
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];
            
            if (boss) { scene.remove(boss.mesh); boss = null; }
            document.getElementById('bossHealth').style.display = 'none';
            
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles = [];

            particles.forEach(p => scene.remove(p.mesh));
            particles = [];

            coins.forEach(c => scene.remove(c.mesh));
            coins = [];

            itemCooldowns = {};
            currentWave = 1;
            waveInProgress = false;
            
            document.getElementById('gameOver').style.display = 'none';
            gameRunning = true;
            startWave();
        }
        
        function backToMenu() {
            gameRunning = false;
            renderer.domElement.style.display = 'none';
            if (document.exitPointerLock) document.exitPointerLock();
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('menu').style.display = 'flex';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('coinsDisplay').style.display = 'none';
            document.getElementById('statsPanel').style.display = 'none';
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('hotbar').style.display = 'none';
            document.getElementById('mobileControls').style.display = 'none';

            document.getElementById('menuCoins').textContent = 'üí∞ ' + inventory.coins;
            saveCoinsToCloud(); // Save coins when returning to menu
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];
            if (boss) { scene.remove(boss.mesh); boss = null; }
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles = [];
            coins.forEach(c => scene.remove(c.mesh));
            coins = [];
            
            currentWave = 1;
            waveInProgress = false;
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Update post-processing on resize
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
            if (fxaaPass) {
                fxaaPass.material.uniforms['resolution'].value.x = 1 / (window.innerWidth * renderer.getPixelRatio());
                fxaaPass.material.uniforms['resolution'].value.y = 1 / (window.innerHeight * renderer.getPixelRatio());
            }
        });
        
        init();
        initDeviceMode();
        checkPaymentSuccess();
        gameLoop(0);

        // Hide menu initially and start auth flow
        document.getElementById('menu').style.display = 'none';
        tryAutoLogin();
    </script>
</body>
</html>
