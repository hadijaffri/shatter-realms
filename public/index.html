<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ShatterRealms - Realism Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        body {
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #hud {
            position: fixed;
            bottom: 100px;
            left: 15px;
            pointer-events: none;
            z-index: 100;
        }
        
        .bar-container {
            width: 180px;
            height: 18px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 9px;
            margin-bottom: 5px;
            overflow: hidden;
            position: relative;
        }
        
        .bar-fill { height: 100%; transition: width 0.3s ease; }
        #healthBar .bar-fill { background: linear-gradient(90deg, #8b0000, #ff3333); }
        #energyBar .bar-fill { background: linear-gradient(90deg, #003366, #0088ff); }
        
        .bar-text {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9);
        }
        
        .bar-icon {
            position: absolute;
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 11px;
        }
        
        #coinsDisplay {
            position: fixed;
            top: 15px;
            right: 130px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid gold;
            border-radius: 15px;
            padding: 5px 12px;
            color: gold;
            font-size: 14px;
            font-weight: bold;
            z-index: 100;
        }
        
        #statsPanel {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 8px;
            color: white;
            font-size: 10px;
            z-index: 100;
        }
        
        .stat-label { color: #aaa; font-size: 8px; }
        .stat-value { color: #fff; font-weight: bold; font-size: 12px; }
        
        #hotbar {
            position: fixed;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 3px;
            z-index: 110;
            pointer-events: auto;
        }
        
        .hotbar-slot {
            width: 45px;
            height: 45px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        }
        
        .hotbar-slot.selected {
            border-color: #ffcc00;
            box-shadow: 0 0 8px rgba(255, 200, 0, 0.5);
        }
        
        .hotbar-slot .item-icon { font-size: 18px; }
        .hotbar-slot .item-name { font-size: 6px; color: #aaa; }
        .hotbar-slot .slot-key {
            position: absolute;
            top: 1px; left: 3px;
            font-size: 8px;
            color: #888;
        }
        
        .hotbar-slot .cooldown-overlay {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 10px;
            text-align: center;
            display: none;
        }
        
        #minimap {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 90px;
            height: 90px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            overflow: hidden;
            z-index: 100;
        }
        
        #crosshair {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            width: 16px; height: 16px;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
        }
        
        #crosshair::before { width: 12px; height: 2px; top: 7px; left: 2px; }
        #crosshair::after { width: 2px; height: 12px; top: 2px; left: 7px; }
        
        #waveAnnounce {
            position: fixed;
            top: 25%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 20px rgba(255, 100, 100, 0.8);
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 200;
            pointer-events: none;
        }
        
        #bossHealth {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            display: none;
            z-index: 100;
        }
        
        #bossName {
            text-align: center;
            color: #ff4444;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        #bossBarContainer {
            height: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff4444;
            border-radius: 6px;
            overflow: hidden;
        }
        
        #bossFill {
            height: 100%;
            background: linear-gradient(90deg, #660000, #ff0000);
            width: 100%;
            transition: width 0.3s;
        }
        
        #menu {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a1a2a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        #menu h1 {
            font-size: 42px;
            color: #fff;
            text-shadow: 0 0 40px rgba(100, 200, 255, 0.8);
            margin-bottom: 5px;
        }
        
        #menu h2 {
            font-size: 14px;
            color: #88ccff;
            margin-bottom: 20px;
            font-weight: normal;
        }
        
        .menu-btn {
            padding: 10px 30px;
            font-size: 14px;
            background: linear-gradient(135deg, #4a00e0, #8e2de2);
            border: none;
            border-radius: 18px;
            color: white;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }
        
        .menu-btn:hover { transform: scale(1.05); }
        .menu-btn.shop-btn { background: linear-gradient(135deg, #f39c12, #e74c3c); }
        .menu-btn.settings-btn { background: linear-gradient(135deg, #27ae60, #2ecc71); }
        .menu-btn.quit-btn { background: linear-gradient(135deg, #636e72, #2d3436); }
        
        .panel {
            display: none;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 30, 0.98);
            border: 3px solid #8e2de2;
            border-radius: 15px;
            z-index: 1001;
            width: 90%;
            max-width: 450px;
            max-height: 75vh;
            overflow: hidden;
            flex-direction: column;
        }
        
        .panel-header {
            padding: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .panel-header h2 { color: gold; margin: 0; font-size: 18px; }
        
        .panel-content {
            padding: 12px;
            overflow-y: auto;
            flex: 1;
            -webkit-overflow-scrolling: touch;
        }
        
        .close-btn {
            font-size: 22px;
            color: white;
            cursor: pointer;
            background: none;
            border: none;
            padding: 5px 10px;
        }
        
        #shopPanel { border-color: #f39c12; }
        #shopPanel .panel-header h2 { color: #f39c12; }
        
        .shop-item {
            display: flex;
            align-items: center;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 8px;
            margin: 6px 0;
            gap: 8px;
        }
        
        .shop-item-icon { font-size: 24px; }
        .shop-item-info { flex: 1; }
        .shop-item-name { color: white; font-weight: bold; font-size: 12px; }
        .shop-item-desc { color: #888; font-size: 10px; }
        .shop-item-price { color: gold; font-weight: bold; font-size: 12px; margin-right: 8px; }
        
        .shop-buy-btn {
            padding: 5px 12px;
            background: linear-gradient(135deg, #f39c12, #e67e22);
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-size: 11px;
        }
        
        .shop-buy-btn:disabled { background: #444; cursor: not-allowed; }
        
        #settingsPanel { border-color: #27ae60; }
        #settingsPanel .panel-header h2 { color: #2ecc71; }
        
        .settings-category { margin-bottom: 12px; }
        
        .settings-category-title {
            color: #8e2de2;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(142, 45, 226, 0.3);
        }
        
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .setting-label { color: #ccc; font-size: 11px; }
        
        .toggle-switch {
            width: 40px;
            height: 20px;
            background: #444;
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.3s;
            flex-shrink: 0;
        }
        
        .toggle-switch.on { background: #2ecc71; }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px; height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px; left: 2px;
            transition: left 0.3s;
        }
        
        .toggle-switch.on::after { left: 22px; }
        
        .slider-container { display: flex; align-items: center; gap: 6px; }
        
        .slider {
            width: 70px;
            height: 5px;
            -webkit-appearance: none;
            background: #444;
            border-radius: 3px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px; height: 12px;
            background: #2ecc71;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider-value { color: #2ecc71; font-size: 10px; min-width: 25px; }
        
        #mobileControls {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #joystickZone {
            position: absolute;
            bottom: 25px;
            left: 25px;
            width: 130px;
            height: 130px;
            pointer-events: none;
            z-index: 60;
        }
        
        #joystickBase {
            width: 110px;
            height: 110px;
            background: rgba(255, 255, 255, 0.12);
            border: 3px solid rgba(255, 255, 255, 0.25);
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #joystickKnob {
            width: 45px;
            height: 45px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.25));
            border-radius: 50%;
            position: absolute;
            will-change: transform;
        }
        
        .mobile-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 20px;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 60;
        }
        
        #attackBtn {
            bottom: 70px;
            right: 20px;
            width: 65px;
            height: 65px;
            font-size: 26px;
            background: rgba(255, 50, 50, 0.15);
            border-color: rgba(255, 100, 100, 0.3);
        }
        
        #jumpBtn {
            bottom: 155px;
            right: 20px;
            background: rgba(100, 200, 255, 0.15);
            border-color: rgba(150, 220, 255, 0.3);
        }
        
        #dashBtn {
            bottom: 70px;
            right: 105px;
            background: rgba(50, 150, 255, 0.15);
            border-color: rgba(100, 180, 255, 0.3);
        }
        
        .damage-number {
            position: fixed;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
            z-index: 150;
            animation: floatUp 1s forwards;
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-35px) scale(0.5); }
        }
        
        .coin-pickup {
            position: fixed;
            color: gold;
            font-weight: bold;
            font-size: 14px;
            pointer-events: none;
            animation: coinFloat 1s forwards;
            z-index: 150;
        }
        
        @keyframes coinFloat {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        
        #gameOver {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        #gameOver h1 { font-size: 38px; color: #ff4444; margin-bottom: 12px; }
        #gameOver p { color: #fff; font-size: 14px; margin: 4px 0; }
        
        .mobile-mode #hud { bottom: 150px; left: 8px; }
        .mobile-mode .bar-container { width: 140px; height: 16px; }
        .mobile-mode #hotbar { bottom: 75px; transform: translateX(-50%) scale(0.8); }

        /* Multiplayer UI */
        #modeSelect {
            display: none;
            text-align: center;
        }

        #modeSelect p {
            color: #aaa;
            margin-bottom: 15px;
        }

        .mode-btn {
            padding: 15px 40px;
            font-size: 16px;
            background: linear-gradient(135deg, #4a00e0, #8e2de2);
            border: none;
            border-radius: 20px;
            color: white;
            cursor: pointer;
            margin: 8px;
            transition: all 0.3s;
        }

        .mode-btn:hover { transform: scale(1.05); }
        .mode-btn.multiplayer { background: linear-gradient(135deg, #e74c3c, #c0392b); }

        #matchTimer {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff4444;
            border-radius: 15px;
            padding: 8px 20px;
            color: #ff4444;
            font-size: 24px;
            font-weight: bold;
            z-index: 100;
            display: none;
        }

        #scoreboard {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #8e2de2;
            border-radius: 15px;
            padding: 20px;
            z-index: 500;
            display: none;
            min-width: 350px;
        }

        #scoreboard h2 {
            color: gold;
            text-align: center;
            margin-bottom: 15px;
        }

        .scoreboard-header {
            display: flex;
            justify-content: space-between;
            padding: 8px 15px;
            color: #888;
            font-size: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .scoreboard-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 15px;
            color: white;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .scoreboard-row.me {
            background: rgba(142, 45, 226, 0.3);
        }

        .scoreboard-row.winner {
            background: rgba(255, 215, 0, 0.2);
            color: gold;
        }

        .player-name { flex: 2; }
        .player-kills, .player-deaths { flex: 1; text-align: center; }

        #lobbyScreen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a1a2a 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #lobbyScreen h2 {
            color: #fff;
            font-size: 28px;
            margin-bottom: 20px;
        }

        #lobbyPlayers {
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 15px;
            min-width: 300px;
            margin-bottom: 20px;
        }

        .lobby-player {
            color: white;
            padding: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        #lobbyStatus {
            color: #88ccff;
            font-size: 14px;
            margin-bottom: 20px;
        }

        #matchEndScreen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #matchEndScreen h1 {
            font-size: 42px;
            color: gold;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        #matchEndScreen .winner-name {
            font-size: 24px;
            color: #fff;
            margin-bottom: 20px;
        }

        #matchEndScreen .reward {
            font-size: 18px;
            color: gold;
            margin-bottom: 20px;
        }

        .other-player-nameplate {
            position: absolute;
            color: white;
            font-size: 12px;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9);
            pointer-events: none;
        }

        .other-player-healthbar {
            width: 60px;
            height: 6px;
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 3px;
            margin: 3px auto;
            overflow: hidden;
        }

        .other-player-healthbar-fill {
            height: 100%;
            background: linear-gradient(90deg, #8b0000, #ff3333);
            transition: width 0.3s ease;
        }

        #killFeed {
            position: fixed;
            top: 80px;
            right: 15px;
            z-index: 100;
            display: none;
        }

        .kill-message {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            margin-bottom: 5px;
            font-size: 12px;
            animation: fadeOut 3s forwards;
        }

        @keyframes fadeOut {
            0%, 70% { opacity: 1; }
            100% { opacity: 0; }
        }

        #respawnTimer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ff4444;
            text-shadow: 0 0 20px rgba(255, 68, 68, 0.8);
            z-index: 200;
            display: none;
        }
    </style>
</head>
<body>
    <div id="menu">
        <h1>SHATTERREALMS</h1>
        <h2>Realism Edition</h2>
        <div id="deviceSelect">
            <p style="color: #aaa; margin-bottom: 15px;">Select your device:</p>
            <button class="menu-btn" onclick="selectDevice('computer')">üñ•Ô∏è Computer</button>
            <button class="menu-btn" onclick="selectDevice('mobile')">üì± Mobile</button>
        </div>
        <div id="modeSelect">
            <p>Select Game Mode</p>
            <button class="mode-btn" onclick="selectMode('singleplayer')">üéÆ Singleplayer</button>
            <button class="mode-btn multiplayer" onclick="selectMode('multiplayer')">‚öîÔ∏è Multiplayer</button>
        </div>
        <div id="startSection" style="display: none;">
            <button class="menu-btn" onclick="startGame()">‚öîÔ∏è Play</button>
            <button class="menu-btn shop-btn" onclick="openShop()">üõí Shop</button>
            <button class="menu-btn settings-btn" onclick="openSettings()">‚öôÔ∏è Settings</button>
            <button class="menu-btn quit-btn" onclick="quitGame()">üö™ Quit</button>
            <div id="menuCoins" style="color: gold; margin-top: 12px; font-size: 16px;">üí∞ 0</div>
        </div>
    </div>
    
    <div id="shopPanel" class="panel">
        <div class="panel-header">
            <h2>üõí SHOP</h2>
            <button class="close-btn" onclick="closeShop()">‚úï</button>
        </div>
        <div class="panel-content" id="shopItems"></div>
    </div>
    
    <div id="settingsPanel" class="panel">
        <div class="panel-header">
            <h2>‚öôÔ∏è SETTINGS</h2>
            <button class="close-btn" onclick="closeSettings()">‚úï</button>
        </div>
        <div class="panel-content" id="settingsContent"></div>
    </div>
    
    <div id="mobileControls">
        <div id="joystickZone">
            <div id="joystickBase">
                <div id="joystickKnob"></div>
            </div>
        </div>
        <button id="attackBtn" class="mobile-btn">‚öîÔ∏è</button>
        <button id="jumpBtn" class="mobile-btn">‚¨ÜÔ∏è</button>
        <button id="dashBtn" class="mobile-btn">üí®</button>
    </div>
    
    <div id="hud" style="display: none;">
        <div id="healthBar" class="bar-container">
            <span class="bar-icon">‚ù§Ô∏è</span>
            <div class="bar-fill" style="width: 100%"></div>
            <span class="bar-text">100 / 100</span>
        </div>
        <div id="energyBar" class="bar-container">
            <span class="bar-icon">‚ö°</span>
            <div class="bar-fill" style="width: 100%"></div>
            <span class="bar-text">100 / 100</span>
        </div>
    </div>
    
    <div id="coinsDisplay" style="display: none;">üí∞ 0</div>
    
    <div id="statsPanel" style="display: none;">
        <div><span class="stat-label">WAVE</span><br><span class="stat-value" id="waveNum">1</span></div>
        <div style="margin-top:5px;"><span class="stat-label">SCORE</span><br><span class="stat-value" id="score">0</span></div>
    </div>
    
    <div id="minimap" style="display: none;"><canvas id="minimapCanvas"></canvas></div>
    <div id="crosshair" style="display: none;"></div>
    <div id="hotbar" style="display: none;"></div>
    <div id="waveAnnounce"></div>
    <div id="clickToPlay" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 10px; font-size: 18px; z-index: 200; pointer-events: none;">Click to enable mouse controls</div>
    
    <div id="bossHealth">
        <div id="bossName">BOSS</div>
        <div id="bossBarContainer"><div id="bossFill"></div></div>
    </div>
    
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p>Wave: <span id="finalWave">1</span></p>
        <p>Score: <span id="finalScore">0</span></p>
        <p>Coins: <span id="finalCoins">0</span></p>
        <button class="menu-btn" onclick="restartGame()">‚öîÔ∏è Retry</button>
        <button class="menu-btn" onclick="backToMenu()">üè† Menu</button>
    </div>

    <!-- Multiplayer UI -->
    <div id="matchTimer">5:00</div>

    <div id="scoreboard">
        <h2>SCOREBOARD</h2>
        <div class="scoreboard-header">
            <span class="player-name">Player</span>
            <span class="player-kills">Kills</span>
            <span class="player-deaths">Deaths</span>
        </div>
        <div id="scoreboardContent"></div>
    </div>

    <div id="lobbyScreen">
        <h2>MULTIPLAYER LOBBY</h2>
        <div id="lobbyPlayers">
            <div class="lobby-player">Waiting for players...</div>
        </div>
        <div id="lobbyStatus">Connecting...</div>
        <button class="menu-btn" onclick="leaveLobby()">Leave</button>
    </div>

    <div id="matchEndScreen">
        <h1>MATCH OVER</h1>
        <div class="winner-name" id="winnerName">Winner: Player</div>
        <div class="reward" id="rewardText"></div>
        <div id="finalScoreboard"></div>
        <button class="menu-btn" onclick="playAgainMultiplayer()">Play Again</button>
        <button class="menu-btn quit-btn" onclick="backToMenuFromMultiplayer()">Back to Menu</button>
    </div>

    <div id="killFeed"></div>
    <div id="respawnTimer"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        let scene, camera, renderer, player;
        let gameRunning = false;
        let enemies = [];
        let projectiles = [];
        let coins = [];
        let colliders = [];
        let buildings = [];
        let boss = null;
        let deviceMode = 'computer';
        let playerState = null;
        let swordMesh = null;
        let swordSwinging = false;
        let swordSwingTime = 0;

        // Particle system
        let particles = [];

        // Particle creation functions
        function createParticles(position, color, count, speed, size, lifetime, spread = 1) {
            for (let i = 0; i < count; i++) {
                const geo = new THREE.SphereGeometry(size * (0.5 + Math.random() * 0.5), 6, 6);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);

                // Random velocity
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.3) * spread,
                    (Math.random() - 0.5) * spread
                ).normalize().multiplyScalar(speed * (0.5 + Math.random() * 0.5));

                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: lifetime,
                    maxLife: lifetime,
                    gravity: 0.0003,
                    shrink: true
                });
            }
        }

        function createSparkParticles(position, color, count) {
            for (let i = 0; i < count; i++) {
                const geo = new THREE.BoxGeometry(0.02, 0.15, 0.02);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);

                const angle = Math.random() * Math.PI * 2;
                const upAngle = Math.random() * Math.PI * 0.5;
                const speed = 0.05 + Math.random() * 0.1;

                const velocity = new THREE.Vector3(
                    Math.cos(angle) * Math.sin(upAngle) * speed,
                    Math.cos(upAngle) * speed,
                    Math.sin(angle) * Math.sin(upAngle) * speed
                );

                particle.lookAt(particle.position.clone().add(velocity));

                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: 400 + Math.random() * 300,
                    maxLife: 700,
                    gravity: 0.0008,
                    shrink: false,
                    trail: true
                });
            }
        }

        function createMagicParticles(position, color, count, size = 0.08) {
            for (let i = 0; i < count; i++) {
                const geo = new THREE.OctahedronGeometry(size * (0.6 + Math.random() * 0.4), 0);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });
                const particle = new THREE.Mesh(geo, mat);

                // Spiral outward pattern
                const angle = (i / count) * Math.PI * 2 + Math.random() * 0.5;
                const radius = 0.2 + Math.random() * 0.3;
                particle.position.copy(position);
                particle.position.x += Math.cos(angle) * radius;
                particle.position.z += Math.sin(angle) * radius;
                particle.position.y += (Math.random() - 0.5) * 0.5;

                const velocity = new THREE.Vector3(
                    Math.cos(angle) * 0.02,
                    0.02 + Math.random() * 0.03,
                    Math.sin(angle) * 0.02
                );

                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: 600 + Math.random() * 400,
                    maxLife: 1000,
                    gravity: -0.0001, // Float upward
                    shrink: true,
                    spin: true,
                    spinSpeed: 0.05 + Math.random() * 0.05
                });
            }
        }

        function createExplosionParticles(position, color, secondaryColor) {
            // Core explosion particles
            createParticles(position, color, 25, 0.15, 0.12, 500, 2);
            // Secondary colored particles
            createParticles(position, secondaryColor, 15, 0.12, 0.08, 400, 1.5);
            // Spark trails
            createSparkParticles(position, 0xffff00, 12);
            // Smoke
            createParticles(position, 0x444444, 10, 0.03, 0.2, 800, 0.8);
        }

        function createHitParticles(position, color) {
            createParticles(position, color, 8, 0.06, 0.05, 300, 0.8);
            createSparkParticles(position, 0xffffff, 5);
        }

        function createDeathParticles(position, color) {
            createParticles(position, color, 30, 0.08, 0.1, 600, 1.5);
            createMagicParticles(position, 0xff0000, 15, 0.06);
            createParticles(position, 0x220000, 20, 0.04, 0.15, 800, 1);
        }

        function createSlashParticles(position, direction, color) {
            for (let i = 0; i < 12; i++) {
                const geo = new THREE.PlaneGeometry(0.04, 0.25);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);

                // Arc pattern
                const arcAngle = (i / 12) * Math.PI - Math.PI / 2;
                const offset = new THREE.Vector3(
                    Math.cos(arcAngle) * 0.3,
                    Math.sin(arcAngle) * 0.3,
                    0
                );

                // Rotate offset to match direction
                const rotation = Math.atan2(direction.x, direction.z);
                offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation);
                particle.position.add(offset);

                particle.rotation.y = rotation;
                particle.rotation.x = arcAngle;

                const velocity = offset.clone().normalize().multiplyScalar(0.03);

                scene.add(particle);
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: 200 + Math.random() * 100,
                    maxLife: 300,
                    gravity: 0,
                    shrink: true
                });
            }
        }

        function createProjectileTrail(position, color) {
            const geo = new THREE.SphereGeometry(0.06, 4, 4);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6
            });
            const particle = new THREE.Mesh(geo, mat);
            particle.position.copy(position);

            scene.add(particle);
            particles.push({
                mesh: particle,
                velocity: new THREE.Vector3(0, 0.005, 0),
                life: 150,
                maxLife: 150,
                gravity: 0,
                shrink: true
            });
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];

                // Update position
                p.mesh.position.add(p.velocity.clone().multiplyScalar(dt / 16));

                // Apply gravity
                p.velocity.y -= p.gravity * dt;

                // Update life
                p.life -= dt;
                const lifeRatio = p.life / p.maxLife;

                // Fade out
                p.mesh.material.opacity = lifeRatio;

                // Shrink
                if (p.shrink) {
                    const scale = 0.3 + lifeRatio * 0.7;
                    p.mesh.scale.setScalar(scale);
                }

                // Spin
                if (p.spin) {
                    p.mesh.rotation.x += p.spinSpeed;
                    p.mesh.rotation.y += p.spinSpeed * 0.7;
                }

                // Remove dead particles
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        // Settings
        const settings = {
            autoJump: false,
            autoCollectCoins: true,
            walkSpeed: 30,
            sprintSpeed: 30,
            sensitivity: 50,
            invertY: false,
            showDamageNumbers: true,
            showMinimap: true
        };
        
        // Inventory
        const inventory = { coins: 100, ownedItems: ['sword', 'fireball'] };

        // ============ COOKIE PERSISTENCE ============
        function setCookie(name, value, days = 365) {
            const expires = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toUTCString();
            document.cookie = `${name}=${encodeURIComponent(JSON.stringify(value))}; expires=${expires}; path=/; SameSite=Lax`;
        }

        function getCookie(name) {
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [cookieName, cookieValue] = cookie.trim().split('=');
                if (cookieName === name) {
                    try {
                        return JSON.parse(decodeURIComponent(cookieValue));
                    } catch (e) {
                        return null;
                    }
                }
            }
            return null;
        }

        function loadFromCookies() {
            const data = getCookie('shatterrealms_data');
            if (data) {
                if (data.coins !== undefined) inventory.coins = data.coins;
                if (data.ownedItems && data.ownedItems.length > 0) {
                    inventory.ownedItems = data.ownedItems;
                }
                console.log('Loaded from cookies:', data);
                return true;
            }
            return false;
        }

        function saveToCookies() {
            const data = {
                coins: inventory.coins,
                ownedItems: inventory.ownedItems
            };
            setCookie('shatterrealms_data', data);
            console.log('Saved to cookies:', data);
        }

        // ============ CLOUD + COOKIE SAVE FUNCTIONS ============
        async function loadFromCloud() {
            // First try cookies as immediate fallback
            loadFromCookies();

            try {
                const response = await fetch('/api/save');
                const data = await response.json();

                // Merge: prefer cloud data if it has more items or more coins
                const cloudCoins = data.coins || 0;
                const cookieCoins = inventory.coins || 0;
                inventory.coins = Math.max(cloudCoins, cookieCoins);

                if (data.ownedItems && data.ownedItems.length > 0) {
                    // Merge owned items (union of both)
                    const merged = new Set([...inventory.ownedItems, ...data.ownedItems]);
                    inventory.ownedItems = Array.from(merged);
                }

                // Populate hotbar with owned items
                hotbar = [null, null, null, null, null, null];
                for (let i = 0; i < Math.min(inventory.ownedItems.length, 6); i++) {
                    hotbar[i] = inventory.ownedItems[i];
                }
                // Refresh hotbar UI if it exists
                if (document.getElementById('hotbar')) {
                    setupHotbar();
                }

                document.getElementById('menuCoins').textContent = 'üí∞ ' + inventory.coins;
                document.getElementById('coinsDisplay').textContent = 'üí∞ ' + inventory.coins;
                console.log('Loaded from cloud (merged):', inventory);

                // Sync cookies with merged data
                saveToCookies();
            } catch (e) {
                console.log('Could not load from cloud, using cookies/defaults');
            }
        }

        async function saveToCloud() {
            // Always save to cookies first (instant backup)
            saveToCookies();

            try {
                await fetch('/api/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        coins: inventory.coins,
                        ownedItems: inventory.ownedItems
                    })
                });
                console.log('Saved to cloud:', inventory);
            } catch (e) {
                console.log('Could not save to cloud (saved to cookies)');
            }
        }

        // Alias for backward compatibility
        const saveCoinsToCloud = saveToCloud;

        // Load save when page loads
        loadFromCloud();

        // ============ GAME MODE & MULTIPLAYER STATE ============
        let gameMode = 'singleplayer'; // 'singleplayer' or 'multiplayer'
        let partySocket = null;
        let myPlayerId = null;
        let myPlayerName = 'Player_' + Math.random().toString(36).substr(2, 4);
        let otherPlayers = new Map(); // Map of playerId -> { mesh, nameplate, healthbar, data }
        let matchTimeRemaining = 300000; // 5 minutes in ms
        let isInMatch = false;
        let isDead = false;
        let respawnCountdown = 0;
        let pvpStats = { kills: 0, deaths: 0 };
        const PARTYKIT_HOST = "shatterrealmsgame.hadijaffri.partykit.dev"; // Update with your PartyKit deployment

        // Items
        const itemDefs = {
            // === STARTER WEAPONS ===
            sword: { name: 'Sword', icon: '‚öîÔ∏è', type: 'weapon', damage: 25, cooldown: 500, desc: 'Basic melee attack' },
            fireball: { name: 'Fireball', icon: 'üî•', type: 'ability', damage: 40, cooldown: 2000, energy: 15, desc: 'Ranged fire attack' },

            // === MELEE WEAPONS ===
            axe: { name: 'Battle Axe', icon: 'ü™ì', type: 'weapon', damage: 45, cooldown: 800, desc: 'Heavy melee damage' },
            spear: { name: 'Spear', icon: 'üî±', type: 'weapon', damage: 35, cooldown: 600, desc: 'Long reach attack' },
            hammer: { name: 'War Hammer', icon: 'üî®', type: 'weapon', damage: 60, cooldown: 1200, desc: 'Massive damage, slow' },
            dagger: { name: 'Dagger', icon: 'üó°Ô∏è', type: 'weapon', damage: 18, cooldown: 250, desc: 'Fast attack speed' },
            katana: { name: 'Katana', icon: '‚öîÔ∏è', type: 'weapon', damage: 38, cooldown: 400, desc: 'Swift blade strikes' },
            scythe: { name: 'Scythe', icon: 'üåô', type: 'weapon', damage: 55, cooldown: 900, desc: 'Reaper\'s weapon' },
            mace: { name: 'Mace', icon: 'üèè', type: 'weapon', damage: 42, cooldown: 700, desc: 'Crushing blows' },
            flail: { name: 'Flail', icon: '‚õìÔ∏è', type: 'weapon', damage: 48, cooldown: 850, desc: 'Chain weapon' },
            halberd: { name: 'Halberd', icon: 'ü™ì', type: 'weapon', damage: 52, cooldown: 950, desc: 'Polearm attack' },
            claws: { name: 'Wolf Claws', icon: 'üê∫', type: 'weapon', damage: 22, cooldown: 200, desc: 'Rapid slashes' },
            gauntlet: { name: 'Power Gauntlet', icon: 'ü•ä', type: 'weapon', damage: 35, cooldown: 450, desc: 'Punch attack' },
            chainsaw: { name: 'Chainsaw', icon: 'ü™ö', type: 'weapon', damage: 65, cooldown: 300, desc: 'Brutal damage' },
            pickaxe: { name: 'Pickaxe', icon: '‚õèÔ∏è', type: 'weapon', damage: 40, cooldown: 650, desc: 'Mining tool turned weapon' },
            shovel: { name: 'Battle Shovel', icon: 'ü™†', type: 'weapon', damage: 28, cooldown: 500, desc: 'Blunt force' },
            sickle: { name: 'Sickle', icon: 'üåæ', type: 'weapon', damage: 32, cooldown: 350, desc: 'Curved blade' },
            nunchucks: { name: 'Nunchucks', icon: 'ü•¢', type: 'weapon', damage: 26, cooldown: 280, desc: 'Martial arts weapon' },
            bo_staff: { name: 'Bo Staff', icon: 'üéã', type: 'weapon', damage: 30, cooldown: 400, desc: 'Long range melee' },
            whip: { name: 'Whip', icon: '„Ä∞Ô∏è', type: 'weapon', damage: 24, cooldown: 350, desc: 'Long reach' },
            anchor: { name: 'Anchor', icon: '‚öì', type: 'weapon', damage: 75, cooldown: 1500, desc: 'Extremely heavy' },
            wrench: { name: 'Giant Wrench', icon: 'üîß', type: 'weapon', damage: 38, cooldown: 550, desc: 'Tool of destruction' },

            // === LEGENDARY MELEE ===
            excalibur: { name: 'Excalibur', icon: 'üó°Ô∏è', type: 'weapon', damage: 85, cooldown: 600, desc: 'Legendary blade' },
            mjolnir: { name: 'Mjolnir', icon: 'üî®', type: 'weapon', damage: 95, cooldown: 1000, desc: 'Thor\'s hammer' },
            gungnir: { name: 'Gungnir', icon: 'üî±', type: 'weapon', damage: 80, cooldown: 700, desc: 'Odin\'s spear' },
            kusanagi: { name: 'Kusanagi', icon: '‚öîÔ∏è', type: 'weapon', damage: 88, cooldown: 450, desc: 'Divine blade' },

            // === RANGED WEAPONS ===
            bow: { name: 'Bow', icon: 'üèπ', type: 'ranged', damage: 35, cooldown: 800, desc: 'Arrow shot' },
            crossbow: { name: 'Crossbow', icon: 'üéØ', type: 'ranged', damage: 50, cooldown: 1200, desc: 'Powerful bolt' },
            shuriken: { name: 'Shuriken', icon: '‚ú¥Ô∏è', type: 'ranged', damage: 20, cooldown: 300, desc: 'Throwing star' },
            javelin: { name: 'Javelin', icon: 'üéø', type: 'ranged', damage: 45, cooldown: 900, desc: 'Throwing spear' },
            boomerang: { name: 'Boomerang', icon: 'ü™É', type: 'ranged', damage: 28, cooldown: 600, desc: 'Returns to you' },
            kunai: { name: 'Kunai', icon: 'üìç', type: 'ranged', damage: 22, cooldown: 350, desc: 'Ninja knife' },
            chakram: { name: 'Chakram', icon: 'üíø', type: 'ranged', damage: 38, cooldown: 700, desc: 'Spinning disc' },
            blowdart: { name: 'Blowdart', icon: 'üé∫', type: 'ranged', damage: 15, cooldown: 400, desc: 'Poison dart' },

            // === MAGIC SPELLS ===
            iceball: { name: 'Ice Blast', icon: '‚ùÑÔ∏è', type: 'ability', damage: 35, cooldown: 1800, energy: 12, desc: 'Freezing projectile' },
            lightning: { name: 'Lightning', icon: '‚ö°', type: 'ability', damage: 55, cooldown: 2500, energy: 25, desc: 'Chain lightning' },
            poison: { name: 'Poison Cloud', icon: '‚ò†Ô∏è', type: 'ability', damage: 30, cooldown: 3000, energy: 20, desc: 'AOE poison damage' },
            laser: { name: 'Laser Beam', icon: 'üî¥', type: 'ability', damage: 70, cooldown: 3500, energy: 35, desc: 'Powerful beam attack' },
            meteor: { name: 'Meteor', icon: '‚òÑÔ∏è', type: 'ability', damage: 90, cooldown: 5000, energy: 50, desc: 'Massive impact' },
            tornado: { name: 'Tornado', icon: 'üå™Ô∏è', type: 'ability', damage: 45, cooldown: 3000, energy: 30, desc: 'Spinning winds' },
            earthquake: { name: 'Earthquake', icon: 'üåã', type: 'ability', damage: 60, cooldown: 4000, energy: 40, desc: 'Ground shaker' },
            tsunami: { name: 'Tsunami', icon: 'üåä', type: 'ability', damage: 55, cooldown: 3500, energy: 35, desc: 'Water wave' },
            vortex: { name: 'Void Vortex', icon: 'üï≥Ô∏è', type: 'ability', damage: 75, cooldown: 4500, energy: 45, desc: 'Black hole' },
            solar: { name: 'Solar Flare', icon: '‚òÄÔ∏è', type: 'ability', damage: 65, cooldown: 3000, energy: 32, desc: 'Blinding light' },
            lunar: { name: 'Lunar Strike', icon: 'üåô', type: 'ability', damage: 58, cooldown: 2800, energy: 28, desc: 'Moon power' },
            arcane: { name: 'Arcane Blast', icon: 'üîÆ', type: 'ability', damage: 50, cooldown: 2200, energy: 22, desc: 'Pure magic' },
            nature: { name: 'Nature\'s Wrath', icon: 'üåø', type: 'ability', damage: 42, cooldown: 2500, energy: 20, desc: 'Plant attack' },
            shadow: { name: 'Shadow Bolt', icon: 'üñ§', type: 'ability', damage: 48, cooldown: 1800, energy: 18, desc: 'Dark magic' },
            holy: { name: 'Holy Light', icon: '‚ú®', type: 'ability', damage: 52, cooldown: 2000, energy: 24, desc: 'Divine damage' },
            plasma: { name: 'Plasma Ball', icon: 'üü£', type: 'ability', damage: 62, cooldown: 2400, energy: 28, desc: 'Energy sphere' },
            gravity: { name: 'Gravity Well', icon: '‚¨õ', type: 'ability', damage: 55, cooldown: 3200, energy: 35, desc: 'Crushing force' },
            chain_lightning: { name: 'Chain Lightning', icon: '‚õàÔ∏è', type: 'ability', damage: 40, cooldown: 2000, energy: 22, desc: 'Bouncing shock' },
            frost_nova: { name: 'Frost Nova', icon: 'üí†', type: 'ability', damage: 35, cooldown: 2500, energy: 25, desc: 'AOE freeze' },
            fire_storm: { name: 'Fire Storm', icon: 'üî•', type: 'ability', damage: 70, cooldown: 4000, energy: 40, desc: 'Raining fire' },

            // === LEGENDARY MAGIC ===
            supernova: { name: 'Supernova', icon: 'üí•', type: 'ability', damage: 150, cooldown: 8000, energy: 80, desc: 'Ultimate explosion' },
            apocalypse: { name: 'Apocalypse', icon: 'üåë', type: 'ability', damage: 200, cooldown: 12000, energy: 100, desc: 'World ender' },
            genesis: { name: 'Genesis Beam', icon: 'üåü', type: 'ability', damage: 120, cooldown: 6000, energy: 60, desc: 'Creation energy' },
            oblivion: { name: 'Oblivion', icon: 'üíÄ', type: 'ability', damage: 180, cooldown: 10000, energy: 90, desc: 'Erase from existence' },

            // === UTILITY ITEMS ===
            shield: { name: 'Shield', icon: 'üõ°Ô∏è', type: 'ability', cooldown: 6000, energy: 20, desc: '+20 defense 4s' },
            medkit: { name: 'Medkit', icon: 'üíä', type: 'consumable', healing: 50, cooldown: 4000, desc: 'Heal 50 HP' },
            megaHeal: { name: 'Mega Heal', icon: 'üíâ', type: 'consumable', healing: 100, cooldown: 8000, desc: 'Full heal' },
            jumpPad: { name: 'Jump Pad', icon: 'ü¶ò', type: 'ability', cooldown: 3000, energy: 10, desc: 'Super jump' },
            speedBoost: { name: 'Speed Boost', icon: 'üí®', type: 'ability', cooldown: 5000, energy: 15, desc: '2x speed 3s' },
            rage: { name: 'Rage Mode', icon: 'üò°', type: 'ability', cooldown: 10000, energy: 40, desc: '2x damage 5s' },
            invisibility: { name: 'Invisibility', icon: 'üëª', type: 'ability', cooldown: 15000, energy: 50, desc: 'Vanish 5s' },
            teleport: { name: 'Teleport', icon: 'üåÄ', type: 'ability', cooldown: 8000, energy: 30, desc: 'Blink forward' },
            reflect: { name: 'Reflect Shield', icon: 'ü™û', type: 'ability', cooldown: 10000, energy: 35, desc: 'Reflect damage' },
            lifesteal: { name: 'Lifesteal', icon: 'üßõ', type: 'ability', cooldown: 12000, energy: 45, desc: 'Drain health' },
            timestop: { name: 'Time Stop', icon: '‚è∞', type: 'ability', cooldown: 20000, energy: 60, desc: 'Freeze time 3s' },
            clone: { name: 'Shadow Clone', icon: 'üë•', type: 'ability', cooldown: 15000, energy: 40, desc: 'Create decoy' },
            berserk: { name: 'Berserk', icon: 'üî¥', type: 'ability', cooldown: 18000, energy: 55, desc: '3x damage, take 2x' },
            fortify: { name: 'Fortify', icon: 'üè∞', type: 'ability', cooldown: 12000, energy: 35, desc: '+50 defense 6s' },
            regenerate: { name: 'Regeneration', icon: 'üíö', type: 'ability', cooldown: 20000, energy: 40, desc: 'Heal over time' },
            energize: { name: 'Energize', icon: 'üîã', type: 'ability', cooldown: 15000, energy: 0, desc: 'Restore 50 energy' },

            // === BOMBS & EXPLOSIVES ===
            grenade: { name: 'Grenade', icon: 'üí£', type: 'ability', damage: 80, cooldown: 4000, energy: 25, desc: 'Explosive' },
            dynamite: { name: 'Dynamite', icon: 'üß®', type: 'ability', damage: 100, cooldown: 5000, energy: 35, desc: 'Big explosion' },
            molotov: { name: 'Molotov', icon: 'üçæ', type: 'ability', damage: 60, cooldown: 3500, energy: 20, desc: 'Fire bomb' },
            flashbang: { name: 'Flashbang', icon: 'üí°', type: 'ability', damage: 10, cooldown: 6000, energy: 15, desc: 'Stun enemies' },
            smoke_bomb: { name: 'Smoke Bomb', icon: 'üí≠', type: 'ability', damage: 0, cooldown: 5000, energy: 10, desc: 'Cover escape' },
            cluster_bomb: { name: 'Cluster Bomb', icon: 'üéÜ', type: 'ability', damage: 120, cooldown: 7000, energy: 50, desc: 'Multiple explosions' },
            nuke: { name: 'Mini Nuke', icon: '‚ò¢Ô∏è', type: 'ability', damage: 250, cooldown: 20000, energy: 100, desc: 'Nuclear strike' },

            // === SUMMONING ===
            summon_wolf: { name: 'Summon Wolf', icon: 'üê∫', type: 'ability', damage: 30, cooldown: 8000, energy: 40, desc: 'Call wolf ally' },
            summon_dragon: { name: 'Summon Dragon', icon: 'üêâ', type: 'ability', damage: 80, cooldown: 15000, energy: 70, desc: 'Dragon attack' },
            summon_golem: { name: 'Summon Golem', icon: 'üóø', type: 'ability', damage: 50, cooldown: 10000, energy: 50, desc: 'Stone guardian' },
            summon_phoenix: { name: 'Summon Phoenix', icon: 'ü¶Ö', type: 'ability', damage: 70, cooldown: 12000, energy: 60, desc: 'Fire bird' },
            summon_demon: { name: 'Summon Demon', icon: 'üëø', type: 'ability', damage: 90, cooldown: 18000, energy: 80, desc: 'Hellspawn' },

            // === ELEMENTAL WEAPONS ===
            flame_sword: { name: 'Flame Sword', icon: 'üî•', type: 'weapon', damage: 55, cooldown: 550, desc: 'Burning blade' },
            frost_axe: { name: 'Frost Axe', icon: 'üßä', type: 'weapon', damage: 58, cooldown: 850, desc: 'Freezing chop' },
            thunder_hammer: { name: 'Thunder Hammer', icon: '‚õàÔ∏è', type: 'weapon', damage: 72, cooldown: 1100, desc: 'Shocking smash' },
            venom_dagger: { name: 'Venom Dagger', icon: 'üêç', type: 'weapon', damage: 25, cooldown: 280, desc: 'Poisoned blade' },
            earth_mace: { name: 'Earth Mace', icon: 'ü™®', type: 'weapon', damage: 62, cooldown: 900, desc: 'Stone crusher' },
            wind_blade: { name: 'Wind Blade', icon: 'üå¨Ô∏è', type: 'weapon', damage: 42, cooldown: 380, desc: 'Swift as wind' },
            shadow_scythe: { name: 'Shadow Scythe', icon: 'üåë', type: 'weapon', damage: 68, cooldown: 800, desc: 'Dark harvest' },
            holy_lance: { name: 'Holy Lance', icon: '‚úùÔ∏è', type: 'weapon', damage: 65, cooldown: 700, desc: 'Divine pierce' }
        };

        const shopItems = [
            // Melee Weapons
            { id: 'axe', price: 150 },
            { id: 'spear', price: 120 },
            { id: 'hammer', price: 300 },
            { id: 'dagger', price: 80 },
            { id: 'katana', price: 250 },
            { id: 'scythe', price: 400 },
            { id: 'mace', price: 200 },
            { id: 'flail', price: 280 },
            { id: 'halberd', price: 350 },
            { id: 'claws', price: 180 },
            { id: 'gauntlet', price: 220 },
            { id: 'chainsaw', price: 500 },
            { id: 'pickaxe', price: 160 },
            { id: 'shovel', price: 90 },
            { id: 'sickle', price: 140 },
            { id: 'nunchucks', price: 170 },
            { id: 'bo_staff', price: 130 },
            { id: 'whip', price: 150 },
            { id: 'anchor', price: 600 },
            { id: 'wrench', price: 190 },
            // Legendary Melee
            { id: 'excalibur', price: 2500 },
            { id: 'mjolnir', price: 3000 },
            { id: 'gungnir', price: 2800 },
            { id: 'kusanagi', price: 2700 },
            // Ranged
            { id: 'bow', price: 200 },
            { id: 'crossbow', price: 350 },
            { id: 'shuriken', price: 100 },
            { id: 'javelin', price: 280 },
            { id: 'boomerang', price: 180 },
            { id: 'kunai', price: 120 },
            { id: 'chakram', price: 250 },
            { id: 'blowdart', price: 80 },
            // Magic Spells
            { id: 'iceball', price: 200 },
            { id: 'lightning', price: 350 },
            { id: 'poison', price: 250 },
            { id: 'laser', price: 500 },
            { id: 'meteor', price: 800 },
            { id: 'tornado', price: 400 },
            { id: 'earthquake', price: 550 },
            { id: 'tsunami', price: 500 },
            { id: 'vortex', price: 700 },
            { id: 'solar', price: 600 },
            { id: 'lunar', price: 550 },
            { id: 'arcane', price: 380 },
            { id: 'nature', price: 320 },
            { id: 'shadow', price: 400 },
            { id: 'holy', price: 450 },
            { id: 'plasma', price: 580 },
            { id: 'gravity', price: 520 },
            { id: 'chain_lightning', price: 360 },
            { id: 'frost_nova', price: 380 },
            { id: 'fire_storm', price: 650 },
            // Legendary Magic
            { id: 'supernova', price: 5000 },
            { id: 'apocalypse', price: 8000 },
            { id: 'genesis', price: 4500 },
            { id: 'oblivion', price: 7000 },
            // Utility
            { id: 'shield', price: 100 },
            { id: 'medkit', price: 75 },
            { id: 'megaHeal', price: 200 },
            { id: 'jumpPad', price: 125 },
            { id: 'speedBoost', price: 150 },
            { id: 'rage', price: 400 },
            { id: 'invisibility', price: 600 },
            { id: 'teleport', price: 450 },
            { id: 'reflect', price: 500 },
            { id: 'lifesteal', price: 700 },
            { id: 'timestop', price: 1500 },
            { id: 'clone', price: 550 },
            { id: 'berserk', price: 800 },
            { id: 'fortify', price: 400 },
            { id: 'regenerate', price: 600 },
            { id: 'energize', price: 300 },
            // Bombs
            { id: 'grenade', price: 250 },
            { id: 'dynamite', price: 400 },
            { id: 'molotov', price: 200 },
            { id: 'flashbang', price: 150 },
            { id: 'smoke_bomb', price: 100 },
            { id: 'cluster_bomb', price: 900 },
            { id: 'nuke', price: 5000 },
            // Summons
            { id: 'summon_wolf', price: 500 },
            { id: 'summon_dragon', price: 2000 },
            { id: 'summon_golem', price: 800 },
            { id: 'summon_phoenix', price: 1500 },
            { id: 'summon_demon', price: 2500 },
            // Elemental Weapons
            { id: 'flame_sword', price: 450 },
            { id: 'frost_axe', price: 480 },
            { id: 'thunder_hammer', price: 650 },
            { id: 'venom_dagger', price: 300 },
            { id: 'earth_mace', price: 520 },
            { id: 'wind_blade', price: 380 },
            { id: 'shadow_scythe', price: 600 },
            { id: 'holy_lance', price: 580 }
        ];
        
        let hotbar = ['sword', 'fireball', null, null, null, null];
        let selectedSlot = 0;
        let itemCooldowns = {};
        
        // Input
        const keys = {};
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;
        let joystickActive = false;
        let joystickX = 0, joystickY = 0;
        
        // Wave
        let currentWave = 1;
        let waveInProgress = false;
        
        // Get terrain height at any position
        function getTerrainHeight(x, z) {
            let height = 0;
            height += Math.sin(x * 0.02) * Math.cos(z * 0.02) * 3; // Large hills
            height += Math.sin(x * 0.05) * Math.cos(z * 0.04) * 1.5; // Medium bumps
            height += Math.sin(x * 0.1 + z * 0.1) * 0.3; // Small details
            height += Math.sin(x * 0.15 + z * 0.08) * 0.15; // Micro details

            const distFromCenter = Math.sqrt(x * x + z * z);
            if (distFromCenter < 30) {
                height *= distFromCenter / 30;
            }

            return height;
        }
        
        function init() {
            playerState = {
                position: new THREE.Vector3(0, 1.7, 0),
                velocity: new THREE.Vector3(0, 0, 0),
                rotation: { x: 0, y: 0 },
                health: 100,
                maxHealth: 100,
                energy: 100,
                maxEnergy: 100,
                speed: 0.03,
                sprintSpeed: 0.05,
                defense: 5,
                isGrounded: true,
                score: 0,
                kills: 0
            };
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x7ec8e3);
            scene.fog = new THREE.FogExp2(0x7ec8e3, 0.006);
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.copy(playerState.position);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);
            
            // Realistic lighting
            const ambientLight = new THREE.AmbientLight(0x8899aa, 0.4);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffeedd, 1.0);
            sunLight.position.set(60, 100, 40);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 10;
            sunLight.shadow.camera.far = 250;
            sunLight.shadow.camera.left = -60;
            sunLight.shadow.camera.right = 60;
            sunLight.shadow.camera.top = 60;
            sunLight.shadow.camera.bottom = -60;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);
            
            const hemiLight = new THREE.HemisphereLight(0x88bbff, 0x445522, 0.5);
            scene.add(hemiLight);
            
            // Ground - realistic grass with hills (higher resolution)
            const groundGeo = new THREE.PlaneGeometry(250, 250, 120, 120);
            const positions = groundGeo.attributes.position;
            const colors = [];

            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                // Create rolling hills with more variation
                let height = 0;
                height += Math.sin(x * 0.02) * Math.cos(y * 0.02) * 3; // Large hills
                height += Math.sin(x * 0.05) * Math.cos(y * 0.04) * 1.5; // Medium bumps
                height += Math.sin(x * 0.1 + y * 0.1) * 0.3; // Small details
                height += Math.sin(x * 0.15 + y * 0.08) * 0.15; // Micro details

                // Flatten area near spawn
                const distFromCenter = Math.sqrt(x * x + y * y);
                if (distFromCenter < 30) {
                    height *= distFromCenter / 30;
                }

                positions.setZ(i, height);

                // Vertex colors for ground variation
                const grassBase = new THREE.Color(0x4a7c3f);
                const grassDark = new THREE.Color(0x3a5c2f);
                const grassLight = new THREE.Color(0x5a9c4f);
                const dirt = new THREE.Color(0x6b5344);

                // Mix colors based on position and height
                let color = grassBase.clone();
                const noise = Math.sin(x * 0.3) * Math.cos(y * 0.25) * 0.5 + 0.5;
                const heightFactor = (height + 3) / 6;

                if (noise > 0.7) {
                    color.lerp(grassLight, (noise - 0.7) * 2);
                } else if (noise < 0.3) {
                    color.lerp(grassDark, (0.3 - noise) * 2);
                }

                // Add dirt patches
                const dirtNoise = Math.sin(x * 0.08 + 1.5) * Math.cos(y * 0.12 + 2.3);
                if (dirtNoise > 0.6) {
                    color.lerp(dirt, (dirtNoise - 0.6) * 1.5);
                }

                // Darken valleys, lighten peaks
                color.lerp(grassDark, Math.max(0, -heightFactor * 0.3));
                color.lerp(grassLight, Math.max(0, heightFactor * 0.2));

                colors.push(color.r, color.g, color.b);
            }

            groundGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            groundGeo.computeVertexNormals();

            const groundMat = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.92,
                metalness: 0,
                flatShading: false
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Village center cobblestone area
            const cobbleGeo = new THREE.CircleGeometry(18, 32);
            const cobbleMat = new THREE.MeshStandardMaterial({
                color: 0x6a6a6a,
                roughness: 0.85,
                metalness: 0.1
            });
            const cobble = new THREE.Mesh(cobbleGeo, cobbleMat);
            cobble.rotation.x = -Math.PI / 2;
            cobble.position.set(0, 0.03, 12);
            cobble.receiveShadow = true;
            scene.add(cobble);

            // Cobblestone details (individual stones)
            for (let s = 0; s < 80; s++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 16;
                const stoneSize = 0.3 + Math.random() * 0.4;
                const stoneGeo = new THREE.CylinderGeometry(stoneSize, stoneSize * 0.9, 0.08, 6);
                const stoneMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0, 0, 0.35 + Math.random() * 0.2),
                    roughness: 0.9
                });
                const stone = new THREE.Mesh(stoneGeo, stoneMat);
                stone.position.set(
                    Math.cos(angle) * radius,
                    0.06,
                    12 + Math.sin(angle) * radius
                );
                stone.rotation.y = Math.random() * Math.PI;
                stone.receiveShadow = true;
                scene.add(stone);
            }

            // Dirt paths (multiple)
            const pathMat = new THREE.MeshStandardMaterial({ color: 0x7a6355, roughness: 0.95 });

            // Main path (north-south)
            const pathGeo1 = new THREE.PlaneGeometry(4, 150);
            const path1 = new THREE.Mesh(pathGeo1, pathMat);
            path1.rotation.x = -Math.PI / 2;
            path1.position.y = 0.02;
            path1.receiveShadow = true;
            scene.add(path1);

            // East-west path
            const pathGeo2 = new THREE.PlaneGeometry(100, 3.5);
            const path2 = new THREE.Mesh(pathGeo2, pathMat);
            path2.rotation.x = -Math.PI / 2;
            path2.position.set(0, 0.02, 12);
            path2.receiveShadow = true;
            scene.add(path2);

            // Path to church
            const pathGeo3 = new THREE.PlaneGeometry(3, 40);
            const path3 = new THREE.Mesh(pathGeo3, pathMat);
            path3.rotation.x = -Math.PI / 2;
            path3.rotation.z = -0.4;
            path3.position.set(20, 0.02, -5);
            path3.receiveShadow = true;
            scene.add(path3);

            // Scatter small rocks on ground
            for (let r = 0; r < 50; r++) {
                const rx = (Math.random() - 0.5) * 200;
                const rz = (Math.random() - 0.5) * 200;
                const terrainY = getTerrainHeight(rx, rz);
                const rockSize = 0.1 + Math.random() * 0.15;
                const smallRock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(rockSize, 0),
                    new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(0.08, 0.1, 0.3 + Math.random() * 0.15),
                        roughness: 0.95
                    })
                );
                smallRock.position.set(rx, terrainY + rockSize * 0.3, rz);
                smallRock.rotation.set(Math.random(), Math.random(), Math.random());
                smallRock.castShadow = true;
                scene.add(smallRock);
            }
            
            createEnvironment();
            createBuildings();
            
            const playerGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.7, 16);
            const playerMat = new THREE.MeshStandardMaterial({ visible: false });
            player = new THREE.Mesh(playerGeo, playerMat);
            player.position.copy(playerState.position);
            scene.add(player);
            
            // Create 3D sword
            const swordGroup = new THREE.Group();
            
            // Blade
            const bladeGeo = new THREE.BoxGeometry(0.06, 0.8, 0.02);
            const bladeMat = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc, 
                metalness: 0.9, 
                roughness: 0.2 
            });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.y = 0.5;
            swordGroup.add(blade);
            
            // Blade tip
            const tipGeo = new THREE.ConeGeometry(0.04, 0.15, 4);
            const tip = new THREE.Mesh(tipGeo, bladeMat);
            tip.position.y = 0.95;
            tip.rotation.z = Math.PI;
            swordGroup.add(tip);
            
            // Guard
            const guardGeo = new THREE.BoxGeometry(0.2, 0.04, 0.06);
            const guardMat = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, 
                metalness: 0.8, 
                roughness: 0.3 
            });
            const guard = new THREE.Mesh(guardGeo, guardMat);
            guard.position.y = 0.08;
            swordGroup.add(guard);
            
            // Handle
            const handleGeo = new THREE.CylinderGeometry(0.025, 0.03, 0.2, 8);
            const handleMat = new THREE.MeshStandardMaterial({ 
                color: 0x4a3728, 
                roughness: 0.9 
            });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -0.05;
            swordGroup.add(handle);
            
            // Pommel
            const pommelGeo = new THREE.SphereGeometry(0.035, 8, 8);
            const pommel = new THREE.Mesh(pommelGeo, guardMat);
            pommel.position.y = -0.17;
            swordGroup.add(pommel);
            
            swordMesh = swordGroup;
            swordMesh.visible = false;
            scene.add(swordMesh);
            
            setupMinimap();
            setupHotbar();
            generateSettingsUI();
            updateShopUI();
        }
        
        function createEnvironment() {
            colliders = [];
            
            // Trees - realistic
            for (let i = 0; i < 40; i++) {
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                
                if (Math.abs(x) < 25 && Math.abs(z) < 25) continue;
                if (Math.abs(x) < 4) continue;
                
                const terrainY = getTerrainHeight(x, z);
                const treeHeight = 5 + Math.random() * 3;
                const trunkRadius = 0.25 + Math.random() * 0.15;
                
                // Trunk
                const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.7, trunkRadius, treeHeight * 0.4, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5D4037, roughness: 0.9 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.set(x, terrainY + treeHeight * 0.2, z);
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                scene.add(trunk);
                
                colliders.push({
                    type: 'cylinder',
                    position: new THREE.Vector3(x, terrainY, z),
                    radius: trunkRadius + 0.2,
                    canAutoJump: false
                });
                
                // Foliage layers
                for (let j = 0; j < 3; j++) {
                    const foliageRadius = (1.5 - j * 0.3) * (0.8 + Math.random() * 0.2);
                    const foliageGeo = new THREE.ConeGeometry(foliageRadius, treeHeight * 0.2, 8);
                    const foliageMat = new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(0.28 + Math.random() * 0.05, 0.45, 0.28 + Math.random() * 0.06),
                        roughness: 0.85
                    });
                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                    foliage.position.set(x, terrainY + treeHeight * (0.4 + j * 0.14), z);
                    foliage.castShadow = true;
                    scene.add(foliage);
                }
            }
            
            // Rocks - realistic flat orientation
            for (let i = 0; i < 25; i++) {
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;
                
                if (Math.abs(x) < 18 && Math.abs(z) < 18) continue;
                
                const terrainY = getTerrainHeight(x, z);
                const rockSize = 0.3 + Math.random() * 0.8;
                const rockGeo = new THREE.DodecahedronGeometry(rockSize, 0);
                const rockMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(0.4 + Math.random() * 0.15, 0.4 + Math.random() * 0.1, 0.38),
                    roughness: 0.95,
                    flatShading: true
                });
                const rock = new THREE.Mesh(rockGeo, rockMat);
                rock.position.set(x, terrainY + rockSize * 0.3, z);
                // REALISTIC: rocks lie flat, only slight random rotation
                rock.rotation.set(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * Math.PI * 2,
                    (Math.random() - 0.5) * 0.3
                );
                rock.scale.set(1 + Math.random() * 0.4, 0.4 + Math.random() * 0.3, 1 + Math.random() * 0.4);
                rock.castShadow = true;
                rock.receiveShadow = true;
                scene.add(rock);
                
                colliders.push({
                    type: 'sphere',
                    position: new THREE.Vector3(x, terrainY + rockSize * 0.2, z),
                    radius: rockSize * 0.6,
                    canAutoJump: true,
                    jumpHeight: rockSize * 0.3
                });
            }
            
            // Grass tufts
            for (let i = 0; i < 200; i++) {
                const x = (Math.random() - 0.5) * 120;
                const z = (Math.random() - 0.5) * 120;
                const terrainY = getTerrainHeight(x, z);
                
                const grassGeo = new THREE.PlaneGeometry(0.12, 0.3 + Math.random() * 0.2);
                const grassMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0.25 + Math.random() * 0.05, 0.5, 0.32),
                    side: THREE.DoubleSide
                });
                const grass = new THREE.Mesh(grassGeo, grassMat);
                grass.position.set(x, terrainY + 0.15, z);
                grass.rotation.y = Math.random() * Math.PI;
                grass.rotation.x = -0.1;
                scene.add(grass);
            }
        }
        
        function createBuildings() {
            buildings = [];

            const buildingData = [
                // Village center
                { x: 20, z: 0, type: 'house' },
                { x: -20, z: 0, type: 'shop' },
                { x: 20, z: 25, type: 'barn' },
                { x: -20, z: -25, type: 'tower' },
                // New buildings
                { x: 0, z: 35, type: 'tavern' },
                { x: -35, z: 15, type: 'blacksmith' },
                { x: 35, z: -15, type: 'church' },
                { x: -10, z: -40, type: 'windmill' },
                { x: 45, z: 20, type: 'watchtower' },
                { x: -45, z: -10, type: 'house' },
                { x: 30, z: 45, type: 'stable' },
                { x: -30, z: 40, type: 'shop' },
                // Outer buildings
                { x: 55, z: -35, type: 'ruins' },
                { x: -55, z: 35, type: 'cottage' },
                { x: 60, z: 50, type: 'watchtower' },
                { x: -60, z: -50, type: 'barn' }
            ];

            buildingData.forEach(b => {
                const terrainY = getTerrainHeight(b.x, b.z);
                createBuilding(b.x, b.z, b.type, terrainY);
            });

            // Add village well in center
            createWell(0, 15);

            // Add market stalls
            createMarketStall(-8, 8);
            createMarketStall(-4, 8);
            createMarketStall(4, 8);

            // Add fences
            createFence(-15, 25, 20, 0);
            createFence(15, 25, 20, 0);
            createFence(-25, 20, 15, Math.PI / 2);
        }

        function createWell(x, z) {
            const terrainY = getTerrainHeight(x, z);
            const wellGroup = new THREE.Group();

            // Stone base
            const baseGeo = new THREE.CylinderGeometry(1.2, 1.4, 0.8, 12);
            const stoneMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 });
            const base = new THREE.Mesh(baseGeo, stoneMat);
            base.position.y = 0.4;
            base.castShadow = true;
            wellGroup.add(base);

            // Inner hole (dark)
            const holeGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 12);
            const holeMat = new THREE.MeshStandardMaterial({ color: 0x111122 });
            const hole = new THREE.Mesh(holeGeo, holeMat);
            hole.position.y = 0.82;
            wellGroup.add(hole);

            // Wooden frame posts
            const postMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 });
            for (let i = 0; i < 2; i++) {
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2.5, 0.15), postMat);
                post.position.set(i === 0 ? -1 : 1, 1.6, 0);
                post.castShadow = true;
                wellGroup.add(post);
            }

            // Roof beam
            const beam = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.15, 0.2), postMat);
            beam.position.y = 2.9;
            wellGroup.add(beam);

            // Roof
            const roofGeo = new THREE.BoxGeometry(2.8, 0.1, 1.5);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 3.1;
            roof.rotation.x = 0.15;
            wellGroup.add(roof);

            // Bucket
            const bucketGeo = new THREE.CylinderGeometry(0.15, 0.12, 0.25, 8);
            const bucketMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
            const bucket = new THREE.Mesh(bucketGeo, bucketMat);
            bucket.position.set(0, 1.5, 0);
            wellGroup.add(bucket);

            // Rope
            const ropeGeo = new THREE.CylinderGeometry(0.02, 0.02, 1.5, 6);
            const ropeMat = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
            const rope = new THREE.Mesh(ropeGeo, ropeMat);
            rope.position.set(0, 2.2, 0);
            wellGroup.add(rope);

            wellGroup.position.set(x, terrainY, z);
            scene.add(wellGroup);
        }

        function createMarketStall(x, z) {
            const terrainY = getTerrainHeight(x, z);
            const stallGroup = new THREE.Group();

            // Table
            const tableMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
            const table = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 1.2), tableMat);
            table.position.y = 1;
            table.castShadow = true;
            stallGroup.add(table);

            // Legs
            for (let lx = -0.8; lx <= 0.8; lx += 1.6) {
                for (let lz = -0.4; lz <= 0.4; lz += 0.8) {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 0.1), tableMat);
                    leg.position.set(lx, 0.5, lz);
                    stallGroup.add(leg);
                }
            }

            // Canopy poles
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
            for (let px = -0.9; px <= 0.9; px += 1.8) {
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2, 8), poleMat);
                pole.position.set(px, 2, -0.5);
                stallGroup.add(pole);
            }

            // Canopy
            const canopyColors = [0xcc3333, 0x3366cc, 0x33aa33, 0xcccc33];
            const canopyColor = canopyColors[Math.floor(Math.random() * canopyColors.length)];
            const canopyMat = new THREE.MeshStandardMaterial({ color: canopyColor, roughness: 0.9, side: THREE.DoubleSide });
            const canopy = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 1.5), canopyMat);
            canopy.position.set(0, 2.8, 0);
            canopy.rotation.x = -0.3;
            stallGroup.add(canopy);

            // Goods on table (random items)
            const goodsColors = [0xff6600, 0xffff00, 0x00ff00, 0xff0000, 0x8B4513];
            for (let g = 0; g < 5; g++) {
                const goodGeo = Math.random() > 0.5 ?
                    new THREE.SphereGeometry(0.1, 8, 8) :
                    new THREE.BoxGeometry(0.15, 0.15, 0.15);
                const goodMat = new THREE.MeshStandardMaterial({ color: goodsColors[g] });
                const good = new THREE.Mesh(goodGeo, goodMat);
                good.position.set(-0.6 + g * 0.3, 1.15, (Math.random() - 0.5) * 0.6);
                stallGroup.add(good);
            }

            stallGroup.position.set(x, terrainY, z);
            scene.add(stallGroup);
        }

        function createFence(x, z, length, rotation) {
            const terrainY = getTerrainHeight(x, z);
            const fenceGroup = new THREE.Group();
            const fenceMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.9 });

            const postCount = Math.floor(length / 2);
            for (let i = 0; i < postCount; i++) {
                // Post
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.12, 1.2, 0.12), fenceMat);
                post.position.set(i * 2 - length / 2 + 1, 0.6, 0);
                post.castShadow = true;
                fenceGroup.add(post);

                // Horizontal beams
                if (i < postCount - 1) {
                    const beam1 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.06), fenceMat);
                    beam1.position.set(i * 2 - length / 2 + 2, 0.9, 0);
                    fenceGroup.add(beam1);

                    const beam2 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 0.06), fenceMat);
                    beam2.position.set(i * 2 - length / 2 + 2, 0.4, 0);
                    fenceGroup.add(beam2);
                }
            }

            fenceGroup.rotation.y = rotation;
            fenceGroup.position.set(x, terrainY, z);
            scene.add(fenceGroup);
        }
        
        function createBuilding(x, z, type, terrainY) {
            const building = new THREE.Group();
            
            let width, depth, height, wallColor, roofColor;
            
            let isSpecial = false;

            switch(type) {
                case 'house':
                    width = 7; depth = 5; height = 3.5;
                    wallColor = 0xD2B48C;
                    roofColor = 0x8B4513;
                    break;
                case 'shop':
                    width = 8; depth = 6; height = 3.5;
                    wallColor = 0xF5DEB3;
                    roofColor = 0x654321;
                    break;
                case 'barn':
                    width = 10; depth = 7; height = 4;
                    wallColor = 0xCD853F;
                    roofColor = 0x8B0000;
                    break;
                case 'tower':
                    width = 5; depth = 5; height = 8;
                    wallColor = 0x808080;
                    roofColor = 0x2F4F4F;
                    break;
                case 'tavern':
                    width = 12; depth = 8; height = 4.5;
                    wallColor = 0xDEB887;
                    roofColor = 0x4a3728;
                    break;
                case 'blacksmith':
                    width = 9; depth = 7; height = 3.5;
                    wallColor = 0x696969;
                    roofColor = 0x2F2F2F;
                    break;
                case 'church':
                    width = 10; depth = 15; height = 7;
                    wallColor = 0xE8E8E8;
                    roofColor = 0x4a4a5a;
                    break;
                case 'windmill':
                    width = 6; depth = 6; height = 10;
                    wallColor = 0xF5F5DC;
                    roofColor = 0x8B4513;
                    isSpecial = true;
                    break;
                case 'watchtower':
                    width = 4; depth = 4; height = 12;
                    wallColor = 0x808080;
                    roofColor = 0x2F4F4F;
                    break;
                case 'stable':
                    width = 12; depth = 8; height = 3;
                    wallColor = 0x8B7355;
                    roofColor = 0x654321;
                    break;
                case 'ruins':
                    width = 8; depth = 8; height = 2;
                    wallColor = 0x696969;
                    roofColor = 0x505050;
                    isSpecial = true;
                    break;
                case 'cottage':
                    width = 5; depth = 4; height = 2.5;
                    wallColor = 0xD2B48C;
                    roofColor = 0x556B2F;
                    break;
                default:
                    width = 6; depth = 5; height = 3;
                    wallColor = 0xBDB76B;
                    roofColor = 0x8B4513;
            }
            
            // Calculate terrain heights at corners for foundation
            const corners = [
                { cx: x - width/2, cz: z - depth/2 },
                { cx: x + width/2, cz: z - depth/2 },
                { cx: x - width/2, cz: z + depth/2 },
                { cx: x + width/2, cz: z + depth/2 }
            ];
            
            let minTerrainY = terrainY;
            let maxTerrainY = terrainY;
            corners.forEach(c => {
                const h = getTerrainHeight(c.cx, c.cz);
                minTerrainY = Math.min(minTerrainY, h);
                maxTerrainY = Math.max(maxTerrainY, h);
            });
            
            // Foundation height to cover the slope
            const foundationHeight = maxTerrainY - minTerrainY + 0.5;
            const baseY = minTerrainY;
            
            // Create adaptive foundation using multiple segments
            const foundationMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
            
            // Create foundation segments to match terrain
            const segmentsX = 4;
            const segmentsZ = 4;
            const segWidth = width / segmentsX;
            const segDepth = depth / segmentsZ;
            
            for (let sx = 0; sx < segmentsX; sx++) {
                for (let sz = 0; sz < segmentsZ; sz++) {
                    const segX = -width/2 + segWidth/2 + sx * segWidth;
                    const segZ = -depth/2 + segDepth/2 + sz * segDepth;
                    const worldX = x + segX;
                    const worldZ = z + segZ;
                    const segTerrainY = getTerrainHeight(worldX, worldZ);
                    
                    // Height from terrain to building base
                    const segFoundHeight = (baseY + foundationHeight) - segTerrainY + 0.1;
                    
                    if (segFoundHeight > 0.05) {
                        const foundGeo = new THREE.BoxGeometry(segWidth + 0.05, segFoundHeight, segDepth + 0.05);
                        const foundSeg = new THREE.Mesh(foundGeo, foundationMat);
                        foundSeg.position.set(segX, segTerrainY - baseY + segFoundHeight/2, segZ);
                        foundSeg.castShadow = true;
                        foundSeg.receiveShadow = true;
                        building.add(foundSeg);
                    }
                }
            }
            
            // Building base level (on top of foundation)
            const buildingBaseY = foundationHeight;
            
            const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, roughness: 0.85 });
            const wallThickness = 0.25;
            const doorWidth = 1.4;
            const doorHeight = 2.2;
            
            // Front wall - LEFT of door
            const frontLeftGeo = new THREE.BoxGeometry((width - doorWidth) / 2, height, wallThickness);
            const frontLeft = new THREE.Mesh(frontLeftGeo, wallMat);
            frontLeft.position.set(-(width/4 + doorWidth/4), buildingBaseY + height/2, depth/2);
            frontLeft.castShadow = true;
            frontLeft.receiveShadow = true;
            building.add(frontLeft);
            
            // Front wall - RIGHT of door
            const frontRight = new THREE.Mesh(frontLeftGeo, wallMat);
            frontRight.position.set((width/4 + doorWidth/4), buildingBaseY + height/2, depth/2);
            frontRight.castShadow = true;
            frontRight.receiveShadow = true;
            building.add(frontRight);
            
            // Front wall - ABOVE door
            const frontTopGeo = new THREE.BoxGeometry(doorWidth, height - doorHeight, wallThickness);
            const frontTop = new THREE.Mesh(frontTopGeo, wallMat);
            frontTop.position.set(0, buildingBaseY + height - (height - doorHeight)/2, depth/2);
            frontTop.castShadow = true;
            building.add(frontTop);
            
            // Back wall (solid)
            const backWallGeo = new THREE.BoxGeometry(width, height, wallThickness);
            const backWall = new THREE.Mesh(backWallGeo, wallMat);
            backWall.position.set(0, buildingBaseY + height/2, -depth/2);
            backWall.castShadow = true;
            backWall.receiveShadow = true;
            building.add(backWall);
            
            // Side walls
            const sideWallGeo = new THREE.BoxGeometry(wallThickness, height, depth);
            const leftWall = new THREE.Mesh(sideWallGeo, wallMat);
            leftWall.position.set(-width/2, buildingBaseY + height/2, 0);
            leftWall.castShadow = true;
            building.add(leftWall);
            
            const rightWall = new THREE.Mesh(sideWallGeo, wallMat);
            rightWall.position.set(width/2, buildingBaseY + height/2, 0);
            rightWall.castShadow = true;
            building.add(rightWall);
            
            // Roof
            const roofMat = new THREE.MeshStandardMaterial({ color: roofColor, roughness: 0.8 });
            if (type === 'tower') {
                const roofGeo = new THREE.ConeGeometry(width * 0.75, height * 0.4, 4);
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.set(0, buildingBaseY + height + height * 0.2, 0);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                building.add(roof);
            } else {
                const roofGeo = new THREE.BoxGeometry(width + 0.6, 0.3, depth + 0.6);
                const roofBase = new THREE.Mesh(roofGeo, roofMat);
                roofBase.position.set(0, buildingBaseY + height, 0);
                roofBase.castShadow = true;
                building.add(roofBase);
                
                // Pitched roof
                const pitchGeo = new THREE.CylinderGeometry(0, depth * 0.6, height * 0.35, 4);
                const pitch = new THREE.Mesh(pitchGeo, roofMat);
                pitch.position.set(0, buildingBaseY + height + height * 0.17, 0);
                pitch.rotation.y = Math.PI / 4;
                pitch.castShadow = true;
                building.add(pitch);
            }
            
            // Floor
            const floorGeo = new THREE.PlaneGeometry(width - 0.5, depth - 0.5);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.9 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = buildingBaseY + 0.05;
            floor.receiveShadow = true;
            building.add(floor);
            
            // Interior
            createInterior(building, width, depth, height, type, buildingBaseY);
            
            // Door frame
            const doorFrameMat = new THREE.MeshStandardMaterial({ color: 0x4A3C31 });
            const doorFrameGeo = new THREE.BoxGeometry(doorWidth + 0.2, 0.15, 0.3);
            const doorTop = new THREE.Mesh(doorFrameGeo, doorFrameMat);
            doorTop.position.set(0, buildingBaseY + doorHeight, depth/2 + 0.1);
            building.add(doorTop);
            
            // Windows
            const windowMat = new THREE.MeshStandardMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.5
            });
            
            [-width/3, width/3].forEach(wx => {
                const windowGeo = new THREE.BoxGeometry(0.8, 0.8, 0.15);
                const win = new THREE.Mesh(windowGeo, windowMat);
                win.position.set(wx, buildingBaseY + height * 0.55, depth/2 + 0.15);
                building.add(win);
            });
            
            // Add special features for specific building types
            if (type === 'windmill') {
                // Windmill blades
                const bladeGroup = new THREE.Group();
                const bladeMat = new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.8 });
                for (let b = 0; b < 4; b++) {
                    const blade = new THREE.Mesh(new THREE.BoxGeometry(0.3, 4, 0.1), bladeMat);
                    blade.position.y = 2;
                    blade.rotation.z = b * Math.PI / 2;
                    bladeGroup.add(blade);
                    // Blade frame
                    const frame = new THREE.Mesh(new THREE.BoxGeometry(0.1, 3.5, 0.05), bladeMat);
                    frame.position.set(0.15, 1.75, 0);
                    frame.rotation.z = b * Math.PI / 2;
                    bladeGroup.add(frame);
                }
                bladeGroup.position.set(0, buildingBaseY + height * 0.7, depth / 2 + 0.5);
                building.add(bladeGroup);
                // Store for animation
                building.userData.blades = bladeGroup;
            }

            if (type === 'church') {
                // Church steeple
                const steepleGeo = new THREE.ConeGeometry(1.5, 5, 4);
                const steeepleMat = new THREE.MeshStandardMaterial({ color: roofColor, metalness: 0.3 });
                const steeple = new THREE.Mesh(steepleGeo, steeepleMat);
                steeple.position.set(0, buildingBaseY + height + 3.5, -depth / 3);
                steeple.rotation.y = Math.PI / 4;
                building.add(steeple);
                // Cross
                const crossMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8 });
                const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.2, 0.15), crossMat);
                crossV.position.set(0, buildingBaseY + height + 6.5, -depth / 3);
                building.add(crossV);
                const crossH = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.15, 0.15), crossMat);
                crossH.position.set(0, buildingBaseY + height + 6.2, -depth / 3);
                building.add(crossH);
                // Rose window
                const roseGeo = new THREE.CircleGeometry(1.2, 16);
                const roseMat = new THREE.MeshStandardMaterial({
                    color: 0x4169E1,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const rose = new THREE.Mesh(roseGeo, roseMat);
                rose.position.set(0, buildingBaseY + height * 0.65, depth / 2 + 0.16);
                building.add(rose);
            }

            if (type === 'blacksmith') {
                // Chimney with smoke
                const chimneyGeo = new THREE.BoxGeometry(1.2, 3, 1.2);
                const chimneyMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.9 });
                const chimney = new THREE.Mesh(chimneyGeo, chimneyMat);
                chimney.position.set(width / 3, buildingBaseY + height + 1, -depth / 3);
                building.add(chimney);
                // Anvil outside
                const anvilBase = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.4, 0.4),
                    new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9 })
                );
                anvilBase.position.set(width / 2 + 1.5, buildingBaseY + 0.2, 0);
                building.add(anvilBase);
                const anvilTop = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.15, 0.5),
                    new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.95 })
                );
                anvilTop.position.set(width / 2 + 1.5, buildingBaseY + 0.48, 0);
                building.add(anvilTop);
                // Forge glow
                const forgeGlow = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 1, 0.5),
                    new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.6 })
                );
                forgeGlow.position.set(-width / 3, buildingBaseY + 0.5, depth / 2 - 0.5);
                building.add(forgeGlow);
            }

            if (type === 'tavern') {
                // Tavern sign
                const signPost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 2, 8),
                    new THREE.MeshStandardMaterial({ color: 0x4a3728 })
                );
                signPost.position.set(width / 2 + 0.5, buildingBaseY + 2.5, depth / 2);
                building.add(signPost);
                const signBoard = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 0.8, 0.1),
                    new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                );
                signBoard.position.set(width / 2 + 0.5, buildingBaseY + 3.2, depth / 2 + 0.4);
                building.add(signBoard);
                // Barrels outside
                for (let br = 0; br < 3; br++) {
                    const barrel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.35, 0.3, 0.7, 12),
                        new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 })
                    );
                    barrel.position.set(-width / 2 - 0.8, buildingBaseY + 0.35, depth / 4 - br * 0.8);
                    building.add(barrel);
                }
            }

            if (type === 'stable') {
                // Horse stall dividers
                const stallMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
                for (let s = 0; s < 4; s++) {
                    const divider = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2, depth - 1), stallMat);
                    divider.position.set(-width / 2 + 2.5 + s * 2.5, buildingBaseY + 1, 0);
                    building.add(divider);
                }
                // Hay bales
                const hayMat = new THREE.MeshStandardMaterial({ color: 0xDAA520 });
                for (let h = 0; h < 3; h++) {
                    const hay = new THREE.Mesh(new THREE.BoxGeometry(1, 0.6, 0.8), hayMat);
                    hay.position.set(width / 2 - 1.5, buildingBaseY + 0.3 + h * 0.5, -depth / 3 + h * 0.3);
                    hay.rotation.y = h * 0.2;
                    building.add(hay);
                }
            }

            if (type === 'ruins') {
                // Broken walls scattered
                const ruinMat = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 1 });
                for (let r = 0; r < 8; r++) {
                    const rubble = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5 + Math.random(), 0.3 + Math.random() * 0.5, 0.5 + Math.random()),
                        ruinMat
                    );
                    rubble.position.set(
                        (Math.random() - 0.5) * width,
                        buildingBaseY + 0.2,
                        (Math.random() - 0.5) * depth
                    );
                    rubble.rotation.set(Math.random() * 0.3, Math.random() * Math.PI, Math.random() * 0.3);
                    building.add(rubble);
                }
                // Partial standing wall
                const wallPiece = new THREE.Mesh(new THREE.BoxGeometry(3, 2.5, 0.4), ruinMat);
                wallPiece.position.set(-width / 4, buildingBaseY + 1.25, depth / 3);
                wallPiece.rotation.y = 0.2;
                building.add(wallPiece);
            }

            if (type === 'watchtower') {
                // Platform at top
                const platformGeo = new THREE.BoxGeometry(width + 1.5, 0.3, depth + 1.5);
                const platformMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
                const platform = new THREE.Mesh(platformGeo, platformMat);
                platform.position.y = buildingBaseY + height - 0.5;
                building.add(platform);
                // Battlements
                const bMat = new THREE.MeshStandardMaterial({ color: wallColor });
                for (let bx = -1; bx <= 1; bx++) {
                    for (let bz = -1; bz <= 1; bz++) {
                        if (Math.abs(bx) + Math.abs(bz) === 2) {
                            const battlement = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 0.8), bMat);
                            battlement.position.set(bx * (width / 2 + 0.4), buildingBaseY + height + 0.2, bz * (depth / 2 + 0.4));
                            building.add(battlement);
                        }
                    }
                }
                // Flag
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8), poleMat);
                pole.position.set(0, buildingBaseY + height + 1.25, 0);
                building.add(pole);
                const flagMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, side: THREE.DoubleSide });
                const flag = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.8), flagMat);
                flag.position.set(0.6, buildingBaseY + height + 2, 0);
                building.add(flag);
            }

            building.position.set(x, baseY, z);
            scene.add(building);
            
            // Collision - walls only (not door opening)
            const collisionY = baseY + buildingBaseY;
            
            // Left wall collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x - width/2, collisionY, z),
                width: wallThickness + 0.3,
                depth: depth + 0.3,
                canAutoJump: false
            });
            // Right wall collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x + width/2, collisionY, z),
                width: wallThickness + 0.3,
                depth: depth + 0.3,
                canAutoJump: false
            });
            // Back wall collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x, collisionY, z - depth/2),
                width: width + 0.3,
                depth: wallThickness + 0.3,
                canAutoJump: false
            });
            // Front wall LEFT collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x - (width/4 + doorWidth/4), collisionY, z + depth/2),
                width: (width - doorWidth) / 2 + 0.3,
                depth: wallThickness + 0.3,
                canAutoJump: false
            });
            // Front wall RIGHT collider
            colliders.push({
                type: 'box',
                position: new THREE.Vector3(x + (width/4 + doorWidth/4), collisionY, z + depth/2),
                width: (width - doorWidth) / 2 + 0.3,
                depth: wallThickness + 0.3,
                canAutoJump: false
            });
            
            buildings.push({ x, z, width, depth, height, type, baseY });
        }
        
        function createInterior(building, width, depth, height, type, buildingBaseY) {
            // Table
            const tableMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const tableGeo = new THREE.BoxGeometry(1.6, 0.08, 0.8);
            const table = new THREE.Mesh(tableGeo, tableMat);
            table.position.set(0, buildingBaseY + 0.7, 0);
            table.castShadow = true;
            building.add(table);
            
            // Table legs
            const legGeo = new THREE.BoxGeometry(0.08, 0.7, 0.08);
            [[-0.7, -0.3], [-0.7, 0.3], [0.7, -0.3], [0.7, 0.3]].forEach(([lx, lz]) => {
                const leg = new THREE.Mesh(legGeo, tableMat);
                leg.position.set(lx, buildingBaseY + 0.35, lz);
                building.add(leg);
            });
            
            // Chair
            const chairMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const chairSeat = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.04, 0.4), chairMat);
            chairSeat.position.set(-1.3, buildingBaseY + 0.45, 0);
            building.add(chairSeat);
            
            const chairBack = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.04), chairMat);
            chairBack.position.set(-1.3, buildingBaseY + 0.7, -0.2);
            building.add(chairBack);
            
            // Fireplace for house
            if (type === 'house' || type === 'shop') {
                const fireplaceGeo = new THREE.BoxGeometry(1.2, 1, 0.4);
                const fireplaceMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A });
                const fireplace = new THREE.Mesh(fireplaceGeo, fireplaceMat);
                fireplace.position.set(0, buildingBaseY + 0.5, -depth/2 + 0.4);
                building.add(fireplace);
                
                const fireLight = new THREE.PointLight(0xff6600, 0.6, 4);
                fireLight.position.set(0, buildingBaseY + 0.4, -depth/2 + 0.6);
                building.add(fireLight);
            }
            
            // Ceiling light
            const lightGeo = new THREE.CylinderGeometry(0.25, 0.3, 0.15, 8);
            const lightMat = new THREE.MeshStandardMaterial({ color: 0xB8860B });
            const ceilingLight = new THREE.Mesh(lightGeo, lightMat);
            ceilingLight.position.set(0, buildingBaseY + height - 0.4, 0);
            building.add(ceilingLight);
            
            const interiorLight = new THREE.PointLight(0xffee88, 0.5, 6);
            interiorLight.position.set(0, buildingBaseY + height - 0.5, 0);
            building.add(interiorLight);
        }
        
        function generateSettingsUI() {
            const container = document.getElementById('settingsContent');
            container.innerHTML = '';
            
            const categories = {
                'Gameplay': ['autoJump', 'autoCollectCoins'],
                'Movement': ['walkSpeed', 'sprintSpeed'],
                'Camera': ['sensitivity', 'invertY'],
                'Display': ['showDamageNumbers', 'showMinimap']
            };
            
            for (const [category, settingsList] of Object.entries(categories)) {
                const catDiv = document.createElement('div');
                catDiv.className = 'settings-category';
                
                const title = document.createElement('div');
                title.className = 'settings-category-title';
                title.textContent = category;
                catDiv.appendChild(title);
                
                settingsList.forEach(key => {
                    if (settings[key] === undefined) return;
                    
                    const row = document.createElement('div');
                    row.className = 'setting-row';
                    
                    const label = document.createElement('span');
                    label.className = 'setting-label';
                    label.textContent = key.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
                    row.appendChild(label);
                    
                    const value = settings[key];
                    
                    if (typeof value === 'boolean') {
                        const toggle = document.createElement('div');
                        toggle.className = 'toggle-switch' + (value ? ' on' : '');
                        toggle.onclick = () => {
                            settings[key] = !settings[key];
                            toggle.classList.toggle('on');
                        };
                        row.appendChild(toggle);
                    } else if (typeof value === 'number') {
                        const sliderContainer = document.createElement('div');
                        sliderContainer.className = 'slider-container';
                        
                        const slider = document.createElement('input');
                        slider.type = 'range';
                        slider.className = 'slider';
                        slider.min = 0;
                        slider.max = 100;
                        slider.value = value;
                        
                        const valDisplay = document.createElement('span');
                        valDisplay.className = 'slider-value';
                        valDisplay.textContent = value;
                        
                        slider.oninput = () => {
                            settings[key] = parseInt(slider.value);
                            valDisplay.textContent = slider.value;
                        };
                        
                        sliderContainer.appendChild(slider);
                        sliderContainer.appendChild(valDisplay);
                        row.appendChild(sliderContainer);
                    }
                    
                    catDiv.appendChild(row);
                });
                
                container.appendChild(catDiv);
            }
        }
        
        function setupHotbar() {
            const el = document.getElementById('hotbar');
            el.innerHTML = '';
            
            for (let i = 0; i < 6; i++) {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot' + (i === selectedSlot ? ' selected' : '');
                slot.onclick = () => selectSlot(i);
                
                const itemId = hotbar[i];
                if (itemId && itemDefs[itemId]) {
                    const item = itemDefs[itemId];
                    slot.innerHTML = `
                        <span class="slot-key">${i + 1}</span>
                        <span class="item-icon">${item.icon}</span>
                        <span class="item-name">${item.name}</span>
                        <div class="cooldown-overlay" id="cooldown${i}"></div>
                    `;
                } else {
                    slot.innerHTML = `<span class="slot-key">${i + 1}</span><span class="item-icon" style="opacity:0.2">+</span>`;
                }
                
                el.appendChild(slot);
            }
            updateWeaponView();
        }
        
        function selectSlot(index) {
            selectedSlot = index;
            document.querySelectorAll('.hotbar-slot').forEach((el, i) => {
                el.classList.toggle('selected', i === index);
            });
            updateWeaponView();
        }
        
        function updateWeaponView() {
            // No longer needed - using 3D sword
        }
        
        function selectDevice(mode) {
            deviceMode = mode;
            document.getElementById('deviceSelect').style.display = 'none';
            document.getElementById('modeSelect').style.display = 'block';
        }

        function selectMode(mode) {
            gameMode = mode;
            document.getElementById('modeSelect').style.display = 'none';
            document.getElementById('startSection').style.display = 'block';
        }

        function openShop() { document.getElementById('shopPanel').style.display = 'flex'; updateShopUI(); }
        function closeShop() { document.getElementById('shopPanel').style.display = 'none'; }
        
        function updateShopUI() {
            const el = document.getElementById('shopItems');
            el.innerHTML = '';
            
            shopItems.forEach(si => {
                const item = itemDefs[si.id];
                const owned = inventory.ownedItems.includes(si.id);
                const canAfford = inventory.coins >= si.price;
                
                const div = document.createElement('div');
                div.className = 'shop-item';
                div.innerHTML = `
                    <span class="shop-item-icon">${item.icon}</span>
                    <div class="shop-item-info">
                        <div class="shop-item-name">${item.name}</div>
                        <div class="shop-item-desc">${item.desc}</div>
                    </div>
                    <span class="shop-item-price">${owned ? '‚úì' : 'üí∞' + si.price}</span>
                    ${owned ? '' : `<button class="shop-buy-btn" onclick="buyItem('${si.id}', ${si.price})" ${canAfford ? '' : 'disabled'}>Buy</button>`}
                `;
                el.appendChild(div);
            });
            
            document.getElementById('menuCoins').textContent = 'üí∞ ' + inventory.coins;
        }
        
        function buyItem(itemId, price) {
            if (inventory.coins >= price && !inventory.ownedItems.includes(itemId)) {
                inventory.coins -= price;
                inventory.ownedItems.push(itemId);
                const emptySlot = hotbar.findIndex(s => s === null);
                if (emptySlot !== -1) hotbar[emptySlot] = itemId;
                updateShopUI();
                setupHotbar();
                saveCoinsToCloud(); // Save to cloud after purchase
            }
        }
        
        function openSettings() { document.getElementById('settingsPanel').style.display = 'flex'; }
        function closeSettings() { document.getElementById('settingsPanel').style.display = 'none'; }
        function quitGame() { location.reload(); }
        
        function enterFullscreen() {
            const el = document.documentElement;
            if (el.requestFullscreen) el.requestFullscreen();
            else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        }
        
        function setupInput() {
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                if (e.code >= 'Digit1' && e.code <= 'Digit6') {
                    selectSlot(parseInt(e.code.replace('Digit', '')) - 1);
                }
            });
            document.addEventListener('keyup', (e) => { keys[e.code] = false; });
            
            if (deviceMode === 'computer') setupComputerControls();
            else setupMobileControls();
        }
        
        function setupComputerControls() {
            const canvas = renderer.domElement;

            // Request pointer lock on canvas click
            canvas.addEventListener('click', (e) => {
                if (gameRunning && document.pointerLockElement !== canvas) {
                    canvas.requestPointerLock();
                }
            });

            // Use mousedown for attacks (works better with pointer lock)
            document.addEventListener('mousedown', (e) => {
                if (!gameRunning) return;
                if (document.pointerLockElement === canvas) {
                    if (e.button === 0) { // Left click = attack
                        useCurrentItem();
                    }
                }
            });

            // Handle pointer lock change
            document.addEventListener('pointerlockchange', () => {
                const clickMsg = document.getElementById('clickToPlay');
                if (document.pointerLockElement === canvas) {
                    clickMsg.style.display = 'none';
                } else if (gameRunning && deviceMode === 'computer') {
                    clickMsg.style.display = 'block';
                }
            });

            // Mouse movement with pointer lock
            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvas && gameRunning) {
                    const sens = settings.sensitivity / 8000;
                    playerState.rotation.y -= e.movementX * sens;
                    playerState.rotation.x -= e.movementY * sens * (settings.invertY ? -1 : 1);
                    playerState.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, playerState.rotation.x));
                }
            });

            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        function setupMobileControls() {
            document.body.classList.add('mobile-mode');
            
            const joystickZone = document.getElementById('joystickZone');
            const joystickBase = document.getElementById('joystickBase');
            const joystickKnob = document.getElementById('joystickKnob');
            
            let moveTouchId = null;
            let lookTouchId = null;
            let moveStartX = 0, moveStartY = 0;
            let lookStartX = 0, lookStartY = 0;
            
            document.addEventListener('touchstart', (e) => {
                if (!gameRunning) return;
                
                const jRect = joystickZone.getBoundingClientRect();
                const aRect = document.getElementById('attackBtn').getBoundingClientRect();
                const jRect2 = document.getElementById('jumpBtn').getBoundingClientRect();
                const dRect = document.getElementById('dashBtn').getBoundingClientRect();
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    const tx = t.clientX, ty = t.clientY;
                    
                    // Check buttons
                    if (tx >= aRect.left && tx <= aRect.right && ty >= aRect.top && ty <= aRect.bottom) {
                        useCurrentItem(); continue;
                    }
                    if (tx >= jRect2.left && tx <= jRect2.right && ty >= jRect2.top && ty <= jRect2.bottom) {
                        jump(); continue;
                    }
                    if (tx >= dRect.left && tx <= dRect.right && ty >= dRect.top && ty <= dRect.bottom) {
                        dash(); continue;
                    }
                    
                    // Joystick
                    if (tx >= jRect.left && tx <= jRect.right && ty >= jRect.top && ty <= jRect.bottom) {
                        if (moveTouchId === null) {
                            moveTouchId = t.identifier;
                            const bRect = joystickBase.getBoundingClientRect();
                            moveStartX = bRect.left + bRect.width / 2;
                            moveStartY = bRect.top + bRect.height / 2;
                            joystickActive = true;
                        }
                        continue;
                    }
                    
                    // Look
                    if (lookTouchId === null) {
                        lookTouchId = t.identifier;
                        lookStartX = tx;
                        lookStartY = ty;
                    }
                }
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                if (!gameRunning) return;
                
                for (let i = 0; i < e.touches.length; i++) {
                    const t = e.touches[i];
                    
                    // Joystick - FIXED DIRECTION
                    if (t.identifier === moveTouchId) {
                        const dx = t.clientX - moveStartX;
                        const dy = t.clientY - moveStartY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const maxDist = 35;
                        
                        if (dist > 0) {
                            const clampedDist = Math.min(dist, maxDist);
                            const ratio = clampedDist / maxDist;
                            
                            // X is left/right (strafe), Y is forward/back
                            // Up on screen (negative dy) = forward in game
                            joystickX = (dx / dist) * ratio;
                            joystickY = (-dy / dist) * ratio;
                            
                            const vx = (dx / dist) * clampedDist;
                            const vy = (dy / dist) * clampedDist;
                            joystickKnob.style.transform = `translate(${vx}px, ${vy}px)`;
                        } else {
                            joystickX = 0;
                            joystickY = 0;
                            joystickKnob.style.transform = 'translate(0, 0)';
                        }
                    }
                    
                    // Look
                    if (t.identifier === lookTouchId) {
                        const sens = settings.sensitivity / 1500;
                        const dx = t.clientX - lookStartX;
                        const dy = t.clientY - lookStartY;
                        
                        playerState.rotation.y -= dx * sens;
                        playerState.rotation.x -= dy * sens * (settings.invertY ? -1 : 1);
                        playerState.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, playerState.rotation.x));
                        
                        lookStartX = t.clientX;
                        lookStartY = t.clientY;
                    }
                }
            }, { passive: true });
            
            document.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === moveTouchId) {
                        moveTouchId = null;
                        joystickActive = false;
                        joystickX = 0;
                        joystickY = 0;
                        joystickKnob.style.transform = 'translate(0, 0)';
                    }
                    if (t.identifier === lookTouchId) {
                        lookTouchId = null;
                    }
                }
            }, { passive: true });
        }
        
        let minimapCtx;
        function setupMinimap() {
            const c = document.getElementById('minimapCanvas');
            c.width = 90; c.height = 90;
            minimapCtx = c.getContext('2d');
        }
        
        function updateMinimap() {
            if (!minimapCtx || !settings.showMinimap) return;
            minimapCtx.fillStyle = 'rgba(20,40,20,0.9)';
            minimapCtx.fillRect(0, 0, 90, 90);
            
            const scale = 0.25;
            const cx = 45, cy = 45;
            
            // Buildings
            minimapCtx.fillStyle = '#886644';
            buildings.forEach(b => {
                const bx = cx + (b.x - playerState.position.x) * scale;
                const by = cy + (b.z - playerState.position.z) * scale;
                minimapCtx.fillRect(bx - 3, by - 3, 6, 6);
            });
            
            // Enemies
            minimapCtx.fillStyle = '#ff4444';
            enemies.forEach(e => {
                if (!e.mesh) return;
                const ex = cx + (e.mesh.position.x - playerState.position.x) * scale;
                const ey = cy + (e.mesh.position.z - playerState.position.z) * scale;
                if (ex > 0 && ex < 90 && ey > 0 && ey < 90) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(ex, ey, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            // Coins
            minimapCtx.fillStyle = 'gold';
            coins.forEach(c => {
                if (!c.mesh) return;
                const coinX = cx + (c.mesh.position.x - playerState.position.x) * scale;
                const coinY = cy + (c.mesh.position.z - playerState.position.z) * scale;
                if (coinX > 0 && coinX < 90 && coinY > 0 && coinY < 90) {
                    minimapCtx.beginPath();
                    minimapCtx.arc(coinX, coinY, 2, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            // Player
            minimapCtx.fillStyle = '#44ff44';
            minimapCtx.beginPath();
            minimapCtx.arc(cx, cy, 3, 0, Math.PI * 2);
            minimapCtx.fill();
            
            minimapCtx.strokeStyle = '#88ff88';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(cx, cy);
            minimapCtx.lineTo(cx - Math.sin(playerState.rotation.y) * 8, cy - Math.cos(playerState.rotation.y) * 8);
            minimapCtx.stroke();
        }
        
        function updateHUD() {
            const hp = (playerState.health / playerState.maxHealth) * 100;
            document.querySelector('#healthBar .bar-fill').style.width = hp + '%';
            document.querySelector('#healthBar .bar-text').textContent = Math.ceil(playerState.health) + '/' + playerState.maxHealth;
            
            const ep = (playerState.energy / playerState.maxEnergy) * 100;
            document.querySelector('#energyBar .bar-fill').style.width = ep + '%';
            document.querySelector('#energyBar .bar-text').textContent = Math.ceil(playerState.energy) + '/' + playerState.maxEnergy;
            
            document.getElementById('waveNum').textContent = currentWave;
            document.getElementById('score').textContent = playerState.score;
            document.getElementById('coinsDisplay').textContent = 'üí∞ ' + inventory.coins;
            
            for (let i = 0; i < 6; i++) {
                const el = document.getElementById('cooldown' + i);
                if (!el) continue;
                const itemId = hotbar[i];
                if (itemId && itemCooldowns[itemId] > 0) {
                    el.style.display = 'block';
                    el.textContent = Math.ceil(itemCooldowns[itemId] / 1000);
                } else {
                    el.style.display = 'none';
                }
            }
        }
        
        function useCurrentItem() {
            const itemId = hotbar[selectedSlot];
            if (!itemId) return;
            const item = itemDefs[itemId];
            if (!item || itemCooldowns[itemId] > 0) return;
            if (item.energy && playerState.energy < item.energy) return;
            
            itemCooldowns[itemId] = item.cooldown;
            if (item.energy) playerState.energy -= item.energy;
            
            // Handle by item type for easier management
            if (item.type === 'weapon') {
                // Melee weapons with different ranges
                const ranges = { spear: 3.5, gungnir: 3.5, halberd: 3.2, bo_staff: 3.0, whip: 3.5, holy_lance: 3.2,
                                 dagger: 1.8, claws: 1.8, venom_dagger: 1.8, nunchucks: 2.0, sickle: 2.2 };
                meleeAttack(item.damage, ranges[itemId] || 2.5);
            }
            else if (item.type === 'ranged') {
                // Ranged weapons
                const colors = { bow: 0x8B4513, crossbow: 0x444444, shuriken: 0xcccccc, javelin: 0x8B4513,
                                boomerang: 0xDEB887, kunai: 0x333333, chakram: 0xffd700, blowdart: 0x228B22 };
                shootProjectile(item.damage, colors[itemId] || 0xaaaaaa);
            }
            else if (item.type === 'ability' && item.damage) {
                // Magic/projectile abilities
                const colors = {
                    fireball: 0xff4400, iceball: 0x00ccff, lightning: 0xffff00, poison: 0x00ff00,
                    laser: 0xff0000, meteor: 0xff6600, tornado: 0x888888, earthquake: 0x8B4513,
                    tsunami: 0x0066ff, vortex: 0x440088, solar: 0xffff00, lunar: 0xaaaaff,
                    arcane: 0xff00ff, nature: 0x00aa00, shadow: 0x222222, holy: 0xffffcc,
                    plasma: 0xaa00ff, gravity: 0x000000, chain_lightning: 0x00ffff, frost_nova: 0x00ffff,
                    fire_storm: 0xff2200, supernova: 0xffaa00, apocalypse: 0x330000, genesis: 0xffffff,
                    oblivion: 0x000000, grenade: 0x556b2f, dynamite: 0xff0000, molotov: 0xff4500,
                    flashbang: 0xffffff, cluster_bomb: 0xff6600, nuke: 0x00ff00,
                    summon_wolf: 0x808080, summon_dragon: 0xff0000, summon_golem: 0x8B4513,
                    summon_phoenix: 0xff6600, summon_demon: 0x8b0000
                };
                shootProjectile(item.damage, colors[itemId] || 0xffffff);
            }
            else {
                // Utility abilities
                switch (itemId) {
                    case 'shield':
                        playerState.defense += 20;
                        setTimeout(() => playerState.defense -= 20, 4000);
                        break;
                    case 'medkit':
                        playerState.health = Math.min(playerState.maxHealth, playerState.health + item.healing);
                        break;
                    case 'megaHeal':
                        playerState.health = playerState.maxHealth;
                        break;
                    case 'jumpPad':
                        playerState.velocity.y = 0.25;
                        playerState.isGrounded = false;
                        break;
                    case 'speedBoost':
                        playerState.speed *= 2;
                        playerState.sprintSpeed *= 2;
                        setTimeout(() => { playerState.speed /= 2; playerState.sprintSpeed /= 2; }, 3000);
                        break;
                    case 'rage':
                        playerState.rageModeActive = true;
                        setTimeout(() => { playerState.rageModeActive = false; }, 5000);
                        break;
                    case 'invisibility':
                        playerState.invisible = true;
                        setTimeout(() => { playerState.invisible = false; }, 5000);
                        break;
                    case 'teleport':
                        const dir = new THREE.Vector3();
                        camera.getWorldDirection(dir);
                        playerState.position.x += dir.x * 10;
                        playerState.position.z += dir.z * 10;
                        break;
                    case 'reflect':
                        playerState.reflecting = true;
                        setTimeout(() => { playerState.reflecting = false; }, 4000);
                        break;
                    case 'lifesteal':
                        playerState.lifestealActive = true;
                        setTimeout(() => { playerState.lifestealActive = false; }, 6000);
                        break;
                    case 'timestop':
                        playerState.timestopActive = true;
                        setTimeout(() => { playerState.timestopActive = false; }, 3000);
                        break;
                    case 'clone':
                        // Visual effect only for now
                        break;
                    case 'berserk':
                        playerState.berserkActive = true;
                        setTimeout(() => { playerState.berserkActive = false; }, 5000);
                        break;
                    case 'fortify':
                        playerState.defense += 50;
                        setTimeout(() => playerState.defense -= 50, 6000);
                        break;
                    case 'regenerate':
                        playerState.regenerating = true;
                        setTimeout(() => { playerState.regenerating = false; }, 10000);
                        break;
                    case 'energize':
                        playerState.energy = Math.min(playerState.maxEnergy, playerState.energy + 50);
                        break;
                    case 'smoke_bomb':
                        // Escape utility
                        break;
                }
            }
        }
        
        function meleeAttack(damage, range = 2.5) {
            // Apply damage bonuses
            if (playerState.rageModeActive) damage *= 2;
            if (playerState.berserkActive) damage *= 3;

            // Start sword swing animation
            swordSwinging = true;
            swordSwingTime = 0;
            if (swordMesh) swordMesh.visible = true;

            const raycaster = new THREE.Raycaster();
            raycaster.far = range;
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            raycaster.set(camera.position, dir);

            // Create slash particle effect
            const slashPos = camera.position.clone().add(dir.clone().multiplyScalar(1));
            createSlashParticles(slashPos, dir, 0xccccff);

            const enemyMeshes = enemies.map(e => e.mesh).filter(m => m);

            // Check hits against all enemy parts
            let hitEnemy = null;
            enemies.forEach(e => {
                if (!e.mesh) return;
                const enemyPos = e.mesh.position;
                const distToEnemy = camera.position.distanceTo(enemyPos);
                if (distToEnemy < range) {
                    // Check if enemy is roughly in front of player
                    const toEnemy = enemyPos.clone().sub(camera.position).normalize();
                    const dot = toEnemy.dot(dir);
                    if (dot > 0.5) {
                        hitEnemy = e;
                    }
                }
            });

            if (hitEnemy) {
                damageEnemy(hitEnemy, damage, Math.random() < 0.15);
                // Hit particles on enemy
                const hitPos = hitEnemy.mesh.position.clone();
                hitPos.y += 0.8;
                createHitParticles(hitPos, 0xff4400);
            }

            if (boss && boss.mesh) {
                const bossPos = boss.mesh.position;
                const distToBoss = camera.position.distanceTo(bossPos);
                if (distToBoss < 3) {
                    const toBoss = bossPos.clone().sub(camera.position).normalize();
                    const dot = toBoss.dot(dir);
                    if (dot > 0.4) {
                        damageBoss(damage, Math.random() < 0.15);
                        // Hit particles on boss
                        const hitPos = boss.mesh.position.clone();
                        hitPos.y += 1.5;
                        createHitParticles(hitPos, 0xff0000);
                    }
                }
            }

            // PvP: Check for hits on other players in multiplayer mode
            if (gameMode === 'multiplayer' && isInMatch && !isDead) {
                // Send attack event to server
                if (partySocket && partySocket.readyState === WebSocket.OPEN) {
                    partySocket.send(JSON.stringify({
                        type: 'attack',
                        weapon: hotbar[selectedSlot] || 'sword',
                        position: { x: playerState.position.x, y: playerState.position.y, z: playerState.position.z },
                        direction: { x: dir.x, y: dir.y, z: dir.z }
                    }));
                }

                // Check hits against other players
                otherPlayers.forEach((playerData, playerId) => {
                    if (!playerData.mesh || playerData.data.health <= 0) return;

                    const otherPos = playerData.mesh.position.clone();
                    otherPos.y += 1.0; // Adjust for mesh offset
                    const distToPlayer = camera.position.distanceTo(otherPos);

                    if (distToPlayer < range) {
                        const toPlayer = otherPos.clone().sub(camera.position).normalize();
                        const dot = toPlayer.dot(dir);
                        if (dot > 0.5) {
                            // Hit! Send damage to server
                            if (partySocket && partySocket.readyState === WebSocket.OPEN) {
                                partySocket.send(JSON.stringify({
                                    type: 'damage',
                                    targetId: playerId,
                                    damage: damage
                                }));
                            }
                            // Visual feedback
                            const hitPos = otherPos.clone();
                            createHitParticles(hitPos, 0xff0000);
                        }
                    }
                });
            }
        }
        
        function shootProjectile(damage, color) {
            // Apply damage bonuses
            if (playerState.rageModeActive) damage *= 2;
            if (playerState.berserkActive) damage *= 3;

            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);

            // Cast particles at player position
            const castPos = camera.position.clone().add(dir.clone().multiplyScalar(0.5));
            createMagicParticles(castPos, color, 8, 0.05);

            const geo = new THREE.SphereGeometry(0.15, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color });
            const proj = new THREE.Mesh(geo, mat);
            proj.position.copy(camera.position);
            scene.add(proj);

            // Add glow effect to projectile
            const glowGeo = new THREE.SphereGeometry(0.22, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            proj.add(glow);

            projectiles.push({ mesh: proj, direction: dir.clone(), speed: 0.25, damage, life: 3000, color: color, trailTimer: 0 });
        }
        
        function jump() {
            if (playerState.isGrounded) {
                playerState.velocity.y = 0.1;
                playerState.isGrounded = false;
            }
        }
        
        function dash() {
            if (playerState.energy < 10) return;
            playerState.energy -= 10;
            
            let mx = 0, mz = 0;
            if (deviceMode === 'mobile') {
                mx = joystickX;
                mz = joystickY;
            } else {
                if (keys['KeyW']) mz = -1;
                if (keys['KeyS']) mz = 1;
                if (keys['KeyA']) mx = -1;
                if (keys['KeyD']) mx = 1;
            }
            
            const sin = Math.sin(playerState.rotation.y);
            const cos = Math.cos(playerState.rotation.y);
            const wx = mx * cos + mz * sin;
            const wz = mz * cos - mx * sin;

            if (wx === 0 && wz === 0) return;
            const len = Math.sqrt(wx * wx + wz * wz);
            
            const newX = playerState.position.x + (wx / len) * 2;
            const newZ = playerState.position.z + (wz / len) * 2;
            
            if (!checkCollision(newX, newZ)) {
                playerState.position.x = newX;
                playerState.position.z = newZ;
            }
        }
        
        function checkCollision(x, z) {
            const r = 0.35;
            for (const col of colliders) {
                const dx = x - col.position.x;
                const dz = z - col.position.z;
                
                if (col.type === 'cylinder' || col.type === 'sphere') {
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < col.radius + r) {
                        if (settings.autoJump && col.canAutoJump && playerState.isGrounded) {
                            playerState.velocity.y = 0.08;
                            playerState.isGrounded = false;
                            return false;
                        }
                        return true;
                    }
                } else if (col.type === 'box') {
                    if (Math.abs(dx) < col.width / 2 + r && Math.abs(dz) < col.depth / 2 + r) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Enemy types with different stats and appearances - more detailed
        const enemyTypes = [
            { name: 'Grunt', bodyColor: 0x8B4513, skinColor: 0xDEB887, eyeColor: 0xff3300,
              armorColor: 0x654321, accentColor: 0xA0522D, glowColor: null,
              weapon: 'sword', weaponColor: 0xcccccc, health: 1.0, damage: 1.0, speed: 1.0,
              hasCape: false, hasAura: false, scarCount: 1, scale: 1.0 },
            { name: 'Brute', bodyColor: 0x8B0000, skinColor: 0xCD5C5C, eyeColor: 0xffff00,
              armorColor: 0x2F1010, accentColor: 0xff4444, glowColor: 0xff2200,
              weapon: 'axe', weaponColor: 0x555555, health: 1.8, damage: 1.6, speed: 0.7,
              hasCape: false, hasAura: true, scarCount: 3, scale: 1.15 },
            { name: 'Assassin', bodyColor: 0x1a0a1a, skinColor: 0x9370DB, eyeColor: 0x00ffff,
              armorColor: 0x2d1f3d, accentColor: 0x8A2BE2, glowColor: 0x00ffff,
              weapon: 'dagger', weaponColor: 0x222222, health: 0.6, damage: 1.3, speed: 1.5,
              hasCape: true, hasAura: false, scarCount: 0, scale: 0.9 },
            { name: 'Mage', bodyColor: 0x191970, skinColor: 0xB0C4DE, eyeColor: 0xff00ff,
              armorColor: 0x0a0a40, accentColor: 0x4169E1, glowColor: 0x9400D3,
              weapon: 'staff', weaponColor: 0x9400D3, health: 0.7, damage: 1.8, speed: 0.9,
              hasCape: true, hasAura: true, scarCount: 0, scale: 1.0 },
            { name: 'Knight', bodyColor: 0x2F4F4F, skinColor: 0xC0C0C0, eyeColor: 0xff4400,
              armorColor: 0x708090, accentColor: 0xFFD700, glowColor: null,
              weapon: 'hammer', weaponColor: 0x4a4a4a, health: 2.2, damage: 2.0, speed: 0.6,
              hasCape: true, hasAura: false, scarCount: 2, scale: 1.1 }
        ];

        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 18 + Math.random() * 12;
            const x = playerState.position.x + Math.cos(angle) * distance;
            const z = playerState.position.z + Math.sin(angle) * distance;
            const terrainY = getTerrainHeight(x, z);

            // Pick random enemy type
            const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];

            // Create enemy group for body parts
            const enemyGroup = new THREE.Group();

            // Body (torso) with armor
            const bodyGeo = new THREE.CylinderGeometry(0.28, 0.34, 0.85, 12);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: type.armorColor,
                roughness: 0.4,
                metalness: type.name === 'Knight' ? 0.7 : 0.2
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            enemyGroup.add(body);

            // Chest plate / armor detail
            const chestGeo = new THREE.BoxGeometry(0.45, 0.35, 0.2);
            const chestMat = new THREE.MeshStandardMaterial({
                color: type.bodyColor,
                roughness: 0.3,
                metalness: type.name === 'Knight' ? 0.8 : 0.3
            });
            const chest = new THREE.Mesh(chestGeo, chestMat);
            chest.position.set(0, 0.7, 0.12);
            chest.castShadow = true;
            enemyGroup.add(chest);

            // Belt
            const beltGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.08, 12);
            const beltMat = new THREE.MeshStandardMaterial({ color: type.accentColor, roughness: 0.5, metalness: 0.4 });
            const belt = new THREE.Mesh(beltGeo, beltMat);
            belt.position.y = 0.25;
            enemyGroup.add(belt);

            // Belt buckle
            const buckleMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.9, roughness: 0.2 });
            const buckle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.08, 0.05), buckleMat);
            buckle.position.set(0, 0.25, 0.36);
            enemyGroup.add(buckle);

            // Head with better detail
            const headGeo = new THREE.SphereGeometry(0.24, 16, 14);
            const headMat = new THREE.MeshStandardMaterial({
                color: type.skinColor,
                roughness: 0.7,
                metalness: 0.1
            });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.18;
            head.castShadow = true;
            enemyGroup.add(head);

            // Type-specific headgear
            if (type.name === 'Knight') {
                // Helmet
                const helmetGeo = new THREE.SphereGeometry(0.27, 12, 10, 0, Math.PI * 2, 0, Math.PI * 0.6);
                const helmetMat = new THREE.MeshStandardMaterial({ color: type.armorColor, metalness: 0.8, roughness: 0.3 });
                const helmet = new THREE.Mesh(helmetGeo, helmetMat);
                helmet.position.y = 1.25;
                enemyGroup.add(helmet);
                // Helmet visor
                const visorGeo = new THREE.BoxGeometry(0.3, 0.08, 0.15);
                const visor = new THREE.Mesh(visorGeo, new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9 }));
                visor.position.set(0, 1.18, 0.18);
                enemyGroup.add(visor);
            } else if (type.name === 'Mage') {
                // Wizard hood
                const hoodGeo = new THREE.ConeGeometry(0.3, 0.4, 8);
                const hoodMat = new THREE.MeshStandardMaterial({ color: type.armorColor, roughness: 0.8 });
                const hood = new THREE.Mesh(hoodGeo, hoodMat);
                hood.position.y = 1.45;
                enemyGroup.add(hood);
            } else if (type.name === 'Assassin') {
                // Hood/mask
                const maskGeo = new THREE.SphereGeometry(0.26, 12, 10, 0, Math.PI * 2, 0, Math.PI * 0.7);
                const maskMat = new THREE.MeshStandardMaterial({ color: 0x1a0a1a, roughness: 0.9 });
                const mask = new THREE.Mesh(maskGeo, maskMat);
                mask.position.y = 1.22;
                enemyGroup.add(mask);
            } else if (type.name === 'Brute') {
                // Horns
                const hornGeo = new THREE.ConeGeometry(0.06, 0.2, 6);
                const hornMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6 });
                const leftHorn = new THREE.Mesh(hornGeo, hornMat);
                leftHorn.position.set(-0.15, 1.35, 0);
                leftHorn.rotation.z = 0.4;
                enemyGroup.add(leftHorn);
                const rightHorn = new THREE.Mesh(hornGeo, hornMat);
                rightHorn.position.set(0.15, 1.35, 0);
                rightHorn.rotation.z = -0.4;
                enemyGroup.add(rightHorn);
            }

            // Eyes with glow effect
            const eyeGeo = new THREE.SphereGeometry(0.055, 10, 10);
            const eyeMat = new THREE.MeshStandardMaterial({
                color: type.eyeColor,
                emissive: type.eyeColor,
                emissiveIntensity: 0.8
            });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.09, 1.2, 0.19);
            enemyGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.09, 1.2, 0.19);
            enemyGroup.add(rightEye);

            // Eye pupils
            const pupilGeo = new THREE.SphereGeometry(0.025, 8, 8);
            const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.set(-0.09, 1.2, 0.24);
            enemyGroup.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
            rightPupil.position.set(0.09, 1.2, 0.24);
            enemyGroup.add(rightPupil);

            // Mouth with teeth
            const mouthGeo = new THREE.BoxGeometry(0.14, 0.05, 0.06);
            const mouthMat = new THREE.MeshStandardMaterial({ color: 0x220000 });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, 1.06, 0.19);
            enemyGroup.add(mouth);

            // Teeth
            for (let i = -2; i <= 2; i++) {
                const toothGeo = new THREE.BoxGeometry(0.02, 0.03, 0.02);
                const toothMat = new THREE.MeshStandardMaterial({ color: 0xffffee });
                const tooth = new THREE.Mesh(toothGeo, toothMat);
                tooth.position.set(i * 0.025, 1.045, 0.22);
                enemyGroup.add(tooth);
            }

            // Shoulder pads
            const shoulderGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const shoulderMat = new THREE.MeshStandardMaterial({
                color: type.bodyColor,
                metalness: type.name === 'Knight' ? 0.8 : 0.3,
                roughness: 0.4
            });
            const leftShoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
            leftShoulder.position.set(-0.42, 0.95, 0);
            leftShoulder.scale.set(1, 0.7, 0.8);
            enemyGroup.add(leftShoulder);

            const rightShoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
            rightShoulder.position.set(0.42, 0.95, 0);
            rightShoulder.scale.set(1, 0.7, 0.8);
            enemyGroup.add(rightShoulder);

            // Arms with better detail
            const upperArmGeo = new THREE.CylinderGeometry(0.07, 0.08, 0.3, 10);
            const armMat = new THREE.MeshStandardMaterial({ color: type.skinColor, roughness: 0.7 });

            const leftArm = new THREE.Group();
            const leftUpperArm = new THREE.Mesh(upperArmGeo, armMat);
            leftUpperArm.position.y = -0.15;
            leftArm.add(leftUpperArm);
            // Forearm with armor
            const forearmGeo = new THREE.CylinderGeometry(0.055, 0.07, 0.28, 8);
            const forearmMat = new THREE.MeshStandardMaterial({ color: type.armorColor, roughness: 0.5, metalness: 0.3 });
            const leftForearm = new THREE.Mesh(forearmGeo, forearmMat);
            leftForearm.position.y = -0.38;
            leftArm.add(leftForearm);
            // Hand
            const handGeo = new THREE.SphereGeometry(0.06, 8, 8);
            const leftHand = new THREE.Mesh(handGeo, armMat);
            leftHand.position.y = -0.52;
            leftArm.add(leftHand);
            leftArm.position.set(-0.42, 0.85, 0);
            leftArm.rotation.z = 0.2;
            enemyGroup.add(leftArm);

            const rightArm = new THREE.Group();
            const rightUpperArm = new THREE.Mesh(upperArmGeo, armMat);
            rightUpperArm.position.y = -0.15;
            rightArm.add(rightUpperArm);
            const rightForearm = new THREE.Mesh(forearmGeo, forearmMat);
            rightForearm.position.y = -0.38;
            rightArm.add(rightForearm);
            const rightHand = new THREE.Mesh(handGeo, armMat);
            rightHand.position.y = -0.52;
            rightArm.add(rightHand);
            rightArm.position.set(0.42, 0.85, 0);
            rightArm.rotation.z = -0.2;
            enemyGroup.add(rightArm);

            // Add weapon to right hand
            const weaponGroup = new THREE.Group();
            const weaponMat = new THREE.MeshStandardMaterial({ color: type.weaponColor, metalness: 0.9, roughness: 0.2 });

            if (type.weapon === 'sword') {
                // Detailed sword
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.55, 0.02), weaponMat);
                blade.position.y = -0.32;
                weaponGroup.add(blade);
                // Sword edge highlight
                const edgeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1, roughness: 0.1 });
                const edge = new THREE.Mesh(new THREE.BoxGeometry(0.052, 0.55, 0.005), edgeMat);
                edge.position.set(0, -0.32, 0.01);
                weaponGroup.add(edge);
                // Guard
                const guard = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.03, 0.04),
                    new THREE.MeshStandardMaterial({ color: 0xDAA520, metalness: 0.8 }));
                guard.position.y = -0.02;
                weaponGroup.add(guard);
                // Handle
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.14, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.9 }));
                handle.position.y = 0.05;
                weaponGroup.add(handle);
                // Pommel
                const pommel = new THREE.Mesh(new THREE.SphereGeometry(0.035, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0xDAA520, metalness: 0.8 }));
                pommel.position.y = 0.14;
                weaponGroup.add(pommel);
            } else if (type.weapon === 'axe') {
                // Detailed axe
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.035, 0.7, 8),
                    new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 }));
                handle.position.y = -0.4;
                weaponGroup.add(handle);
                // Axe head - curved
                const axeHeadShape = new THREE.Shape();
                axeHeadShape.moveTo(0, 0);
                axeHeadShape.quadraticCurveTo(0.2, 0.1, 0.18, 0.2);
                axeHeadShape.lineTo(0.05, 0.2);
                axeHeadShape.lineTo(0.05, -0.2);
                axeHeadShape.lineTo(0.18, -0.2);
                axeHeadShape.quadraticCurveTo(0.2, -0.1, 0, 0);
                const axeHeadGeo = new THREE.ExtrudeGeometry(axeHeadShape, { depth: 0.03, bevelEnabled: false });
                const axeHead = new THREE.Mesh(axeHeadGeo, weaponMat);
                axeHead.position.set(-0.02, -0.65, -0.015);
                axeHead.rotation.z = Math.PI;
                weaponGroup.add(axeHead);
            } else if (type.weapon === 'dagger') {
                // Sleek dagger
                const blade = new THREE.Mesh(new THREE.ConeGeometry(0.03, 0.3, 4), weaponMat);
                blade.position.y = -0.2;
                blade.rotation.z = Math.PI;
                weaponGroup.add(blade);
                const guard = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.02, 0.03),
                    new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.7 }));
                guard.position.y = -0.03;
                weaponGroup.add(guard);
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.022, 0.1, 6),
                    new THREE.MeshStandardMaterial({ color: 0x1a0a1a }));
                handle.position.y = 0.03;
                weaponGroup.add(handle);
            } else if (type.weapon === 'staff') {
                // Magical staff
                const staff = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.035, 1.1, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.7 }));
                staff.position.y = -0.6;
                weaponGroup.add(staff);
                // Staff rings
                for (let i = 0; i < 3; i++) {
                    const ring = new THREE.Mesh(new THREE.TorusGeometry(0.04, 0.008, 8, 16),
                        new THREE.MeshStandardMaterial({ color: 0xDAA520, metalness: 0.9 }));
                    ring.position.y = -0.2 - i * 0.25;
                    ring.rotation.x = Math.PI / 2;
                    weaponGroup.add(ring);
                }
                // Crystal orb
                const orb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16),
                    new THREE.MeshStandardMaterial({
                        color: type.weaponColor,
                        emissive: type.weaponColor,
                        emissiveIntensity: 0.7,
                        transparent: true,
                        opacity: 0.9
                    }));
                orb.position.y = -1.15;
                weaponGroup.add(orb);
                // Orb glow
                const glow = new THREE.Mesh(new THREE.SphereGeometry(0.13, 12, 12),
                    new THREE.MeshBasicMaterial({
                        color: type.weaponColor,
                        transparent: true,
                        opacity: 0.3
                    }));
                glow.position.y = -1.15;
                weaponGroup.add(glow);
            } else if (type.weapon === 'hammer') {
                // War hammer
                const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.04, 0.6, 8),
                    new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.7 }));
                handle.position.y = -0.35;
                weaponGroup.add(handle);
                // Leather grip
                const grip = new THREE.Mesh(new THREE.CylinderGeometry(0.042, 0.042, 0.2, 8),
                    new THREE.MeshStandardMaterial({ color: 0x2a1a0a, roughness: 0.9 }));
                grip.position.y = -0.1;
                weaponGroup.add(grip);
                // Hammer head
                const hammerHead = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.15, 0.18), weaponMat);
                hammerHead.position.y = -0.65;
                weaponGroup.add(hammerHead);
                // Metal bands
                const bandMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.9 });
                const band1 = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.02, 0.2), bandMat);
                band1.position.y = -0.58;
                weaponGroup.add(band1);
                const band2 = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.02, 0.2), bandMat);
                band2.position.y = -0.72;
                weaponGroup.add(band2);
            }

            weaponGroup.position.set(0.42, 0.32, 0.18);
            weaponGroup.rotation.x = -0.6;
            enemyGroup.add(weaponGroup);

            // Legs with boots
            const thighGeo = new THREE.CylinderGeometry(0.09, 0.1, 0.3, 10);
            const legMat = new THREE.MeshStandardMaterial({ color: type.armorColor, roughness: 0.6 });
            const bootMat = new THREE.MeshStandardMaterial({ color: type.bodyColor, roughness: 0.5, metalness: 0.2 });

            const leftLeg = new THREE.Group();
            const leftThigh = new THREE.Mesh(thighGeo, legMat);
            leftThigh.position.y = -0.15;
            leftLeg.add(leftThigh);
            const leftShin = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.08, 0.28, 8), legMat);
            leftShin.position.y = -0.38;
            leftLeg.add(leftShin);
            const leftBoot = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.18), bootMat);
            leftBoot.position.set(0, -0.52, 0.03);
            leftLeg.add(leftBoot);
            leftLeg.position.set(-0.14, 0.22, 0);
            enemyGroup.add(leftLeg);

            const rightLeg = new THREE.Group();
            const rightThigh = new THREE.Mesh(thighGeo, legMat);
            rightThigh.position.y = -0.15;
            rightLeg.add(rightThigh);
            const rightShin = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.08, 0.28, 8), legMat);
            rightShin.position.y = -0.38;
            rightLeg.add(rightShin);
            const rightBoot = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.18), bootMat);
            rightBoot.position.set(0, -0.52, 0.03);
            rightLeg.add(rightBoot);
            rightLeg.position.set(0.14, 0.22, 0);
            enemyGroup.add(rightLeg);

            // Add cape for certain enemy types
            if (type.hasCape) {
                const capeGroup = new THREE.Group();
                // Cape main body - flowing cloth
                const capeGeo = new THREE.PlaneGeometry(0.7, 0.9, 4, 6);
                const capeMat = new THREE.MeshStandardMaterial({
                    color: type.name === 'Knight' ? 0x8B0000 : type.armorColor,
                    roughness: 0.9,
                    side: THREE.DoubleSide
                });
                const cape = new THREE.Mesh(capeGeo, capeMat);
                cape.position.set(0, 0.5, -0.35);
                cape.rotation.x = 0.2;
                capeGroup.add(cape);
                // Cape collar
                const collarGeo = new THREE.TorusGeometry(0.32, 0.04, 8, 16, Math.PI);
                const collarMat = new THREE.MeshStandardMaterial({ color: type.accentColor, metalness: 0.6 });
                const collar = new THREE.Mesh(collarGeo, collarMat);
                collar.position.set(0, 1.0, -0.15);
                collar.rotation.x = Math.PI / 2;
                collar.rotation.z = Math.PI;
                capeGroup.add(collar);
                enemyGroup.add(capeGroup);
            }

            // Add glowing aura for certain enemy types
            if (type.hasAura && type.glowColor) {
                const auraGeo = new THREE.SphereGeometry(0.8, 12, 12);
                const auraMat = new THREE.MeshBasicMaterial({
                    color: type.glowColor,
                    transparent: true,
                    opacity: 0.15
                });
                const aura = new THREE.Mesh(auraGeo, auraMat);
                aura.position.y = 0.7;
                enemyGroup.add(aura);
                // Inner aura glow
                const innerAuraGeo = new THREE.SphereGeometry(0.5, 10, 10);
                const innerAuraMat = new THREE.MeshBasicMaterial({
                    color: type.glowColor,
                    transparent: true,
                    opacity: 0.25
                });
                const innerAura = new THREE.Mesh(innerAuraGeo, innerAuraMat);
                innerAura.position.y = 0.7;
                enemyGroup.add(innerAura);
            }

            // Add battle scars/markings
            for (let s = 0; s < type.scarCount; s++) {
                const scarGeo = new THREE.BoxGeometry(0.02, 0.12 + Math.random() * 0.08, 0.01);
                const scarMat = new THREE.MeshStandardMaterial({ color: 0x330000 });
                const scar = new THREE.Mesh(scarGeo, scarMat);
                // Random position on face/body
                if (s === 0) {
                    scar.position.set(-0.05 + Math.random() * 0.1, 1.15, 0.23);
                    scar.rotation.z = -0.3 + Math.random() * 0.6;
                } else {
                    scar.position.set((Math.random() - 0.5) * 0.3, 0.5 + Math.random() * 0.4, 0.25);
                    scar.rotation.z = -0.5 + Math.random();
                }
                enemyGroup.add(scar);
            }

            // Add armor rivets/details for Knight
            if (type.name === 'Knight') {
                const rivetMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9 });
                for (let r = 0; r < 6; r++) {
                    const rivet = new THREE.Mesh(new THREE.SphereGeometry(0.02, 6, 6), rivetMat);
                    rivet.position.set(
                        -0.18 + (r % 3) * 0.18,
                        0.55 + Math.floor(r / 3) * 0.2,
                        0.22
                    );
                    enemyGroup.add(rivet);
                }
            }

            // Add magical runes for Mage
            if (type.name === 'Mage') {
                const runeMat = new THREE.MeshBasicMaterial({
                    color: type.weaponColor,
                    transparent: true,
                    opacity: 0.8
                });
                // Floating rune circles
                for (let r = 0; r < 3; r++) {
                    const runeRing = new THREE.Mesh(new THREE.TorusGeometry(0.08 + r * 0.03, 0.008, 8, 16), runeMat);
                    runeRing.position.set((r - 1) * 0.25, 0.6 + Math.sin(r) * 0.1, 0.35);
                    runeRing.rotation.x = Math.PI / 2 + Math.random() * 0.3;
                    enemyGroup.add(runeRing);
                }
            }

            // Add spikes for Brute
            if (type.name === 'Brute') {
                const spikeMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8 });
                // Shoulder spikes
                for (let sp = 0; sp < 4; sp++) {
                    const spike = new THREE.Mesh(new THREE.ConeGeometry(0.03, 0.12, 6), spikeMat);
                    const side = sp < 2 ? -1 : 1;
                    spike.position.set(side * 0.48, 0.95 + (sp % 2) * 0.08, (sp % 2) * 0.05);
                    spike.rotation.z = side * 0.8;
                    enemyGroup.add(spike);
                }
                // Back spikes
                for (let bs = 0; bs < 3; bs++) {
                    const backSpike = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.15, 6), spikeMat);
                    backSpike.position.set((bs - 1) * 0.15, 0.8 + bs * 0.05, -0.3);
                    backSpike.rotation.x = 0.5;
                    enemyGroup.add(backSpike);
                }
            }

            // Add smoke/shadow effect for Assassin
            if (type.name === 'Assassin') {
                const smokeMat = new THREE.MeshBasicMaterial({
                    color: 0x1a0a2a,
                    transparent: true,
                    opacity: 0.3
                });
                for (let sm = 0; sm < 5; sm++) {
                    const smoke = new THREE.Mesh(new THREE.SphereGeometry(0.1 + Math.random() * 0.1, 8, 8), smokeMat);
                    smoke.position.set(
                        (Math.random() - 0.5) * 0.6,
                        Math.random() * 0.5,
                        (Math.random() - 0.5) * 0.6
                    );
                    enemyGroup.add(smoke);
                }
            }

            // Apply type-specific scale
            enemyGroup.scale.setScalar(type.scale);

            enemyGroup.position.set(x, terrainY, z);
            scene.add(enemyGroup);

            const baseHealth = 30 * (1 + currentWave * 0.08);
            const baseDamage = 10 + currentWave * 1.5;
            const baseSpeed = 0.004 + currentWave * 0.0003;

            enemies.push({
                mesh: enemyGroup,
                type: type.name,
                health: baseHealth * type.health,
                maxHealth: baseHealth * type.health,
                damage: baseDamage * type.damage,
                speed: baseSpeed * type.speed,
                attackCooldown: 0,
                radius: 0.5,
                leftArm: leftArm,
                rightArm: rightArm,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                animTime: Math.random() * Math.PI * 2
            });
        }
        
        function spawnBoss() {
            const angle = Math.random() * Math.PI * 2;
            const x = playerState.position.x + Math.cos(angle) * 28;
            const z = playerState.position.z + Math.sin(angle) * 28;
            const terrainY = getTerrainHeight(x, z);
            
            // Create boss group
            const bossGroup = new THREE.Group();
            
            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.7, 0.9, 1.8, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x440000, emissive: 0x220000, emissiveIntensity: 0.2, roughness: 0.6 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.2;
            body.castShadow = true;
            bossGroup.add(body);
            
            // Head
            const headGeo = new THREE.SphereGeometry(0.5, 14, 12);
            const headMat = new THREE.MeshStandardMaterial({ color: 0x660000, roughness: 0.5 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 2.4;
            head.castShadow = true;
            bossGroup.add(head);
            
            // Glowing eyes
            const eyeGeo = new THREE.SphereGeometry(0.1, 10, 10);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 });
            
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.18, 2.5, 0.4);
            bossGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.18, 2.5, 0.4);
            bossGroup.add(rightEye);
            
            // Mouth/teeth
            const mouthGeo = new THREE.BoxGeometry(0.3, 0.1, 0.1);
            const mouthMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.position.set(0, 2.25, 0.45);
            bossGroup.add(mouth);
            
            // Horns
            const hornGeo = new THREE.ConeGeometry(0.1, 0.5, 8);
            const hornMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4 });
            
            const leftHorn = new THREE.Mesh(hornGeo, hornMat);
            leftHorn.position.set(-0.35, 2.8, 0);
            leftHorn.rotation.z = 0.4;
            bossGroup.add(leftHorn);
            
            const rightHorn = new THREE.Mesh(hornGeo, hornMat);
            rightHorn.position.set(0.35, 2.8, 0);
            rightHorn.rotation.z = -0.4;
            bossGroup.add(rightHorn);
            
            // Arms
            const armGeo = new THREE.CylinderGeometry(0.15, 0.2, 1.2, 10);
            const armMat = new THREE.MeshStandardMaterial({ color: 0x550000, roughness: 0.6 });
            
            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(-0.95, 1.4, 0);
            leftArm.rotation.z = 0.4;
            bossGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(0.95, 1.4, 0);
            rightArm.rotation.z = -0.4;
            bossGroup.add(rightArm);
            
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.18, 0.22, 0.9, 10);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x330000, roughness: 0.7 });
            
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.3, 0.45, 0);
            bossGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.3, 0.45, 0);
            bossGroup.add(rightLeg);
            
            bossGroup.position.set(x, terrainY, z);
            scene.add(bossGroup);
            
            boss = {
                mesh: bossGroup,
                health: 180 + currentWave * 25,
                maxHealth: 180 + currentWave * 25,
                damage: 20 + currentWave * 3,
                speed: 0.004,
                attackCooldown: 0,
                leftArm: leftArm,
                rightArm: rightArm,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                animTime: 0
            };
            
            document.getElementById('bossHealth').style.display = 'block';
            document.getElementById('bossName').textContent = 'BOSS - Wave ' + currentWave;
            announceWave('‚ö†Ô∏è BOSS');
        }
        
        function damageEnemy(enemy, damage, isCrit) {
            if (enemy.dying) return; // Don't damage dying enemies
            enemy.health -= damage;
            if (settings.showDamageNumbers) showDamageNumber(enemy.mesh.position, damage, isCrit);

            // Flash all meshes in the enemy group white
            enemy.mesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.emissive = new THREE.Color(0xffffff);
                    child.material.emissiveIntensity = 1;
                    setTimeout(() => {
                        if (child.material) child.material.emissiveIntensity = 0;
                    }, 80);
                }
            });

            if (enemy.health <= 0) killEnemy(enemy);
        }
        
        function damageBoss(damage, isCrit) {
            boss.health -= damage;
            if (settings.showDamageNumbers) showDamageNumber(boss.mesh.position, damage, isCrit);
            document.getElementById('bossFill').style.width = (boss.health / boss.maxHealth * 100) + '%';
            if (boss.health <= 0) killBoss();
        }
        
        function showDamageNumber(pos, damage, isCrit) {
            const sp = pos.clone().project(camera);
            const x = (sp.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-sp.y * 0.5 + 0.5) * window.innerHeight;
            
            const div = document.createElement('div');
            div.className = 'damage-number';
            div.textContent = Math.round(damage);
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.style.color = isCrit ? '#ffff00' : '#ffffff';
            div.style.fontSize = isCrit ? '20px' : '14px';
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }
        
        function killEnemy(enemy) {
            if (enemy.dying) return;
            enemy.dying = true;

            // Death particles
            const deathPos = enemy.mesh.position.clone();
            deathPos.y += 0.7;
            createDeathParticles(deathPos, 0x880000);

            spawnCoin(enemy.mesh.position.clone());

            playerState.score += 100;
            playerState.kills++;
            playerState.health = Math.min(playerState.maxHealth, playerState.health + 2);
            playerState.energy = Math.min(playerState.maxEnergy, playerState.energy + 5);
            updateHUD();

            // Death animation: fall over and fade out
            const startY = enemy.mesh.position.y;
            const startRotation = enemy.mesh.rotation.x;
            let deathTime = 0;
            const deathDuration = 600;

            function animateDeath() {
                deathTime += 16;
                const progress = Math.min(deathTime / deathDuration, 1);

                // Fall backwards
                enemy.mesh.rotation.x = startRotation + progress * (Math.PI / 2);
                enemy.mesh.position.y = startY - progress * 0.5;

                // Fade out all materials
                enemy.mesh.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.transparent = true;
                        child.material.opacity = 1 - progress;
                    }
                });

                if (progress < 1) {
                    requestAnimationFrame(animateDeath);
                } else {
                    // Remove enemy after animation
                    scene.remove(enemy.mesh);
                    const idx = enemies.indexOf(enemy);
                    if (idx > -1) enemies.splice(idx, 1);
                    checkWaveComplete();
                }
            }

            animateDeath();
        }
        
        function killBoss() {
            // Massive death explosion for boss
            const bossPos = boss.mesh.position.clone();
            bossPos.y += 1.2;
            createExplosionParticles(bossPos, 0xff0000, 0xff6600);
            createDeathParticles(bossPos, 0x660000);
            createMagicParticles(bossPos, 0xffff00, 20, 0.1);
            // Extra explosions around boss
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const offsetPos = bossPos.clone();
                    offsetPos.x += (Math.random() - 0.5) * 2;
                    offsetPos.y += (Math.random() - 0.5) * 1;
                    offsetPos.z += (Math.random() - 0.5) * 2;
                    createExplosionParticles(offsetPos, 0xff4400, 0xffaa00);
                }, i * 150);
            }

            for (let i = 0; i < 6; i++) {
                const pos = boss.mesh.position.clone();
                pos.x += (Math.random() - 0.5) * 3;
                pos.z += (Math.random() - 0.5) * 3;
                spawnCoin(pos);
            }

            scene.remove(boss.mesh);
            playerState.score += 1000;
            playerState.health = playerState.maxHealth;
            playerState.energy = playerState.maxEnergy;

            boss = null;
            document.getElementById('bossHealth').style.display = 'none';
            announceWave('BOSS DEFEATED!');
            updateHUD();

            setTimeout(() => { currentWave++; startWave(); }, 3000);
        }
        
        function spawnCoin(position) {
            const geo = new THREE.CylinderGeometry(0.2, 0.2, 0.06, 16);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.1 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(position);
            const terrainY = getTerrainHeight(position.x, position.z);
            mesh.position.y = terrainY + 0.5;
            mesh.rotation.x = Math.PI / 2;
            scene.add(mesh);
            
            coins.push({ mesh, value: 5 + Math.floor(currentWave / 2), bobOffset: Math.random() * Math.PI * 2, baseY: terrainY + 0.5 });
        }
        
        function damagePlayer(damage) {
            const finalDamage = Math.max(1, damage - playerState.defense);
            playerState.health -= finalDamage;
            
            const v = document.createElement('div');
            v.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle,transparent 40%,rgba(255,0,0,0.25) 100%);pointer-events:none;z-index:150;';
            document.body.appendChild(v);
            setTimeout(() => v.remove(), 150);
            
            if (playerState.health <= 0) gameOver();
            updateHUD();
        }
        
        function announceWave(text) {
            const el = document.getElementById('waveAnnounce');
            el.textContent = text;
            el.style.opacity = '1';
            setTimeout(() => el.style.opacity = '0', 2000);
        }
        
        function startWave() {
            waveInProgress = true;
            announceWave('WAVE ' + currentWave);
            
            const count = 3 + currentWave * 2;
            let spawned = 0;
            const interval = setInterval(() => {
                if (spawned >= count) {
                    clearInterval(interval);
                    if (currentWave % 5 === 0) setTimeout(spawnBoss, 2000);
                    return;
                }
                spawnEnemy();
                spawned++;
            }, 800);
        }
        
        function checkWaveComplete() {
            if (enemies.length === 0 && !boss && waveInProgress) {
                waveInProgress = false;
                playerState.score += currentWave * 50;
                playerState.health = Math.min(playerState.maxHealth, playerState.health + 10);
                announceWave('WAVE COMPLETE!');
                setTimeout(() => { currentWave++; startWave(); }, 3000);
            }
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalWave').textContent = currentWave;
            document.getElementById('finalScore').textContent = playerState.score;
            document.getElementById('finalCoins').textContent = inventory.coins;
            document.getElementById('gameOver').style.display = 'flex';
            document.getElementById('clickToPlay').style.display = 'none';
            // Release pointer lock so user can click buttons
            if (document.exitPointerLock) document.exitPointerLock();
            saveCoinsToCloud(); // Save coins when game ends
        }
        
        // Get terrain height at any position
        function updatePlayer(dt) {
            // VERY SLOW speeds
            const baseSpeed = 0.015 + (settings.walkSpeed - 50) * 0.0003;
            const baseSprint = 0.025 + (settings.sprintSpeed - 50) * 0.0005;
            
            const isSprint = keys['ShiftLeft'];
            const speed = isSprint ? baseSprint : baseSpeed;
            
            let mx = 0, mz = 0;
            
            if (deviceMode === 'mobile') {
                // joystickX = strafe (left/right), joystickY = forward/back
                mx = joystickX;
                mz = joystickY;
            } else {
                if (keys['KeyW']) mz = -1;  // Forward
                if (keys['KeyS']) mz = 1; // Backward
                if (keys['KeyA']) mx = -1; // Strafe left
                if (keys['KeyD']) mx = 1;  // Strafe right
                if (mx !== 0 && mz !== 0) {
                    const len = Math.sqrt(mx * mx + mz * mz);
                    mx /= len;
                    mz /= len;
                }
            }
            
            // Calculate world movement based on camera direction
            // Forward (positive mz) moves in camera's look direction
            const sin = Math.sin(playerState.rotation.y);
            const cos = Math.cos(playerState.rotation.y);

            // Standard FPS movement relative to camera direction
            // W = forward (where you're looking), S = backward, A = strafe left, D = strafe right
            const worldMoveX = mx * cos + mz * sin;
            const worldMoveZ = mz * cos - mx * sin;
            
            const moveAmount = speed * dt;
            const newX = playerState.position.x + worldMoveX * moveAmount;
            const newZ = playerState.position.z + worldMoveZ * moveAmount;
            
            if (!checkCollision(newX, newZ)) {
                playerState.position.x = newX;
                playerState.position.z = newZ;
            } else {
                if (!checkCollision(newX, playerState.position.z)) playerState.position.x = newX;
                else if (!checkCollision(playerState.position.x, newZ)) playerState.position.z = newZ;
            }
            
            playerState.position.x = Math.max(-120, Math.min(120, playerState.position.x));
            playerState.position.z = Math.max(-120, Math.min(120, playerState.position.z));
            
            // Gravity and terrain following
            const terrainY = getTerrainHeight(playerState.position.x, playerState.position.z);
            const groundY = terrainY + 1.7;
            
            playerState.velocity.y -= 0.004;
            playerState.position.y += playerState.velocity.y;
            
            if (playerState.position.y <= groundY) {
                playerState.position.y = groundY;
                playerState.velocity.y = 0;
                playerState.isGrounded = true;
            }
            
            if (deviceMode === 'computer' && keys['Space']) { jump(); keys['Space'] = false; }
            
            camera.position.copy(playerState.position);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = playerState.rotation.y;
            camera.rotation.x = playerState.rotation.x;
            
            if (player) player.position.copy(playerState.position);
            
            // Update sword position and animation
            if (swordMesh) {
                if (swordSwinging) {
                    swordSwingTime += dt;
                    
                    // Sword swing animation (300ms total)
                    const swingDuration = 300;
                    const progress = Math.min(swordSwingTime / swingDuration, 1);
                    
                    // Swing arc from right to left
                    const swingAngle = Math.sin(progress * Math.PI) * 1.5;
                    
                    // Position sword in front of camera
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    
                    const right = new THREE.Vector3();
                    right.crossVectors(camera.up, dir).normalize();
                    
                    // Start position (right side)
                    const startOffset = 0.4 - progress * 0.6;
                    
                    swordMesh.position.copy(camera.position);
                    swordMesh.position.add(dir.clone().multiplyScalar(0.5));
                    swordMesh.position.add(right.clone().multiplyScalar(startOffset));
                    swordMesh.position.y -= 0.3;
                    
                    // Rotate sword during swing
                    swordMesh.rotation.set(
                        camera.rotation.x - 0.5 + swingAngle * 0.3,
                        camera.rotation.y + swingAngle,
                        -0.3 + swingAngle * 0.5
                    );
                    
                    if (progress >= 1) {
                        swordSwinging = false;
                        swordMesh.visible = false;
                    }
                }
            }
        }
        
        function updateEnemies(dt) {
            enemies.forEach((e, idx) => {
                if (!e.mesh || e.dying) return;
                
                const toPlayer = playerState.position.clone().sub(e.mesh.position);
                toPlayer.y = 0;
                const dist = toPlayer.length();
                toPlayer.normalize();
                
                e.mesh.lookAt(new THREE.Vector3(playerState.position.x, e.mesh.position.y, playerState.position.z));
                
                let isMoving = false;
                
                if (dist > 1.3) {
                    // Calculate new position
                    let newX = e.mesh.position.x + toPlayer.x * e.speed * dt;
                    let newZ = e.mesh.position.z + toPlayer.z * e.speed * dt;
                    
                    // Check collision with other enemies
                    let canMove = true;
                    enemies.forEach((other, otherIdx) => {
                        if (idx === otherIdx || !other.mesh) return;
                        
                        const dx = newX - other.mesh.position.x;
                        const dz = newZ - other.mesh.position.z;
                        const distToOther = Math.sqrt(dx * dx + dz * dz);
                        
                        // If too close to another enemy, push apart
                        if (distToOther < 1.0) {
                            canMove = false;
                            // Push away from the other enemy
                            if (distToOther > 0.1) {
                                const pushX = (dx / distToOther) * 0.02;
                                const pushZ = (dz / distToOther) * 0.02;
                                e.mesh.position.x += pushX;
                                e.mesh.position.z += pushZ;
                            }
                        }
                    });
                    
                    if (canMove) {
                        e.mesh.position.x = newX;
                        e.mesh.position.z = newZ;
                        isMoving = true;
                    }
                }
                
                // Update Y position to terrain height (with offset to prevent leg clipping)
                const terrainY = getTerrainHeight(e.mesh.position.x, e.mesh.position.z);
                e.mesh.position.y = terrainY + 0.15;
                
                // Animate arms and legs while moving
                if (isMoving && e.leftArm && e.rightArm && e.leftLeg && e.rightLeg) {
                    e.animTime += dt * 0.012;
                    const swing = Math.sin(e.animTime) * 0.6;
                    
                    // Arms swing opposite to legs
                    e.leftArm.rotation.x = swing;
                    e.rightArm.rotation.x = -swing;
                    
                    // Legs swing
                    e.leftLeg.rotation.x = -swing * 0.8;
                    e.rightLeg.rotation.x = swing * 0.8;
                } else if (e.leftArm && e.rightArm && e.leftLeg && e.rightLeg) {
                    // Reset to idle pose
                    e.leftArm.rotation.x *= 0.9;
                    e.rightArm.rotation.x *= 0.9;
                    e.leftLeg.rotation.x *= 0.9;
                    e.rightLeg.rotation.x *= 0.9;
                }
                
                if (dist < 1.8 && e.attackCooldown <= 0) {
                    damagePlayer(e.damage);
                    e.attackCooldown = 1500;
                }
                
                e.attackCooldown -= dt;
            });
        }
        
        function updateBoss(dt) {
            if (!boss || !boss.mesh) return;
            
            const toPlayer = playerState.position.clone().sub(boss.mesh.position);
            toPlayer.y = 0;
            const dist = toPlayer.length();
            toPlayer.normalize();
            
            boss.mesh.lookAt(new THREE.Vector3(playerState.position.x, boss.mesh.position.y, playerState.position.z));
            
            let isMoving = false;
            
            if (dist > 2) {
                boss.mesh.position.x += toPlayer.x * boss.speed * dt;
                boss.mesh.position.z += toPlayer.z * boss.speed * dt;
                isMoving = true;
            }
            
            // Update Y position to terrain height (with offset to prevent leg clipping)
            const terrainY = getTerrainHeight(boss.mesh.position.x, boss.mesh.position.z);
            boss.mesh.position.y = terrainY + 0.25;
            
            // Animate arms and legs
            if (isMoving && boss.leftArm && boss.rightArm && boss.leftLeg && boss.rightLeg) {
                boss.animTime += dt * 0.008;
                const swing = Math.sin(boss.animTime) * 0.5;
                
                boss.leftArm.rotation.x = swing;
                boss.rightArm.rotation.x = -swing;
                boss.leftLeg.rotation.x = -swing * 0.7;
                boss.rightLeg.rotation.x = swing * 0.7;
            }
            
            if (dist < 3 && boss.attackCooldown <= 0) {
                damagePlayer(boss.damage);
                boss.attackCooldown = 2000;
            }
            
            boss.attackCooldown -= dt;
        }
        
        function updateProjectiles(dt) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.mesh.position.add(p.direction.clone().multiplyScalar(p.speed * dt / 16));
                p.life -= dt;

                // Create particle trail
                p.trailTimer = (p.trailTimer || 0) + dt;
                if (p.trailTimer > 30 && p.color) {
                    p.trailTimer = 0;
                    createProjectileTrail(p.mesh.position.clone(), p.color);
                }

                let hitSomething = false;

                enemies.forEach(e => {
                    if (!e.mesh || hitSomething) return;
                    if (p.mesh.position.distanceTo(e.mesh.position) < 0.9) {
                        damageEnemy(e, p.damage, false);
                        // Explosion particles on impact
                        const impactPos = p.mesh.position.clone();
                        impactPos.y += 0.5;
                        createExplosionParticles(impactPos, p.color || 0xff4400, 0xffaa00);
                        p.life = 0;
                        hitSomething = true;
                    }
                });

                if (boss && boss.mesh && p.mesh.position.distanceTo(boss.mesh.position) < 1.4) {
                    damageBoss(p.damage, false);
                    // Big explosion on boss
                    const impactPos = p.mesh.position.clone();
                    createExplosionParticles(impactPos, p.color || 0xff0000, 0xff6600);
                    p.life = 0;
                    hitSomething = true;
                }

                // PvP: Check for hits on other players in multiplayer mode
                if (gameMode === 'multiplayer' && isInMatch && !isDead && !hitSomething) {
                    otherPlayers.forEach((playerData, playerId) => {
                        if (!playerData.mesh || playerData.data.health <= 0 || hitSomething) return;

                        const otherPos = playerData.mesh.position.clone();
                        otherPos.y += 1.0;

                        if (p.mesh.position.distanceTo(otherPos) < 1.2) {
                            // Hit! Send damage to server
                            if (partySocket && partySocket.readyState === WebSocket.OPEN) {
                                partySocket.send(JSON.stringify({
                                    type: 'damage',
                                    targetId: playerId,
                                    damage: p.damage
                                }));
                            }
                            // Visual feedback
                            const impactPos = p.mesh.position.clone();
                            createExplosionParticles(impactPos, p.color || 0xff4400, 0xffaa00);
                            p.life = 0;
                            hitSomething = true;
                        }
                    });
                }

                if (p.life <= 0) {
                    // Fizzle particles if it didn't hit anything
                    if (!hitSomething) {
                        createParticles(p.mesh.position.clone(), p.color || 0xaaaaaa, 5, 0.02, 0.04, 200, 0.5);
                    }
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }
        }
        
        function updateCoins(dt) {
            const collectRange = settings.autoCollectCoins ? 2.5 : 1;
            
            for (let i = coins.length - 1; i >= 0; i--) {
                const c = coins[i];
                
                c.mesh.rotation.z += 0.02;
                const baseY = c.baseY || 0.5;
                c.mesh.position.y = baseY + Math.sin(Date.now() * 0.003 + c.bobOffset) * 0.08;
                
                const dx = c.mesh.position.x - playerState.position.x;
                const dz = c.mesh.position.z - playerState.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist < collectRange) {
                    inventory.coins += c.value;
                    
                    const div = document.createElement('div');
                    div.className = 'coin-pickup';
                    div.textContent = '+' + c.value + ' üí∞';
                    div.style.left = '50%';
                    div.style.top = '35%';
                    document.body.appendChild(div);
                    setTimeout(() => div.remove(), 1000);
                    
                    scene.remove(c.mesh);
                    coins.splice(i, 1);
                    updateHUD();
                }
            }
        }
        
        function updateCooldowns(dt) {
            for (const id in itemCooldowns) {
                if (itemCooldowns[id] > 0) itemCooldowns[id] -= dt;
            }
            
            if (playerState.energy < playerState.maxEnergy) {
                playerState.energy = Math.min(playerState.maxEnergy, playerState.energy + dt * 0.002);
            }
        }
        
        let lastTime = 0;
        let lastSaveTime = 0;
        function gameLoop(timestamp) {
            requestAnimationFrame(gameLoop);

            const dt = Math.min(timestamp - lastTime, 50);
            lastTime = timestamp;

            if (!gameRunning) {
                renderer.render(scene, camera);
                return;
            }

            updatePlayer(dt);
            updateProjectiles(dt);
            updateCooldowns(dt);
            updateParticles(dt);
            updateHUD();

            // Mode-specific updates
            if (gameMode === 'singleplayer') {
                updateEnemies(dt);
                updateBoss(dt);
                updateCoins(dt);
                updateMinimap();
            } else if (gameMode === 'multiplayer' && isInMatch) {
                updateOtherPlayers(dt);
                renderPlayerNameplates();
                updateMatchTimer();
            }

            // Auto-save coins every 15 seconds
            if (timestamp - lastSaveTime > 15000) {
                lastSaveTime = timestamp;
                saveCoinsToCloud();
            }

            renderer.render(scene, camera);
        }
        
        function startGame() {
            if (gameMode === 'multiplayer') {
                startMultiplayerGame();
                return;
            }

            // Singleplayer mode
            enterFullscreen();
            document.getElementById('menu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('coinsDisplay').style.display = 'block';
            document.getElementById('statsPanel').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('hotbar').style.display = 'flex';

            setupInput();

            if (deviceMode === 'mobile') {
                document.getElementById('mobileControls').style.display = 'block';
            } else {
                // Request pointer lock - if it fails, user can click canvas to lock
                renderer.domElement.requestPointerLock();
            }

            gameRunning = true;
            startWave();
        }

        // ============ MULTIPLAYER FUNCTIONS ============
        function startMultiplayerGame() {
            enterFullscreen();
            document.getElementById('menu').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'flex';
            document.getElementById('lobbyStatus').textContent = 'Connecting to server...';

            connectToMultiplayer();
        }

        function connectToMultiplayer() {
            const roomId = 'main-arena'; // Default room

            // Create WebSocket connection to PartyKit
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${PARTYKIT_HOST}/parties/shatterrealms/${roomId}`;

            try {
                partySocket = new WebSocket(wsUrl);

                partySocket.onopen = () => {
                    console.log('Connected to multiplayer server');
                    document.getElementById('lobbyStatus').textContent = 'Connected! Joining game...';

                    // Send join message
                    const weapon = hotbar[selectedSlot] || 'sword';
                    partySocket.send(JSON.stringify({
                        type: 'join',
                        name: myPlayerName,
                        weapon: weapon
                    }));
                };

                partySocket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    handleServerMessage(data);
                };

                partySocket.onclose = () => {
                    console.log('Disconnected from server');
                    if (isInMatch) {
                        showDisconnectedMessage();
                    }
                };

                partySocket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    document.getElementById('lobbyStatus').textContent = 'Connection failed. Retrying...';
                    setTimeout(connectToMultiplayer, 3000);
                };
            } catch (e) {
                console.error('Failed to connect:', e);
                document.getElementById('lobbyStatus').textContent = 'Connection failed. Check your internet.';
            }
        }

        function handleServerMessage(data) {
            switch (data.type) {
                case 'game_state':
                    handleGameState(data);
                    break;
                case 'player_joined':
                    handlePlayerJoined(data.player);
                    break;
                case 'player_left':
                    handlePlayerLeft(data.playerId, data.playerName);
                    break;
                case 'player_position':
                    handlePlayerPosition(data);
                    break;
                case 'player_attack':
                    handlePlayerAttack(data);
                    break;
                case 'player_damaged':
                    handlePlayerDamaged(data);
                    break;
                case 'player_killed':
                    handlePlayerKilled(data);
                    break;
                case 'player_respawned':
                    handlePlayerRespawned(data);
                    break;
                case 'match_start':
                    handleMatchStart(data);
                    break;
                case 'time_update':
                    matchTimeRemaining = data.timeRemaining;
                    updateMatchTimer();
                    break;
                case 'match_end':
                    handleMatchEnd(data);
                    break;
            }
        }

        function handleGameState(data) {
            myPlayerId = data.playerId;
            matchTimeRemaining = data.timeRemaining;

            // Add existing players
            data.players.forEach(player => {
                if (player.id !== myPlayerId) {
                    createOtherPlayer(player);
                }
            });

            // Update lobby display
            updateLobbyDisplay(data.players);

            // Transition to game
            setTimeout(() => {
                startMultiplayerMatch();
            }, 1000);
        }

        function handlePlayerJoined(player) {
            if (player.id !== myPlayerId) {
                createOtherPlayer(player);
                showKillFeedMessage(`${player.name} joined the game`);
            }
        }

        function handlePlayerLeft(playerId, playerName) {
            removeOtherPlayer(playerId);
            showKillFeedMessage(`${playerName} left the game`);
        }

        function handlePlayerPosition(data) {
            const playerData = otherPlayers.get(data.playerId);
            if (playerData) {
                // Smoothly interpolate position
                playerData.targetPosition = new THREE.Vector3(data.position.x, data.position.y, data.position.z);
                playerData.targetRotation = data.rotation.y;
                playerData.data.health = data.health;
                updateOtherPlayerHealthbar(data.playerId);
            }
        }

        function handlePlayerAttack(data) {
            // Show attack animation for other player
            const playerData = otherPlayers.get(data.playerId);
            if (playerData) {
                // Create attack visual effect
                createAttackEffect(data.position, data.weapon);
            }
        }

        function handlePlayerDamaged(data) {
            if (data.targetId === myPlayerId) {
                // We got hit!
                const finalDamage = Math.max(1, data.damage - playerState.defense);
                playerState.health = data.health;
                showDamageNumber(camera.position, finalDamage, true);

                if (playerState.health <= 0) {
                    handleMyDeath(data.attackerId);
                }
            } else {
                // Another player got hit
                const playerData = otherPlayers.get(data.targetId);
                if (playerData) {
                    playerData.data.health = data.health;
                    updateOtherPlayerHealthbar(data.targetId);
                    showDamageNumber(playerData.mesh.position, data.damage, false);
                }
            }
        }

        function handlePlayerKilled(data) {
            showKillFeedMessage(`${data.killerName} killed ${data.targetName}`);

            if (data.killerId === myPlayerId) {
                pvpStats.kills++;
            }
            if (data.targetId === myPlayerId) {
                pvpStats.deaths++;
            }
        }

        function handlePlayerRespawned(data) {
            if (data.playerId === myPlayerId) {
                // We respawned
                playerState.health = data.health;
                playerState.position.set(data.position.x, data.position.y, data.position.z);
                isDead = false;
                document.getElementById('respawnTimer').style.display = 'none';
            } else {
                const playerData = otherPlayers.get(data.playerId);
                if (playerData) {
                    playerData.mesh.position.set(data.position.x, data.position.y, data.position.z);
                    playerData.data.health = data.health;
                    playerData.mesh.visible = true;
                    updateOtherPlayerHealthbar(data.playerId);
                }
            }
        }

        function handleMatchStart(data) {
            matchTimeRemaining = data.matchDuration;
            pvpStats = { kills: 0, deaths: 0 };
            showKillFeedMessage('Match started!');
        }

        function handleMatchEnd(data) {
            isInMatch = false;
            gameRunning = false;

            // Show match end screen
            document.getElementById('matchEndScreen').style.display = 'flex';
            document.getElementById('winnerName').textContent = `Winner: ${data.winnerName} (${data.winnerKills} kills)`;

            if (data.winnerId === myPlayerId) {
                inventory.coins += data.reward;
                document.getElementById('rewardText').textContent = `You won! +${data.reward} coins`;
                saveToCloud();
            } else {
                document.getElementById('rewardText').textContent = 'Better luck next time!';
            }

            // Build final scoreboard
            let scoreboardHtml = '<div class="scoreboard-header"><span class="player-name">Player</span><span class="player-kills">Kills</span><span class="player-deaths">Deaths</span></div>';
            data.scoreboard.forEach((p, i) => {
                const isMe = p.id === myPlayerId;
                const isWinner = i === 0;
                scoreboardHtml += `<div class="scoreboard-row ${isMe ? 'me' : ''} ${isWinner ? 'winner' : ''}">
                    <span class="player-name">${p.name}</span>
                    <span class="player-kills">${p.kills}</span>
                    <span class="player-deaths">${p.deaths}</span>
                </div>`;
            });
            document.getElementById('finalScoreboard').innerHTML = scoreboardHtml;
        }

        function handleMyDeath(killerId) {
            isDead = true;
            pvpStats.deaths++;
            document.getElementById('respawnTimer').style.display = 'block';

            let countdown = 5;
            document.getElementById('respawnTimer').textContent = countdown;

            const respawnInterval = setInterval(() => {
                countdown--;
                document.getElementById('respawnTimer').textContent = countdown;

                if (countdown <= 0) {
                    clearInterval(respawnInterval);
                    // Request respawn from server
                    if (partySocket && partySocket.readyState === WebSocket.OPEN) {
                        partySocket.send(JSON.stringify({ type: 'respawn' }));
                    }
                }
            }, 1000);
        }

        function startMultiplayerMatch() {
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('coinsDisplay').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('hotbar').style.display = 'flex';
            document.getElementById('matchTimer').style.display = 'block';
            document.getElementById('killFeed').style.display = 'block';

            // Hide singleplayer stats panel (wave/score)
            document.getElementById('statsPanel').style.display = 'none';

            setupInput();

            if (deviceMode === 'mobile') {
                document.getElementById('mobileControls').style.display = 'block';
            } else {
                renderer.domElement.requestPointerLock();
            }

            isInMatch = true;
            gameRunning = true;
            isDead = false;

            // Reset player position
            playerState.position.set(Math.random() * 40 - 20, 1.7, Math.random() * 40 - 20);
            playerState.health = playerState.maxHealth;
            playerState.energy = playerState.maxEnergy;

            // Start position sync
            startPositionSync();
        }

        function startPositionSync() {
            // Send position updates 30 times per second
            setInterval(() => {
                if (partySocket && partySocket.readyState === WebSocket.OPEN && isInMatch && !isDead) {
                    partySocket.send(JSON.stringify({
                        type: 'position',
                        position: {
                            x: playerState.position.x,
                            y: playerState.position.y,
                            z: playerState.position.z
                        },
                        rotation: {
                            x: playerState.rotation.x,
                            y: playerState.rotation.y
                        },
                        weapon: hotbar[selectedSlot] || 'sword'
                    }));
                }
            }, 33); // ~30fps
        }

        function createOtherPlayer(playerData) {
            // Create a simple player mesh (humanoid shape)
            const group = new THREE.Group();

            // Body
            const bodyGeo = new THREE.CapsuleGeometry(0.3, 0.8, 4, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x4444ff });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.8;
            group.add(body);

            // Head
            const headGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.6;
            group.add(head);

            group.position.set(playerData.position.x, playerData.position.y - 1.7, playerData.position.z);
            scene.add(group);

            otherPlayers.set(playerData.id, {
                mesh: group,
                targetPosition: new THREE.Vector3(playerData.position.x, playerData.position.y, playerData.position.z),
                targetRotation: 0,
                data: playerData
            });
        }

        function removeOtherPlayer(playerId) {
            const playerData = otherPlayers.get(playerId);
            if (playerData) {
                scene.remove(playerData.mesh);
                otherPlayers.delete(playerId);
            }
        }

        function updateOtherPlayerHealthbar(playerId) {
            // Health bars are rendered in the game loop
        }

        function updateOtherPlayers(dt) {
            otherPlayers.forEach((playerData, playerId) => {
                // Interpolate position
                if (playerData.targetPosition) {
                    playerData.mesh.position.lerp(
                        new THREE.Vector3(
                            playerData.targetPosition.x,
                            playerData.targetPosition.y - 1.7,
                            playerData.targetPosition.z
                        ),
                        0.1
                    );
                }

                // Interpolate rotation
                if (playerData.targetRotation !== undefined) {
                    playerData.mesh.rotation.y = playerData.targetRotation;
                }
            });
        }

        function renderPlayerNameplates() {
            // Render nameplates above other players
            otherPlayers.forEach((playerData, playerId) => {
                const pos = playerData.mesh.position.clone();
                pos.y += 2.2;

                // Project to screen
                const screenPos = pos.clone().project(camera);
                const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

                // Check if in front of camera
                if (screenPos.z < 1) {
                    // Create or update nameplate element
                    let nameplate = document.getElementById(`nameplate-${playerId}`);
                    if (!nameplate) {
                        nameplate = document.createElement('div');
                        nameplate.id = `nameplate-${playerId}`;
                        nameplate.className = 'other-player-nameplate';
                        nameplate.innerHTML = `
                            <div>${playerData.data.name}</div>
                            <div class="other-player-healthbar">
                                <div class="other-player-healthbar-fill" style="width: 100%"></div>
                            </div>
                        `;
                        document.body.appendChild(nameplate);
                    }

                    nameplate.style.left = x + 'px';
                    nameplate.style.top = y + 'px';
                    nameplate.style.transform = 'translate(-50%, -100%)';

                    // Update health bar
                    const healthPercent = (playerData.data.health / 100) * 100;
                    nameplate.querySelector('.other-player-healthbar-fill').style.width = healthPercent + '%';
                }
            });
        }

        function updateMatchTimer() {
            const minutes = Math.floor(matchTimeRemaining / 60000);
            const seconds = Math.floor((matchTimeRemaining % 60000) / 1000);
            document.getElementById('matchTimer').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function showKillFeedMessage(message) {
            const killFeed = document.getElementById('killFeed');
            const msgEl = document.createElement('div');
            msgEl.className = 'kill-message';
            msgEl.textContent = message;
            killFeed.appendChild(msgEl);

            setTimeout(() => {
                msgEl.remove();
            }, 3000);
        }

        function createAttackEffect(position, weapon) {
            // Visual effect for attacks
            const color = 0xff4444;
            createSparkParticles(new THREE.Vector3(position.x, position.y, position.z), color, 5);
        }

        function showDisconnectedMessage() {
            alert('Disconnected from server. Returning to menu.');
            backToMenuFromMultiplayer();
        }

        function updateLobbyDisplay(players) {
            const lobbyPlayersEl = document.getElementById('lobbyPlayers');
            lobbyPlayersEl.innerHTML = '';
            players.forEach(p => {
                const div = document.createElement('div');
                div.className = 'lobby-player';
                div.textContent = p.name;
                lobbyPlayersEl.appendChild(div);
            });
            document.getElementById('lobbyStatus').textContent = `${players.length} player(s) in game`;
        }

        function leaveLobby() {
            if (partySocket) {
                partySocket.close();
            }
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('menu').style.display = 'flex';
        }

        function playAgainMultiplayer() {
            document.getElementById('matchEndScreen').style.display = 'none';
            cleanupMultiplayer();
            startMultiplayerGame();
        }

        function backToMenuFromMultiplayer() {
            document.getElementById('matchEndScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('matchTimer').style.display = 'none';
            document.getElementById('killFeed').style.display = 'none';
            cleanupMultiplayer();
            backToMenu();
        }

        function cleanupMultiplayer() {
            if (partySocket) {
                partySocket.close();
                partySocket = null;
            }
            otherPlayers.forEach((playerData, playerId) => {
                scene.remove(playerData.mesh);
                const nameplate = document.getElementById(`nameplate-${playerId}`);
                if (nameplate) nameplate.remove();
            });
            otherPlayers.clear();
            isInMatch = false;
            isDead = false;
        }

        // Toggle scoreboard with TAB key
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Tab' && isInMatch) {
                e.preventDefault();
                document.getElementById('scoreboard').style.display = 'block';
                updateScoreboardDisplay();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Tab') {
                document.getElementById('scoreboard').style.display = 'none';
            }
        });

        function updateScoreboardDisplay() {
            const content = document.getElementById('scoreboardContent');
            let html = '';

            // Add self
            html += `<div class="scoreboard-row me">
                <span class="player-name">${myPlayerName} (You)</span>
                <span class="player-kills">${pvpStats.kills}</span>
                <span class="player-deaths">${pvpStats.deaths}</span>
            </div>`;

            // Add other players
            otherPlayers.forEach((playerData) => {
                html += `<div class="scoreboard-row">
                    <span class="player-name">${playerData.data.name}</span>
                    <span class="player-kills">${playerData.data.kills || 0}</span>
                    <span class="player-deaths">${playerData.data.deaths || 0}</span>
                </div>`;
            });

            content.innerHTML = html;
        }
        
        function restartGame() {
            playerState.position.set(0, 1.7, 0);
            playerState.velocity.set(0, 0, 0);
            playerState.rotation = { x: 0, y: 0 };
            playerState.health = playerState.maxHealth;
            playerState.energy = playerState.maxEnergy;
            playerState.score = 0;
            playerState.kills = 0;
            playerState.isGrounded = true;
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];
            
            if (boss) { scene.remove(boss.mesh); boss = null; }
            document.getElementById('bossHealth').style.display = 'none';
            
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles = [];

            particles.forEach(p => scene.remove(p.mesh));
            particles = [];

            coins.forEach(c => scene.remove(c.mesh));
            coins = [];

            itemCooldowns = {};
            currentWave = 1;
            waveInProgress = false;
            
            document.getElementById('gameOver').style.display = 'none';
            gameRunning = true;
            startWave();
        }
        
        function backToMenu() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('menu').style.display = 'flex';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('coinsDisplay').style.display = 'none';
            document.getElementById('statsPanel').style.display = 'none';
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('hotbar').style.display = 'none';
            document.getElementById('mobileControls').style.display = 'none';

            document.getElementById('menuCoins').textContent = 'üí∞ ' + inventory.coins;
            saveCoinsToCloud(); // Save coins when returning to menu
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];
            if (boss) { scene.remove(boss.mesh); boss = null; }
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles = [];
            coins.forEach(c => scene.remove(c.mesh));
            coins = [];
            
            currentWave = 1;
            waveInProgress = false;
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        init();
        gameLoop(0);
    </script>
</body>
</html>
